<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Eudyptula Task1 | Connected</title>
<meta name=keywords content="Eudyptula,linux"><meta name=description content="Task 1 for Eudyptula challenge"><meta name=author content="ayedaemon"><link rel=canonical href=https://ayedaemon.github.io/post/2022/05/eudyptula-task-1/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://ayedaemon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ayedaemon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ayedaemon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ayedaemon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ayedaemon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Eudyptula Task1"><meta property="og:description" content="Task 1 for Eudyptula challenge"><meta property="og:type" content="article"><meta property="og:url" content="https://ayedaemon.github.io/post/2022/05/eudyptula-task-1/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-25T15:14:27+05:30"><meta property="article:modified_time" content="2023-11-07T00:11:41+05:30"><meta property="og:site_name" content="Connected"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/05/eudyptula-task-7/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2022/09/eudyptula-task-6/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2022/06/eudyptula-task-5/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2022/06/eudyptula-task-4/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2022/06/eudyptula-task-3/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2022/06/eudyptula-task-2/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Eudyptula Task1"><meta name=twitter:description content="Task 1 for Eudyptula challenge"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ayedaemon.github.io/post/"},{"@type":"ListItem","position":2,"name":"Eudyptula Task1","item":"https://ayedaemon.github.io/post/2022/05/eudyptula-task-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Eudyptula Task1","name":"Eudyptula Task1","description":"Task 1 for Eudyptula challenge","keywords":["Eudyptula","linux"],"articleBody":"What is this? The Eudyptula Challenge is a series of programming exercises for the Linux kernel, that start from a very basic “Hello world” kernel module, moving on up in complexity to getting patches accepted into the main Linux kernel source tree.\nUnfortunately, this project is not accepting any new applicants right now. So I decided to gather tasks details from other online sources and complete them locally.\nTask-1 This is Task 01 of the Eudyptula Challenge ------------------------------------------ Write a Linux kernel module, and stand-alone Makefile, that when loaded prints to the kernel debug log level, \"Hello World!\" Be sure to make the module be able to be unloaded as well. The Makefile should build the kernel module against the source for the currently running kernel, or, use an environment variable to specify what kernel tree to build it against. Linux provides a powerful and expansive API for applications, but sometimes that’s not enough. Interacting with a piece of hardware or conducting operations that require access to privileged information in the system can require a kernel module. In this task we have to write a kernel module that basically prints “Hello World!”.\nWhat is a Kernel Module? A Linux kernel module is a piece of compiled binary code that is inserted directly into the Linux kernel, running at ring 0, the lowest and least protected ring of execution in the x86–64 processor. Code here runs completely unchecked but operates at incredible speed and has access to everything in the system.\nA loadable kernel module (LKM) is a mechanism for adding code to, or removing code from, the Linux kernel at run time. They are ideal for device drivers, enabling the kernel to communicate with the hardware without it having to know how the hardware works. The alternative to LKMs would be to build the code for each and every driver into the Linux kernel.\nWithout this modular capability, the Linux kernel would be very large, as it would have to support every driver that would ever be needed for the system to work properly. You would also have to rebuild the kernel every time you wanted to add new hardware or update a device driver.\nKernel modules run in kernel space and applications run in user space, and both kernel space and user space have their own unique memory address spaces that do not overlap. This approach ensures that applications running in user space have a consistent view of the hardware, regardless of the hardware platform. The kernel services are then made available to the user space in a controlled way through the use of system calls. The kernel also prevents individual user-space applications from conflicting with each other or from accessing restricted resources through the use of protection levels (e.g., superuser versus regular user permissions).\nPrepare system for building LKMs The system must be prepared to build kernel code, and to do this you must have the Linux headers installed on your device. On a typical Linux desktop machine you can use your package manager to locate the correct package to install. For example, under 64-bit Centos7 you can use the below code. Sometimes the package manager provides multiple version of headers, then you must install the headers for the exact version of your kernel build.\n# Update system sudo yum update -y # Install headers sudo yum install -y kernel-devel kernel-headers # Check headers ls /usr/src/kernels/$(uname -r) Write first module - Hello World The LKM code is very different from the regular user-space C program. Typical computer programs are reasonably straightforward. A loader allocates the memory for the program, then loads the program and other shared libraries into memory. Instruction Execution begins at some entrypoint (typically main() in C/C++ programs). On exit, OS identifies any memory leaks and frees lost memory to pool.\nThe LKMs are not applications - For a start there is no main() and no printf() functions!!. They also do not have any automatic cleanup. Interestingly, they also do not have any floating-point support. In LKMs, the kernel module have atleast 2 entrypoint like functions; These functions executes at loading or unloading of the LKM.\nThe above can be a lot to digest all at once but it is important that they are addressed. Now, we can wrap our minds around the below code and understand how it works.\nTo start with, we need a HelloWorld.c file with 2 function definitions - hello_world_init() and hello_world_exit(). We then register first function to be executed when the LKM is loaded in the memory and the later is registered to be executed at unloading of the LKM. There are few extra functions that configure the metadata for the created module.\n#include #include #include MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"ayedaemon\"); MODULE_DESCRIPTION(\"Eudyptula task1\"); static int hello_world_init(void) { printk(KERN_DEBUG \"Hello World!\\n\"); return 0; } static void hello_world_exit(void) { printk(KERN_DEBUG \"Bye Bye World!\\n\"); } module_init(hello_world_init); module_exit(hello_world_exit); In kernel space, we do not have access to printf() functions, instead we have a very similar in usage function called printk()1, and you can call it from anywhere withing the LKM code. Read more about printk() from here.2\nNow that we’ve constructed the simplest possible module, let’s understand the important parts in detail:\nThe “includes” cover the required header files necessary for Linux kernel development.\nMODULE_LICENSE can be set to a variety of values depending on the license3 of the module. Other following 2 lines are also a part of module metadata.\nAt the end of the file, we call module_init and module_exit to tell the kernel which functions are or loading and unloading functions. This gives us the freedom to name the functions whatever we like.\n… make Makefile A Makefile is required to build the kernel module — in fact, it is a special kbuild Makefile. Below is the Makefile used to build the above LKM code.\nobj-m += HelloWorld.o KDIR := /lib/modules/$(shell uname -r)/build all: $(MAKE) -C $(KDIR) M=$(PWD) modules clean: $(MAKE) -C $(KDIR) M=$(PWD) clean First line of this Makefile is called goal definition and it defines the module to be built. The rest of the Makefile is a regular makefile. Here, -C option switches the directory to the kernel directory before performing any make tasks. The M=$(PWD) variable assignment tells the make command where the actual project files exist, which helps make to return back to the project directory from kernel directory.\nAll going well, the process to build the kernel module should be straightforward, provided that you have installed the Linux headers as described earlier. The steps are as follows:\n[vagrant@centos7 task-1]$ ls HelloWorld.c Makefile README.md [vagrant@centos7 task-1]$ make make -C /lib/modules/3.10.0-1160.62.1.el7.x86_64/build M=/vagrant_data/task-1 modules make[1]: Entering directory `/usr/src/kernels/3.10.0-1160.62.1.el7.x86_64' CC [M] /vagrant_data/task-1/HelloWorld.o Building modules, stage 2. MODPOST 1 modules CC /vagrant_data/task-1/HelloWorld.mod.o LD [M] /vagrant_data/task-1/HelloWorld.ko make[1]: Leaving directory `/usr/src/kernels/3.10.0-1160.62.1.el7.x86_64' Once the module is successfully buit, we can test it by loading the module using insmod command.\n[vagrant@centos7 task-1]$ ls -l *.ko -rw-r--r--. 1 vagrant vagrant 101880 May 25 18:03 HelloWorld.ko [vagrant@centos7 task-1]$ sudo insmod HelloWorld.ko [vagrant@centos7 task-1]$ dmesg | tail -1 [35803.038855] Hello World! [vagrant@centos7 task-1]$ lsmod | head -2 Module Size Used by HelloWorld 12496 0 The metadata information coded in the LKM can be checked with modinfo command.\n[vagrant@centos7 task-1]$ modinfo HelloWorld.ko filename: /vagrant_data/task-1/HelloWorld.ko description: Eudyptula task1 author: ayedaemon license: GPL retpoline: Y rhelversion: 7.9 srcversion: 7969E1C9B651C03B53BA6B2 depends: vermagic: 3.10.0-1160.62.1.el7.x86_64 SMP mod_unload modversions At last, the module can be unloaded easily with rmmod command.\n[vagrant@centos7 task-1]$ sudo rmmod HelloWorld.ko [vagrant@centos7 task-1]$ dmesg | tail -2 [35803.038855] Hello World! [35983.753824] Bye Bye World! Conclusion Hopefully you have built your first loadable kernel module (LKM). Despite the simplicity of the functionality of this module there was a lot of material to cover — by the end of this article: you should have a broad idea of how loadable kernel modules work; you should have your system configured to build, load and unload such modules; and, you should be able to define custom parameters for your LKMs.\nJust remember that you are completely on your own in kernel land. There are no backstops or second chances for your code. If you’re quoting a project for a client, be sure to double, if not triple, the anticipated debugging time. Kernel code has to be as perfect as possible to ensure the integrity and reliability of the systems that will run it.\nIf there is no \\n character at the end of the printk() string, then the next printk() string will also be printed in dmesg. I was able to see both Hello World! and Bye Bye World at the same time when I was either loading or unloading the module. ↩︎\nhttps://www.kernel.org/doc/html/latest/core-api/printk-basics.html ↩︎\nLinux kernel licensing rules - https://www.kernel.org/doc/html/latest/process/license-rules.html ↩︎\n","wordCount":"1443","inLanguage":"en","datePublished":"2022-05-25T15:14:27+05:30","dateModified":"2023-11-07T00:11:41+05:30","author":[{"@type":"Person","name":"ayedaemon"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://ayedaemon.github.io/post/2022/05/eudyptula-task-1/"},"publisher":{"@type":"Organization","name":"Connected","logo":{"@type":"ImageObject","url":"https://ayedaemon.github.io/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://ayedaemon.github.io/ accesskey=h title="Connected (Alt + H)">Connected</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://ayedaemon.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://ayedaemon.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ayedaemon.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ayedaemon.github.io/series/ title=Series><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ayedaemon.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ayedaemon.github.io/post/>Posts</a></div><h1 class=post-title>Eudyptula Task1</h1><div class=post-description>Task 1 for Eudyptula challenge</div><div class=post-meta><span title='2022-05-25 15:14:27 +0530 +0530'>May 25, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1443 words&nbsp;·&nbsp;ayedaemon&nbsp;|&nbsp;<a href=https://github.com/ayedaemon/ayedaemon.github.io/tree/main/content/post/2022/05/Eudyptula-task-1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#what-is-this>What is this?</a></li><li><a href=#task-1>Task-1</a></li><li><a href=#what-is-a-kernel-module>What is a Kernel Module?</a></li><li><a href=#prepare-system-for-building-lkms>Prepare system for building LKMs</a></li><li><a href=#write-first-module---hello-world>Write first module - Hello World</a></li><li><a href=#-make-makefile>&mldr; make Makefile</a></li><li><a href=#conclusion>Conclusion</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h3 id=what-is-this>What is this?<a hidden class=anchor aria-hidden=true href=#what-is-this>#</a></h3><blockquote><p>The <a href=http://eudyptula-challenge.org/>Eudyptula Challenge</a> is a series of programming exercises for the Linux kernel, that start from a very basic “Hello world” kernel module, moving on up in complexity to getting patches accepted into the main Linux kernel source tree.</p></blockquote><p>Unfortunately, this project is not accepting any new applicants right now. So I decided to gather tasks details from other online sources and complete them locally.</p><h3 id=task-1>Task-1<a hidden class=anchor aria-hidden=true href=#task-1>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>This is Task 01 of the Eudyptula Challenge
</span></span><span class=line><span class=cl>------------------------------------------
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Write a Linux kernel module, and stand-alone Makefile, that when loaded
</span></span><span class=line><span class=cl>prints to the kernel debug log level, &#34;Hello World!&#34;  Be sure to make
</span></span><span class=line><span class=cl>the module be able to be unloaded as well.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>The Makefile should build the kernel module against the source for the
</span></span><span class=line><span class=cl>currently running kernel, or, use an environment variable to specify
</span></span><span class=line><span class=cl>what kernel tree to build it against.
</span></span></code></pre></div><p>Linux provides a powerful and expansive API for applications, but sometimes that’s not enough. Interacting with a piece of hardware or conducting operations that require access to privileged information in the system can require a kernel module. In this task we have to write a kernel module that basically prints &ldquo;Hello World!&rdquo;.</p><h3 id=what-is-a-kernel-module>What is a Kernel Module?<a hidden class=anchor aria-hidden=true href=#what-is-a-kernel-module>#</a></h3><p>A Linux kernel module is a piece of compiled binary code that is inserted directly into the Linux kernel, running at ring 0, the lowest and least protected ring of execution in the x86–64 processor. Code here runs completely unchecked but operates at incredible speed and has access to everything in the system.</p><p>A loadable kernel module (LKM) is a mechanism for adding code to, or removing code from, the Linux kernel at run time. They are ideal for device drivers, enabling the kernel to communicate with the hardware without it having to know how the hardware works. The alternative to LKMs would be to build the code for each and every driver into the Linux kernel.</p><p>Without this modular capability, the Linux kernel would be very large, as it would have to support every driver that would ever be needed for the system to work properly. You would also have to rebuild the kernel every time you wanted to add new hardware or update a device driver.</p><p>Kernel modules run in kernel space and applications run in user space, and both kernel space and user space have their own unique memory address spaces that do not overlap. This approach ensures that applications running in user space have a consistent view of the hardware, regardless of the hardware platform. The kernel services are then made available to the user space in a controlled way through the use of system calls. The kernel also prevents individual user-space applications from conflicting with each other or from accessing restricted resources through the use of protection levels (e.g., superuser versus regular user permissions).</p><h3 id=prepare-system-for-building-lkms>Prepare system for building LKMs<a hidden class=anchor aria-hidden=true href=#prepare-system-for-building-lkms>#</a></h3><p>The system must be prepared to build kernel code, and to do this you must have the Linux headers installed on your device. On a typical Linux desktop machine you can use your package manager to locate the correct package to install. For example, under 64-bit Centos7 you can use the below code. Sometimes the package manager provides multiple version of headers, then you must install the headers for the exact version of your kernel build.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Update system</span>
</span></span><span class=line><span class=cl>sudo yum update -y
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Install headers</span>
</span></span><span class=line><span class=cl>sudo yum install -y kernel-devel kernel-headers
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Check headers</span>
</span></span><span class=line><span class=cl>ls /usr/src/kernels/<span class=k>$(</span>uname -r<span class=k>)</span>
</span></span></code></pre></div><h3 id=write-first-module---hello-world>Write first module - Hello World<a hidden class=anchor aria-hidden=true href=#write-first-module---hello-world>#</a></h3><p>The LKM code is very different from the regular user-space C program. Typical computer programs are reasonably straightforward. A loader allocates the memory for the program, then loads the program and other shared libraries into memory. Instruction Execution begins at some entrypoint (typically <code>main()</code> in C/C++ programs). On exit, OS identifies any memory leaks and frees lost memory to pool.</p><p>The LKMs are not applications - For a start there is no <code>main()</code> and no <code>printf()</code> functions!!. They also do not have any automatic cleanup. Interestingly, they also do not have any floating-point support. In LKMs, the kernel module have atleast 2 entrypoint like functions; These functions executes at loading or unloading of the LKM.</p><p>The above can be a lot to digest all at once but it is important that they are addressed. Now, we can wrap our minds around the below code and understand how it works.</p><p>To start with, we need a <code>HelloWorld.c</code> file with 2 function definitions - <code>hello_world_init()</code> and <code>hello_world_exit()</code>. We then register first function to be executed when the LKM is loaded in the memory and the later is registered to be executed at unloading of the LKM. There are few extra functions that configure the metadata for the created module.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/init.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/module.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/kernel.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>MODULE_LICENSE</span><span class=p>(</span><span class=s>&#34;GPL&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>MODULE_AUTHOR</span><span class=p>(</span><span class=s>&#34;ayedaemon&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>MODULE_DESCRIPTION</span><span class=p>(</span><span class=s>&#34;Eudyptula task1&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>hello_world_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>printk</span><span class=p>(</span><span class=n>KERN_DEBUG</span> <span class=s>&#34;Hello World!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>hello_world_exit</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>printk</span><span class=p>(</span><span class=n>KERN_DEBUG</span> <span class=s>&#34;Bye Bye World!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>module_init</span><span class=p>(</span><span class=n>hello_world_init</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>module_exit</span><span class=p>(</span><span class=n>hello_world_exit</span><span class=p>);</span>
</span></span></code></pre></div><p>In kernel space, we do not have access to <code>printf()</code> functions, instead we have a very similar in usage function called <code>printk()</code><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, and you can call it from anywhere withing the LKM code. Read more about <code>printk()</code> from <a href=https://www.kernel.org/doc/html/latest/core-api/printk-basics.html>here</a>.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><p>Now that we’ve constructed the simplest possible module, let’s understand the important parts in detail:</p><ul><li><p>The “includes” cover the required header files necessary for Linux kernel development.</p></li><li><p><code>MODULE_LICENSE</code> can be set to a variety of values depending on the license<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> of the module. Other following 2 lines are also a part of module metadata.</p></li><li><p>At the end of the file, we call module_init and module_exit to tell the kernel which functions are or loading and unloading functions. This gives us the freedom to name the functions whatever we like.</p></li></ul><h3 id=-make-makefile>&mldr; make Makefile<a hidden class=anchor aria-hidden=true href=#-make-makefile>#</a></h3><p>A Makefile is required to build the kernel module — in fact, it is a special <strong>kbuild</strong> Makefile. Below is the <code>Makefile</code> used to build the above LKM code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=nv>obj-m</span> <span class=o>+=</span> HelloWorld.o
</span></span><span class=line><span class=cl><span class=nv>KDIR</span> <span class=o>:=</span> /lib/modules/<span class=k>$(</span>shell uname -r<span class=k>)</span>/build
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>$(</span>MAKE<span class=k>)</span> -C <span class=k>$(</span>KDIR<span class=k>)</span> <span class=nv>M</span><span class=o>=</span><span class=k>$(</span>PWD<span class=k>)</span> modules
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>$(</span>MAKE<span class=k>)</span> -C <span class=k>$(</span>KDIR<span class=k>)</span> <span class=nv>M</span><span class=o>=</span><span class=k>$(</span>PWD<span class=k>)</span> clean
</span></span></code></pre></div><p>First line of this Makefile is called <em>goal definition</em> and it defines the module to be built. The rest of the Makefile is a regular makefile. Here, <code>-C</code> option switches the directory to the kernel directory before performing any make tasks. The <code>M=$(PWD)</code> variable assignment tells the make command where the actual project files exist, which helps make to return back to the project directory from kernel directory.</p><p>All going well, the process to build the kernel module should be straightforward, provided that you have installed the Linux headers as described earlier. The steps are as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>[vagrant@centos7 task-1]$ ls
</span></span><span class=line><span class=cl>HelloWorld.c  Makefile  README.md
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[vagrant@centos7 task-1]$ make
</span></span><span class=line><span class=cl>make -C /lib/modules/3.10.0-1160.62.1.el7.x86_64/build M=/vagrant_data/task-1 modules
</span></span><span class=line><span class=cl>make[1]: Entering directory `/usr/src/kernels/3.10.0-1160.62.1.el7.x86_64&#39;
</span></span><span class=line><span class=cl>  CC [M]  /vagrant_data/task-1/HelloWorld.o
</span></span><span class=line><span class=cl>  Building modules, stage 2.
</span></span><span class=line><span class=cl>  MODPOST 1 modules
</span></span><span class=line><span class=cl>  CC      /vagrant_data/task-1/HelloWorld.mod.o
</span></span><span class=line><span class=cl>  LD [M]  /vagrant_data/task-1/HelloWorld.ko
</span></span><span class=line><span class=cl>make[1]: Leaving directory `/usr/src/kernels/3.10.0-1160.62.1.el7.x86_64&#39;
</span></span></code></pre></div><p>Once the module is successfully buit, we can test it by loading the module using <code>insmod</code> command.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>[vagrant@centos7 task-1]$ ls -l *.ko
</span></span><span class=line><span class=cl>-rw-r--r--. 1 vagrant vagrant 101880 May 25 18:03 HelloWorld.ko
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[vagrant@centos7 task-1]$ sudo insmod HelloWorld.ko
</span></span><span class=line><span class=cl>[vagrant@centos7 task-1]$ dmesg | tail -1
</span></span><span class=line><span class=cl>[35803.038855] Hello World!
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[vagrant@centos7 task-1]$ lsmod | head -2
</span></span><span class=line><span class=cl>Module                  Size  Used by
</span></span><span class=line><span class=cl>HelloWorld             12496  0
</span></span></code></pre></div><p>The metadata information coded in the LKM can be checked with <code>modinfo</code> command.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>[vagrant@centos7 task-1]$ modinfo HelloWorld.ko
</span></span><span class=line><span class=cl>filename:       /vagrant_data/task-1/HelloWorld.ko
</span></span><span class=line><span class=cl>description:    Eudyptula task1
</span></span><span class=line><span class=cl>author:         ayedaemon
</span></span><span class=line><span class=cl>license:        GPL
</span></span><span class=line><span class=cl>retpoline:      Y
</span></span><span class=line><span class=cl>rhelversion:    7.9
</span></span><span class=line><span class=cl>srcversion:     7969E1C9B651C03B53BA6B2
</span></span><span class=line><span class=cl>depends:
</span></span><span class=line><span class=cl>vermagic:       3.10.0-1160.62.1.el7.x86_64 SMP mod_unload modversions
</span></span></code></pre></div><p>At last, the module can be unloaded easily with <code>rmmod</code> command.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>[vagrant@centos7 task-1]$ sudo rmmod HelloWorld.ko
</span></span><span class=line><span class=cl>[vagrant@centos7 task-1]$ dmesg | tail -2
</span></span><span class=line><span class=cl>[35803.038855] Hello World!
</span></span><span class=line><span class=cl>[35983.753824] Bye Bye World!
</span></span></code></pre></div><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>Hopefully you have built your first loadable kernel module (LKM). Despite the simplicity of the functionality of this module there was a lot of material to cover — by the end of this article: you should have a broad idea of how loadable kernel modules work; you should have your system configured to build, load and unload such modules; and, you should be able to define custom parameters for your LKMs.</p><p>Just remember that you are completely on your own in kernel land. There are no backstops or second chances for your code. If you’re quoting a project for a client, be sure to double, if not triple, the anticipated debugging time. Kernel code has to be as perfect as possible to ensure the integrity and reliability of the systems that will run it.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>If there is no <code>\n</code> character at the end of the <code>printk()</code> string, then the next <code>printk()</code> string will also be printed in dmesg. I was able to see both <code>Hello World!</code> and <code>Bye Bye World</code> at the same time when I was either loading or unloading the module.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://www.kernel.org/doc/html/latest/core-api/printk-basics.html>https://www.kernel.org/doc/html/latest/core-api/printk-basics.html</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Linux kernel licensing rules - <a href=https://www.kernel.org/doc/html/latest/process/license-rules.html>https://www.kernel.org/doc/html/latest/process/license-rules.html</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ayedaemon.github.io/tags/eudyptula/>Eudyptula</a></li><li><a href=https://ayedaemon.github.io/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=prev href=https://ayedaemon.github.io/post/2022/05/hands-on-intro-to-sbom/><span class=title>« Next</span><br><span>Hands-on Intro to SBOM</span>
</a><a class=next href=https://ayedaemon.github.io/post/2022/02/fileless-malwares-how-and-why/><span class=title>Prev »</span><br><span>File-less malwares: what and how</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://ayedaemon.github.io/>Connected</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>