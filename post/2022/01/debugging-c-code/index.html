<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Debugging C Code | Connected</title>
<meta name="keywords" content="C programming, Debugging">
<meta name="description" content="
How your x86 program starts up in linux
">
<meta name="author" content="ayedaemon">
<link rel="canonical" href="https://ayedaemon.github.io/post/2022/01/debugging-c-code/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ayedaemon.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ayedaemon.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ayedaemon.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ayedaemon.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://ayedaemon.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Debugging C Code" />
<meta property="og:description" content="
How your x86 program starts up in linux
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ayedaemon.github.io/post/2022/01/debugging-c-code/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-01-27T14:58:51+05:30" />
<meta property="article:modified_time" content="2021-01-27T14:58:51+05:30" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Debugging C Code"/>
<meta name="twitter:description" content="
How your x86 program starts up in linux
"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://ayedaemon.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Debugging C Code",
      "item": "https://ayedaemon.github.io/post/2022/01/debugging-c-code/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Debugging C Code",
  "name": "Debugging C Code",
  "description": " How your x86 program starts up in linux\n",
  "keywords": [
    "C programming", "Debugging"
  ],
  "articleBody": " How your x86 program starts up in linux\nIn this blog, I will assume that you have basic understanding of assembly language. If not, then you should consider learning it. Although I’ll try to explain things in the easiest terms as possible.\nBasic C program Let’s start with a basic C program…\nCODE: (Saving it with simple.c)\n#include int main() { printf(\"Hello main\"); return 0; } … and compile it the way we have always done it with gcc.\ngcc simple.c -o simple.out Now I have got a file simple.out which should be my executable binary.. I have a habit to check the file using file command to be more sure.\n$ file simple.out simple.out: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=11c9b757baf9a3a8271443682135b7488cb04e52, for GNU/Linux 3.2.0, not stripped And now we know that it is an ELF binary and dynamically linked.\nLet’s see what shared objects they use.\n$ ldd simple.out linux-vdso.so.1 (0x00007fffbc364000) libc.so.6 =\u003e /usr/lib/libc.so.6 (0x00007f5b0d6a7000) /lib64/ld-linux-x86-64.so.2 =\u003e /usr/lib64/ld-linux-x86-64.so.2 (0x00007f5b0d8b9000) The interesting one here is libc.so.6 =\u003e /usr/lib/libc.so.6 (0x00007f5b0d6a7000). This shared object is used in almost every linux command you know. On checking the man page for libc.. I came to know that it is the standard C library used in linux.\nThe question I am asking myself here is –\u003e Is this somehow responsible to execute the main() function in C programs.\nMaybe. We’ll see that later.\nLet’s decompile our simple binary. I can check the assembly code of the executable using objdump -d simple.out command on my terminal. It’ll give me a lot of output but right now I am concerned about the main() function… so I’ll just grep it.\n$ objdump -d simple.out | grep -A12 ':' 0000000000001139 : 1139:\t55 push %rbp 113a:\t48 89 e5 mov %rsp,%rbp 113d:\t48 8d 3d c0 0e 00 00 lea 0xec0(%rip),%rdi # 2004 \u003c_IO_stdin_used+0x4\u003e 1144:\tb8 00 00 00 00 mov $0x0,%eax 1149:\te8 e2 fe ff ff callq 1030 114e:\tb8 00 00 00 00 mov $0x0,%eax 1153:\t5d pop %rbp 1154:\tc3 retq 1155:\t66 2e 0f 1f 84 00 00 nopw %cs:0x0(%rax,%rax,1) 115c:\t00 00 00 115f:\t90 nop If you don’t understand assembly, I get what you are feeling right now\nBut you don’t need to understand it completely right now. You can look into some syntax and they’ll make sense in some time. Like callq 1030 - this looks like out printf() function. And we know before calling a function, you need to pass its arguments on the stack. That means the mov just above the callq statement is my string Hello main (which is the argument passed to printf())\nAnother Question –\u003e Is main() really the starting point of execution??\nOn further looking into the objdump -d simple.out command output… I can understand that there is another function_start that calls the main() function.\nDisassembly of section .text: 0000000000001040 \u003c_start\u003e: 1040:\tf3 0f 1e fa endbr64 1044:\t31 ed xor %ebp,%ebp 1046:\t49 89 d1 mov %rdx,%r9 1049:\t5e pop %rsi 104a:\t48 89 e2 mov %rsp,%rdx 104d:\t48 83 e4 f0 and $0xfffffffffffffff0,%rsp 1051:\t50 push %rax 1052:\t54 push %rsp 1053:\t4c 8d 05 76 01 00 00 lea 0x176(%rip),%r8 # 11d0 \u003c__libc_csu_fini\u003e 105a:\t48 8d 0d ff 00 00 00 lea 0xff(%rip),%rcx # 1160 \u003c__libc_csu_init\u003e 1061:\t48 8d 3d d1 00 00 00 lea 0xd1(%rip),%rdi # 1139 1068:\tff 15 72 2f 00 00 callq *0x2f72(%rip) # 3fe0 \u003c__libc_start_main@GLIBC_2.2.5\u003e 106e:\tf4 hlt 106f:\t90 nop It does not call the main() directly.. But it takes main() as an argument and then calls __libc_start_main (from GlibC). Along with main(), it also takes __libc_csu_fini and __libc_csu_init as an argument.\nThe whole picture This image is taken from here… This is a complete in-depth blog explaining How the heck do we get to main()?\nNow from the picture, it is very much clear that _start passes main (and other 2 functions) to __libc_start_main(function name was not sure from the disassembly). And __libc_start_main starts the main().\nBut what the hell is everything else??\nTo start with, Loader is a program that loads executable from disk to RAM (primary memory) for execution. In unix, it is the handler for execve() system call. As per the wikipedia page for loader(computing), It’s tasks include:\nvalidation (permissions, memory requirements etc.); copying the program image from the disk into main memory; copying the command-line arguments on the stack; initializing registers (e.g., the stack pointer); jumping to the program entry point (_start). But before getting to _start, it pre-initializes some global variables to help _start. You can create your custom preinit function as well. For this, you’ll need the constructor function. And yes, it is not C++ and it has a constructor and destructor. Every executable has a global C level constructor and destructor.\nThis is a code (unknown_functions.c) to change the preinit function with my own. I have added 3 printf() statements to preinit() (which should be easy to figure out in assembly now).. I’ll compile this code using gcc unknown_functions.c -o unknown_functions.out.\n#include void preinit(int argc, char **argv, char **envp) { printf(\"%s\\n\", __FUNCTION__); printf(\"%d , %s , %s\\n\", argc, *argv, *envp); printf(\"CLI arg : %s\\n\", argv[1]); } __attribute__((section(\".preinit_array\"))) typeof(preinit) *__preinit = preinit; int main(int argc, char **argv, char **envp) { printf(\"This is %s\\n\",__FUNCTION__); printf(\"%d , %s , %s\\n\", argc, *argv, *envp); printf(\"CLI arg : %s\\n\", argv[1]); return 0; } On running it with ./unknown_functions.out, I get some expected output.\npreinit 1 , ./unknown_functions.out , ALACRITTY_LOG=/tmp/Alacritty-161582.log CLI arg : (null) This is main 1 , ./unknown_functions.out , ALACRITTY_LOG=/tmp/Alacritty-161582.log CLI arg : (null) And we can also pass CLI argument to the binary like ./unknown_functions.out abcd1 and then it’ll give an output like this-\npreinit 2 , ./unknown_functions.out , ALACRITTY_LOG=/tmp/Alacritty-161582.log CLI arg : abcd1 This is main 2 , ./unknown_functions.out , ALACRITTY_LOG=/tmp/Alacritty-161582.log CLI arg : abcd1 With this, we know that preinit function runs before main(). Let’s move forward with _start. This function is responsible to load main() by default. What if we change this function with our custom function and never call main().\nI am using below code(nomain.c) and compiling it with a (special flag this time) – gcc nomain.c -nostartfiles -o nomain.out\n#include #include // For declaration of exit() void _start() { int x = my_fun(); //calling custom main function exit(x); } int my_fun() // our custom main function { printf(\"Surprise!!\\n\"); return 0; } int main() { printf(\"Not the main anymore\"); return 0; } On running the binary ./nomain.out we get,\nSurprise!! To understand what just happened, we need to look into the disassembly of this binary. – objdump -d nomain.out\nnomain.out: file format elf64-x86-64 Disassembly of section .plt: 0000000000001000 \u003c.plt\u003e: 1000:\tff 35 02 30 00 00 pushq 0x3002(%rip) # 4008 \u003c_GLOBAL_OFFSET_TABLE_+0x8\u003e 1006:\tff 25 04 30 00 00 jmpq *0x3004(%rip) # 4010 \u003c_GLOBAL_OFFSET_TABLE_+0x10\u003e 100c:\t0f 1f 40 00 nopl 0x0(%rax) 0000000000001010 : 1010:\tff 25 02 30 00 00 jmpq *0x3002(%rip) # 4018 1016:\t68 00 00 00 00 pushq $0x0 101b:\te9 e0 ff ff ff jmpq 1000 \u003c.plt\u003e 0000000000001020 : 1020:\tff 25 fa 2f 00 00 jmpq *0x2ffa(%rip) # 4020 1026:\t68 01 00 00 00 pushq $0x1 102b:\te9 d0 ff ff ff jmpq 1000 \u003c.plt\u003e 0000000000001030 : 1030:\tff 25 f2 2f 00 00 jmpq *0x2ff2(%rip) # 4028 1036:\t68 02 00 00 00 pushq $0x2 103b:\te9 c0 ff ff ff jmpq 1000 \u003c.plt\u003e Disassembly of section .text: 0000000000001040 \u003c_start\u003e: 1040:\t55 push %rbp 1041:\t48 89 e5 mov %rsp,%rbp 1044:\t48 83 ec 10 sub $0x10,%rsp 1048:\tb8 00 00 00 00 mov $0x0,%eax 104d:\te8 0d 00 00 00 callq 105f 1052:\t89 45 fc mov %eax,-0x4(%rbp) 1055:\t8b 45 fc mov -0x4(%rbp),%eax 1058:\t89 c7 mov %eax,%edi 105a:\te8 d1 ff ff ff callq 1030 000000000000105f : 105f:\t55 push %rbp 1060:\t48 89 e5 mov %rsp,%rbp 1063:\t48 8d 3d 96 0f 00 00 lea 0xf96(%rip),%rdi # 2000 106a:\te8 a1 ff ff ff callq 1010 106f:\tb8 00 00 00 00 mov $0x0,%eax 1074:\t5d pop %rbp 1075:\tc3 retq 0000000000001076 : 1076:\t55 push %rbp 1077:\t48 89 e5 mov %rsp,%rbp 107a:\t48 8d 3d 8a 0f 00 00 lea 0xf8a(%rip),%rdi # 200b 1081:\tb8 00 00 00 00 mov $0x0,%eax 1086:\te8 95 ff ff ff callq 1020 108b:\tb8 00 00 00 00 mov $0x0,%eax 1090:\t5d pop %rbp 1091:\tc3 retq This is pretty small as compared to the disassembly of simple.out. The reason here is clear that we have changed the _start and not implemented any of the fancy functions in it. And this reduces the size of my binary as well.\n$ du nomain.out simple.out 16\tnomain.out 20\tsimple.out What after _start ?? Till now, we have seen that we can pass our values to loader and replace _start with our custom functions… but this will not start __libc_start_main function.\nWhy do we need __libc_start_main to run??\n__libc_start_main is linked into our code from glibc. In general, it takes care of -\ntakes care of setuid and setguid program security problems. registers init and fini arguments. Calls the main function and exit with the return value of main. (This is something that we did in our custom function - nomain.c) This here is the definition for the __libc_start_main function which is implemented in the libc library.\nAs seen in the disassembly (of simple.out binary)… we can see that while calling (callq) the __libc_start_main function… we are passing main, __libc_csu_init and __libc_csu_fini… along with other things.\n0000000000001040 \u003c_start\u003e: 1040:\tf3 0f 1e fa endbr64 1044:\t31 ed xor %ebp,%ebp 1046:\t49 89 d1 mov %rdx,%r9 1049:\t5e pop %rsi 104a:\t48 89 e2 mov %rsp,%rdx 104d:\t48 83 e4 f0 and $0xfffffffffffffff0,%rsp 1051:\t50 push %rax 1052:\t54 push %rsp 1053:\t4c 8d 05 76 01 00 00 lea 0x176(%rip),%r8 # 11d0 \u003c__libc_csu_fini\u003e 105a:\t48 8d 0d ff 00 00 00 lea 0xff(%rip),%rcx # 1160 \u003c__libc_csu_init\u003e 1061:\t48 8d 3d d1 00 00 00 lea 0xd1(%rip),%rdi # 1139 1068:\tff 15 72 2f 00 00 callq *0x2f72(%rip) # 3fe0 \u003c__libc_start_main@GLIBC_2.2.5\u003e 106e:\tf4 hlt 106f:\t90 nop What’s next??\nNext thing that executes is __libc_csu_init which will call all the initializing functions. This phase runs before the main() function. The sequence which is followed(roughly) by the __libc_csu_init function is:\n__init __gmon_start__ frame_dummy __do_global_ctors_aux C level global constructors init array We’ll add our custom c level global constructor and init array function in below code(pre-main.c)…. and complie it with gcc pre-main.c -o pre-main.out.\n#include void init(int argc, char **argv, char **envp) { printf(\"%s\\n\", __FUNCTION__); } void __attribute__ ((constructor)) constructor() { printf(\"%s\\n\", __FUNCTION__); } __attribute__((section(\".init_array\"))) typeof(init) *__init = init; int main() { printf(\"Hello main\"); return 0; } This will give output as below\nconstructor init Hello main After main ?? As we have in the diagram, after main, exit function is called… which calls multiple functions in the below order:-\nat_exit fini_array constructor. The below code(after-main.c) can be used to demonstrate that.\n#include void fini() { printf(\"%s\\n\", __FUNCTION__); } void __attribute__ ((destructor)) destructor() { printf(\"%s\\n\", __FUNCTION__); } __attribute__((section(\".fini_array\"))) typeof(fini) *__fini = fini; void do_something_at_end() { printf(\"Bye bye\\n\"); } int main() { atexit(do_something_at_end); printf(\"Hello main\\n\"); return 0; } This will return the below output - which confirms the order of execution.\nHello main Bye bye fini destructor Here we can see that the atexit function is called before the printf function but in output the atexit output is after the printf is called. The reason here is that here atexit() is simply registering do_something_at_end function to run at exit. It’s not responsible to run it right away.\nThe end. This is pretty much what happens when we run an ELF binary or a C program in linux. In this article, I haven’t talked about a lot of other stuff that happens when a program executes… like setting up the environments variable for the program, how the memory layout is done or what is procedure linkage table(plt), etc…\nIf you find any information wrongly presented in this article, feel free to correct me. I am still learning this whole stuff and there are a lot of things yet to discover.\n",
  "wordCount" : "2038",
  "inLanguage": "en",
  "datePublished": "2021-01-27T14:58:51+05:30",
  "dateModified": "2021-01-27T14:58:51+05:30",
  "author":[{
    "@type": "Person",
    "name": "ayedaemon"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ayedaemon.github.io/post/2022/01/debugging-c-code/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Connected",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ayedaemon.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ayedaemon.github.io/" accesskey="h" title="Connected (Alt + H)">Connected</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ayedaemon.github.io/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://ayedaemon.github.io/series/" title="Series">
                    <span>Series</span>
                </a>
            </li>
            <li>
                <a href="https://ayedaemon.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://ayedaemon.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Debugging C Code
    </h1>
    <div class="post-meta"><span title='2021-01-27 14:58:51 +0530 +0530'>January 27, 2021</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;2038 words&nbsp;·&nbsp;ayedaemon&nbsp;|&nbsp;<a href="https://github.com/ayedaemon/ayedaemon.github.io/content/post/2022/01/Debugging-C-code.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#basic-c-program" aria-label="Basic C program">Basic C program</a></li>
                <li>
                    <a href="#lets-decompile-our-simple-binary" aria-label="Let&rsquo;s decompile our simple binary.">Let&rsquo;s decompile our simple binary.</a></li>
                <li>
                    <a href="#the-whole-picture" aria-label="The whole picture">The whole picture</a></li>
                <li>
                    <a href="#what-after-_start-" aria-label="What after _start ??">What after _start ??</a></li>
                <li>
                    <a href="#after-main-" aria-label="After main ??">After main ??</a></li>
                <li>
                    <a href="#the-end" aria-label="The end.">The end.</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p>How your x86 program starts up in linux</p>
</blockquote>
<p>In this blog, I will assume that you have basic understanding of assembly language. If not, then you should consider learning it. Although I&rsquo;ll try to explain things in the easiest terms as possible.</p>
<h3 id="basic-c-program">Basic C program<a hidden class="anchor" aria-hidden="true" href="#basic-c-program">#</a></h3>
<p>Let&rsquo;s start with a basic C program&hellip;</p>
<p><strong>CODE:</strong> (Saving it with <code>simple.c</code>)</p>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;

int main()
{
    printf(&#34;Hello main&#34;);
    return 0;
}
</code></pre><p>&hellip; and compile it the way we have always done it with <code>gcc</code>.</p>
<pre tabindex="0"><code>gcc simple.c -o simple.out
</code></pre><p>Now I have got a file <code>simple.out</code> which should be my executable binary.. I have a habit to check the file using <code>file</code> command to be more sure.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ file simple.out
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">simple.out: ELF 64-bit LSB pie executable, x86-64, version <span class="m">1</span> <span class="o">(</span>SYSV<span class="o">)</span>, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID<span class="o">[</span>sha1<span class="o">]=</span>11c9b757baf9a3a8271443682135b7488cb04e52, <span class="k">for</span> GNU/Linux 3.2.0, not stripped
</span></span></code></pre></div><p>And now we know that it is an ELF binary and dynamically linked.</p>
<p>Let&rsquo;s see what shared objects they use.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ ldd simple.out
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">linux-vdso.so.1 <span class="o">(</span>0x00007fffbc364000<span class="o">)</span>
</span></span><span class="line"><span class="cl">libc.so.6 <span class="o">=</span>&gt; /usr/lib/libc.so.6 <span class="o">(</span>0x00007f5b0d6a7000<span class="o">)</span>
</span></span><span class="line"><span class="cl">/lib64/ld-linux-x86-64.so.2 <span class="o">=</span>&gt; /usr/lib64/ld-linux-x86-64.so.2 <span class="o">(</span>0x00007f5b0d8b9000<span class="o">)</span>
</span></span></code></pre></div><p>The interesting one here is <code>libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f5b0d6a7000)</code>. This shared object is used in almost every linux command you know. On checking the <code>man</code> page for libc.. I came to know that it is the standard C library used in linux.</p>
<p>The question I am asking myself here is &ndash;&gt; <strong>Is this somehow responsible to execute the <code>main()</code> function in C programs.</strong></p>
<p>Maybe. We&rsquo;ll see that later.</p>
<h3 id="lets-decompile-our-simple-binary">Let&rsquo;s decompile our simple binary.<a hidden class="anchor" aria-hidden="true" href="#lets-decompile-our-simple-binary">#</a></h3>
<p>I can check the assembly code of the executable using <code>objdump -d simple.out</code> command on my terminal. It&rsquo;ll give me a lot of output but right now I am concerned about the <code>main()</code> function&hellip; so I&rsquo;ll just <code>grep</code> it.</p>
<pre tabindex="0"><code>$ objdump -d simple.out | grep -A12 &#39;&lt;main&gt;:&#39;


0000000000001139 &lt;main&gt;:
    1139:	55                   	push   %rbp
    113a:	48 89 e5             	mov    %rsp,%rbp
    113d:	48 8d 3d c0 0e 00 00 	lea    0xec0(%rip),%rdi        # 2004 &lt;_IO_stdin_used+0x4&gt;
    1144:	b8 00 00 00 00       	mov    $0x0,%eax
    1149:	e8 e2 fe ff ff       	callq  1030 &lt;printf@plt&gt;
    114e:	b8 00 00 00 00       	mov    $0x0,%eax
    1153:	5d                   	pop    %rbp
    1154:	c3                   	retq
    1155:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    115c:	00 00 00
    115f:	90                   	nop
</code></pre><p><em>If you don&rsquo;t understand assembly, I get what you are feeling right now</em></p>
<p>But you don&rsquo;t need to understand it completely right now. You can look into some syntax and they&rsquo;ll make sense in some time.
Like <code>callq  1030 &lt;printf@plt&gt;</code> - this looks like out <code>printf()</code> function. And we know before calling a function, you need to pass its arguments on the stack. That means the <code>mov</code> just above the <code>callq</code> statement is my string <code>Hello main</code> (which is the argument passed to <code>printf()</code>)</p>
<p>Another Question &ndash;&gt; <strong>Is <code>main()</code> really the starting point of execution??</strong></p>
<p>On further looking into the <code>objdump -d simple.out</code> command output&hellip; I can understand that there is another function<code>_start</code> that calls the <code>main()</code> function.</p>
<pre tabindex="0"><code>Disassembly of section .text:

0000000000001040 &lt;_start&gt;:
    1040:	f3 0f 1e fa          	endbr64
    1044:	31 ed                	xor    %ebp,%ebp
    1046:	49 89 d1             	mov    %rdx,%r9
    1049:	5e                   	pop    %rsi
    104a:	48 89 e2             	mov    %rsp,%rdx
    104d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    1051:	50                   	push   %rax
    1052:	54                   	push   %rsp
    1053:	4c 8d 05 76 01 00 00 	lea    0x176(%rip),%r8        # 11d0 &lt;__libc_csu_fini&gt;
    105a:	48 8d 0d ff 00 00 00 	lea    0xff(%rip),%rcx        # 1160 &lt;__libc_csu_init&gt;
    1061:	48 8d 3d d1 00 00 00 	lea    0xd1(%rip),%rdi        # 1139 &lt;main&gt;
    1068:	ff 15 72 2f 00 00    	callq  *0x2f72(%rip)        # 3fe0 &lt;__libc_start_main@GLIBC_2.2.5&gt;
    106e:	f4                   	hlt
    106f:	90                   	nop
</code></pre><p>It does not call the <code>main()</code> directly.. But it takes <code>main()</code> as an argument and then calls __libc_start_main (from GlibC). Along with <code>main()</code>, it also takes <code>__libc_csu_fini</code> and <code>__libc_csu_init</code> as an argument.</p>
<h3 id="the-whole-picture">The whole picture<a hidden class="anchor" aria-hidden="true" href="#the-whole-picture">#</a></h3>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/640/0*HlrnUq2SuCxLLzuH.png" alt="the-whole-picture"  />
</p>
<p><em>This image is taken from <a href="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html">here</a>&hellip; This is a complete in-depth blog explaining <code>How the heck do we get to main()?</code></em></p>
<p>Now from the picture, it is very much clear that <code>_start</code> passes <code>main</code> (and other 2 functions) to <code>__libc_start_main</code>(function name was not sure from the disassembly). And <code>__libc_start_main</code> starts the <code>main()</code>.</p>
<p><strong>But what the hell is everything else??</strong></p>
<p>To start with, <strong>Loader</strong> is a program that loads executable from disk to RAM (primary memory) for execution. In unix, it is the handler for <code>execve()</code> system call. As per the <a href="https://en.wikipedia.org/wiki/Loader_%28computing%29#Responsibilities">wikipedia page for loader(computing)</a>, It&rsquo;s tasks include:</p>
<ol>
<li>validation (permissions, memory requirements etc.);</li>
<li>copying the program image from the disk into main memory;</li>
<li>copying the command-line arguments on the stack;</li>
<li>initializing registers (e.g., the stack pointer);</li>
<li>jumping to the program entry point (<code>_start</code>).</li>
</ol>
<p>But before getting to <code>_start</code>, it pre-initializes some global variables to help <code>_start</code>. You can create your custom <code>preinit</code> function as well. For this, you&rsquo;ll need the constructor function. And yes, it is not C++ and it has a constructor and destructor. Every executable has a global C level constructor and destructor.</p>
<p>This is a code (<code>unknown_functions.c</code>) to change the <code>preinit</code> function with my own. I have added 3 <code>printf()</code> statements to <code>preinit()</code> (which should be easy to figure out in assembly now).. I&rsquo;ll compile this code using <code>gcc unknown_functions.c -o unknown_functions.out</code>.</p>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;

void preinit(int argc, char **argv, char **envp) {
 printf(&#34;%s\n&#34;, __FUNCTION__);
 printf(&#34;%d , %s , %s\n&#34;, argc, *argv, *envp);
 printf(&#34;CLI arg : %s\n&#34;, argv[1]);
}

__attribute__((section(&#34;.preinit_array&#34;))) typeof(preinit) *__preinit = preinit;

int main(int argc, char **argv, char **envp) {
    printf(&#34;This is %s\n&#34;,__FUNCTION__);
    printf(&#34;%d , %s , %s\n&#34;, argc, *argv, *envp);
    printf(&#34;CLI arg : %s\n&#34;, argv[1]);
    return 0;
}
</code></pre><p>On running it with <code>./unknown_functions.out</code>, I get some expected output.</p>
<pre tabindex="0"><code>preinit
1 , ./unknown_functions.out , ALACRITTY_LOG=/tmp/Alacritty-161582.log
CLI arg : (null)
This is main
1 , ./unknown_functions.out , ALACRITTY_LOG=/tmp/Alacritty-161582.log
CLI arg : (null)
</code></pre><p>And we can also pass CLI argument to the binary like <code>./unknown_functions.out abcd1</code> and then it&rsquo;ll give an output like this-</p>
<pre tabindex="0"><code>preinit
2 , ./unknown_functions.out , ALACRITTY_LOG=/tmp/Alacritty-161582.log
CLI arg : abcd1
This is main
2 , ./unknown_functions.out , ALACRITTY_LOG=/tmp/Alacritty-161582.log
CLI arg : abcd1
</code></pre><p>With this, we know that <code>preinit</code> function runs before <code>main()</code>. Let&rsquo;s move forward with <code>_start</code>. This function is responsible to load <code>main()</code> by default. What if we change this function with our custom function and never call <code>main()</code>.</p>
<p>I am using below code(<code>nomain.c</code>) and compiling it with a (special flag this time) &ndash; <code>gcc nomain.c -nostartfiles -o nomain.out</code></p>
<pre tabindex="0"><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt; // For declaration of exit()
void _start()
{
    int x = my_fun(); //calling custom main function
    exit(x);
}

int my_fun() // our custom main function
{
    printf(&#34;Surprise!!\n&#34;);
    return 0;
}

int main()
{
  printf(&#34;Not the main anymore&#34;);
  return 0;
}
</code></pre><p>On running the binary <code>./nomain.out</code> we get,</p>
<pre tabindex="0"><code>Surprise!!
</code></pre><p>To understand what just happened, we need to look into the disassembly of this binary. &ndash; <code>objdump -d nomain.out</code></p>
<pre tabindex="0"><code>nomain.out:     file format elf64-x86-64


Disassembly of section .plt:

0000000000001000 &lt;.plt&gt;:
    1000:	ff 35 02 30 00 00    	pushq  0x3002(%rip)        # 4008 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;
    1006:	ff 25 04 30 00 00    	jmpq   *0x3004(%rip)        # 4010 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;
    100c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000001010 &lt;puts@plt&gt;:
    1010:	ff 25 02 30 00 00    	jmpq   *0x3002(%rip)        # 4018 &lt;puts@GLIBC_2.2.5&gt;
    1016:	68 00 00 00 00       	pushq  $0x0
    101b:	e9 e0 ff ff ff       	jmpq   1000 &lt;.plt&gt;

0000000000001020 &lt;printf@plt&gt;:
    1020:	ff 25 fa 2f 00 00    	jmpq   *0x2ffa(%rip)        # 4020 &lt;printf@GLIBC_2.2.5&gt;
    1026:	68 01 00 00 00       	pushq  $0x1
    102b:	e9 d0 ff ff ff       	jmpq   1000 &lt;.plt&gt;

0000000000001030 &lt;exit@plt&gt;:
    1030:	ff 25 f2 2f 00 00    	jmpq   *0x2ff2(%rip)        # 4028 &lt;exit@GLIBC_2.2.5&gt;
    1036:	68 02 00 00 00       	pushq  $0x2
    103b:	e9 c0 ff ff ff       	jmpq   1000 &lt;.plt&gt;

Disassembly of section .text:

0000000000001040 &lt;_start&gt;:
    1040:	55                   	push   %rbp
    1041:	48 89 e5             	mov    %rsp,%rbp
    1044:	48 83 ec 10          	sub    $0x10,%rsp
    1048:	b8 00 00 00 00       	mov    $0x0,%eax
    104d:	e8 0d 00 00 00       	callq  105f &lt;my_fun&gt;
    1052:	89 45 fc             	mov    %eax,-0x4(%rbp)
    1055:	8b 45 fc             	mov    -0x4(%rbp),%eax
    1058:	89 c7                	mov    %eax,%edi
    105a:	e8 d1 ff ff ff       	callq  1030 &lt;exit@plt&gt;

000000000000105f &lt;my_fun&gt;:
    105f:	55                   	push   %rbp
    1060:	48 89 e5             	mov    %rsp,%rbp
    1063:	48 8d 3d 96 0f 00 00 	lea    0xf96(%rip),%rdi        # 2000 &lt;main+0xf8a&gt;
    106a:	e8 a1 ff ff ff       	callq  1010 &lt;puts@plt&gt;
    106f:	b8 00 00 00 00       	mov    $0x0,%eax
    1074:	5d                   	pop    %rbp
    1075:	c3                   	retq

0000000000001076 &lt;main&gt;:
    1076:	55                   	push   %rbp
    1077:	48 89 e5             	mov    %rsp,%rbp
    107a:	48 8d 3d 8a 0f 00 00 	lea    0xf8a(%rip),%rdi        # 200b &lt;main+0xf95&gt;
    1081:	b8 00 00 00 00       	mov    $0x0,%eax
    1086:	e8 95 ff ff ff       	callq  1020 &lt;printf@plt&gt;
    108b:	b8 00 00 00 00       	mov    $0x0,%eax
    1090:	5d                   	pop    %rbp
    1091:	c3                   	retq
</code></pre><p>This is pretty small as compared to the disassembly of <code>simple.out</code>. The reason here is clear that we have changed the <code>_start</code> and not implemented any of the fancy functions in it. And this reduces the size of my binary as well.</p>
<pre tabindex="0"><code>$ du nomain.out simple.out


16	nomain.out
20	simple.out
</code></pre><hr>
<h3 id="what-after-_start-">What after _start ??<a hidden class="anchor" aria-hidden="true" href="#what-after-_start-">#</a></h3>
<p>Till now, we have seen that we can pass our values to loader and replace <code>_start</code> with our custom functions&hellip; but this will not start <code>__libc_start_main</code> function.</p>
<p><strong>Why do we need <code>__libc_start_main</code> to run??</strong></p>
<p><code>__libc_start_main</code> is linked into our code from glibc. In general, it takes care of -</p>
<ol>
<li>takes care of setuid and setguid program security problems.</li>
<li>registers <code>init</code> and <code>fini</code> arguments.</li>
<li>Calls the <code>main</code> function and exit with the return value of <code>main</code>. (<em>This is something that we did in our custom function - <code>nomain.c</code></em>)</li>
</ol>
<p><a href="https://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/baselib---libc-start-main-.html">This here</a> is the definition for the <code>__libc_start_main</code> function which is implemented in the <code>libc</code> library.</p>
<p>As seen in the disassembly (of <code>simple.out</code> binary)&hellip; we can see that while calling (<code>callq</code>) the <code>__libc_start_main</code> function&hellip; we are passing <code>main</code>, <code>__libc_csu_init</code> and <code>__libc_csu_fini</code>&hellip; along with other things.</p>
<pre tabindex="0"><code>0000000000001040 &lt;_start&gt;:
    1040:	f3 0f 1e fa          	endbr64
    1044:	31 ed                	xor    %ebp,%ebp
    1046:	49 89 d1             	mov    %rdx,%r9
    1049:	5e                   	pop    %rsi
    104a:	48 89 e2             	mov    %rsp,%rdx
    104d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    1051:	50                   	push   %rax
    1052:	54                   	push   %rsp
    1053:	4c 8d 05 76 01 00 00 	lea    0x176(%rip),%r8        # 11d0 &lt;__libc_csu_fini&gt;
    105a:	48 8d 0d ff 00 00 00 	lea    0xff(%rip),%rcx        # 1160 &lt;__libc_csu_init&gt;
    1061:	48 8d 3d d1 00 00 00 	lea    0xd1(%rip),%rdi        # 1139 &lt;main&gt;
    1068:	ff 15 72 2f 00 00    	callq  *0x2f72(%rip)        # 3fe0 &lt;__libc_start_main@GLIBC_2.2.5&gt;
    106e:	f4                   	hlt
    106f:	90                   	nop
</code></pre><p><strong>What&rsquo;s next??</strong></p>
<p>Next thing that executes is <code>__libc_csu_init</code> which will call all the initializing functions. This phase <em>runs before the <code>main()</code> function</em>. The sequence which is followed(roughly) by the <code>__libc_csu_init</code> function is:</p>
<ul>
<li><code>__init</code></li>
<li><code>__gmon_start__</code></li>
<li><code>frame_dummy</code></li>
<li><code>__do_global_ctors_aux</code></li>
<li><code>C level global constructors</code></li>
<li><code>init array</code></li>
</ul>
<p>We&rsquo;ll add our custom <code>c level global constructor</code> and <code>init array</code> function in below code(<code>pre-main.c</code>)&hellip;. and complie it with <code>gcc pre-main.c -o pre-main.out</code>.</p>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;

void init(int argc, char **argv, char **envp) {
 printf(&#34;%s\n&#34;, __FUNCTION__);
}


void  __attribute__ ((constructor)) constructor() {
 printf(&#34;%s\n&#34;, __FUNCTION__);
}

__attribute__((section(&#34;.init_array&#34;))) typeof(init) *__init = init;

int main()
{
    printf(&#34;Hello main&#34;);
    return 0;
}
</code></pre><p>This will give output as below</p>
<pre tabindex="0"><code>constructor
init
Hello main
</code></pre><h3 id="after-main-">After main ??<a hidden class="anchor" aria-hidden="true" href="#after-main-">#</a></h3>
<p>As we have in the diagram, after <code>main</code>, <code>exit</code> function is called&hellip; which calls multiple functions in the below order:-</p>
<ol>
<li>at_exit</li>
<li>fini_array</li>
<li>constructor.</li>
</ol>
<p>The below code(<code>after-main.c</code>) can be used to demonstrate that.</p>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;


void fini() {
 printf(&#34;%s\n&#34;, __FUNCTION__);

}

void __attribute__ ((destructor)) destructor() {
 printf(&#34;%s\n&#34;, __FUNCTION__);
}
__attribute__((section(&#34;.fini_array&#34;))) typeof(fini) *__fini = fini;

void do_something_at_end()
{
    printf(&#34;Bye bye\n&#34;);
}

int main()
{
    atexit(do_something_at_end);
    printf(&#34;Hello main\n&#34;);
    return 0;
}
</code></pre><p>This will return the below output - which confirms the order of execution.</p>
<pre tabindex="0"><code>Hello main
Bye bye
fini
destructor
</code></pre><p>Here we can see that the <code>atexit</code> function is called before the <code>printf</code> function but in output the <code>atexit</code> output is after the <code>printf</code> is called. The reason here is that here <code>atexit()</code> is simply registering <code>do_something_at_end</code> function to run at exit. It&rsquo;s not responsible to run it right away.</p>
<hr>
<h3 id="the-end">The end.<a hidden class="anchor" aria-hidden="true" href="#the-end">#</a></h3>
<p>This is pretty much what happens when we run an ELF binary or a C program in linux. In this article, I haven&rsquo;t talked about a lot of other stuff that happens when a program executes&hellip; like setting up the environments variable for the program, how the memory layout is done or what is procedure linkage table(plt), etc&hellip;</p>
<p>If you find any information wrongly presented in this article, feel free to correct me. I am still learning this whole stuff and there are a lot of things yet to discover.</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ayedaemon.github.io/tags/c-programming/">C programming</a></li>
      <li><a href="https://ayedaemon.github.io/tags/debugging/">Debugging</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://ayedaemon.github.io/">Connected</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
