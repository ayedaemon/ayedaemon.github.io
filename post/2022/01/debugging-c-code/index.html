<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Debugging C Code | Connected</title>
<meta name=keywords content="C programming,Debugging"><meta name=description content="
How your x86 program starts up in linux
"><meta name=author content="ayedaemon"><link rel=canonical href=https://ayedaemon.github.io/post/2022/01/debugging-c-code/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://ayedaemon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ayedaemon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ayedaemon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ayedaemon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ayedaemon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Debugging C Code"><meta property="og:description" content="
How your x86 program starts up in linux
"><meta property="og:type" content="article"><meta property="og:url" content="https://ayedaemon.github.io/post/2022/01/debugging-c-code/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-01-27T14:58:51+05:30"><meta property="article:modified_time" content="2024-04-02T17:19:43+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Debugging C Code"><meta name=twitter:description content="
How your x86 program starts up in linux
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ayedaemon.github.io/post/"},{"@type":"ListItem","position":2,"name":"Debugging C Code","item":"https://ayedaemon.github.io/post/2022/01/debugging-c-code/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Debugging C Code","name":"Debugging C Code","description":" How your x86 program starts up in linux\n","keywords":["C programming","Debugging"],"articleBody":" How your x86 program starts up in linux\nIn this blog, I will assume that you have basic understanding of assembly language. If not, then you should consider learning it. Although I’ll try to explain things in the easiest terms as possible.\nBasic C program Let’s start with a basic C program…\nCODE: (Saving it with simple.c)\n#include int main() { printf(\"Hello main\"); return 0; } … and compile it the way we have always done it with gcc.\ngcc simple.c -o simple.out Now I have got a file simple.out which should be my executable binary.. I have a habit to check the file using file command to be more sure.\n$ file simple.out simple.out: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=11c9b757baf9a3a8271443682135b7488cb04e52, for GNU/Linux 3.2.0, not stripped And now we know that it is an ELF binary and dynamically linked.\nLet’s see what shared objects they use.\n$ ldd simple.out linux-vdso.so.1 (0x00007fffbc364000) libc.so.6 =\u003e /usr/lib/libc.so.6 (0x00007f5b0d6a7000) /lib64/ld-linux-x86-64.so.2 =\u003e /usr/lib64/ld-linux-x86-64.so.2 (0x00007f5b0d8b9000) The interesting one here is libc.so.6 =\u003e /usr/lib/libc.so.6 (0x00007f5b0d6a7000). This shared object is used in almost every linux command you know. On checking the man page for libc.. I came to know that it is the standard C library used in linux.\nThe question I am asking myself here is –\u003e Is this somehow responsible to execute the main() function in C programs.\nMaybe. We’ll see that later.\nLet’s decompile our simple binary. I can check the assembly code of the executable using objdump -d simple.out command on my terminal. It’ll give me a lot of output but right now I am concerned about the main() function… so I’ll just grep it.\n$ objdump -d simple.out | grep -A12 ':' 0000000000001139 : 1139:\t55 push %rbp 113a:\t48 89 e5 mov %rsp,%rbp 113d:\t48 8d 3d c0 0e 00 00 lea 0xec0(%rip),%rdi # 2004 \u003c_IO_stdin_used+0x4\u003e 1144:\tb8 00 00 00 00 mov $0x0,%eax 1149:\te8 e2 fe ff ff callq 1030 114e:\tb8 00 00 00 00 mov $0x0,%eax 1153:\t5d pop %rbp 1154:\tc3 retq 1155:\t66 2e 0f 1f 84 00 00 nopw %cs:0x0(%rax,%rax,1) 115c:\t00 00 00 115f:\t90 nop If you don’t understand assembly, I get what you are feeling right now\nBut you don’t need to understand it completely right now. You can look into some syntax and they’ll make sense in some time. Like callq 1030 - this looks like out printf() function. And we know before calling a function, you need to pass its arguments on the stack. That means the mov just above the callq statement is my string Hello main (which is the argument passed to printf())\nAnother Question –\u003e Is main() really the starting point of execution??\nOn further looking into the objdump -d simple.out command output… I can understand that there is another function_start that calls the main() function.\nDisassembly of section .text: 0000000000001040 \u003c_start\u003e: 1040:\tf3 0f 1e fa endbr64 1044:\t31 ed xor %ebp,%ebp 1046:\t49 89 d1 mov %rdx,%r9 1049:\t5e pop %rsi 104a:\t48 89 e2 mov %rsp,%rdx 104d:\t48 83 e4 f0 and $0xfffffffffffffff0,%rsp 1051:\t50 push %rax 1052:\t54 push %rsp 1053:\t4c 8d 05 76 01 00 00 lea 0x176(%rip),%r8 # 11d0 \u003c__libc_csu_fini\u003e 105a:\t48 8d 0d ff 00 00 00 lea 0xff(%rip),%rcx # 1160 \u003c__libc_csu_init\u003e 1061:\t48 8d 3d d1 00 00 00 lea 0xd1(%rip),%rdi # 1139 1068:\tff 15 72 2f 00 00 callq *0x2f72(%rip) # 3fe0 \u003c__libc_start_main@GLIBC_2.2.5\u003e 106e:\tf4 hlt 106f:\t90 nop It does not call the main() directly.. But it takes main() as an argument and then calls __libc_start_main (from GlibC). Along with main(), it also takes __libc_csu_fini and __libc_csu_init as an argument.\nThe whole picture This image is taken from here… This is a complete in-depth blog explaining How the heck do we get to main()?\nNow from the picture, it is very much clear that _start passes main (and other 2 functions) to __libc_start_main(function name was not sure from the disassembly). And __libc_start_main starts the main().\nBut what the hell is everything else??\nTo start with, Loader is a program that loads executable from disk to RAM (primary memory) for execution. In unix, it is the handler for execve() system call. As per the wikipedia page for loader(computing), It’s tasks include:\nvalidation (permissions, memory requirements etc.); copying the program image from the disk into main memory; copying the command-line arguments on the stack; initializing registers (e.g., the stack pointer); jumping to the program entry point (_start). But before getting to _start, it pre-initializes some global variables to help _start. You can create your custom preinit function as well. For this, you’ll need the constructor function. And yes, it is not C++ and it has a constructor and destructor. Every executable has a global C level constructor and destructor.\nThis is a code (unknown_functions.c) to change the preinit function with my own. I have added 3 printf() statements to preinit() (which should be easy to figure out in assembly now).. I’ll compile this code using gcc unknown_functions.c -o unknown_functions.out.\n#include void preinit(int argc, char **argv, char **envp) { printf(\"%s\\n\", __FUNCTION__); printf(\"%d , %s , %s\\n\", argc, *argv, *envp); printf(\"CLI arg : %s\\n\", argv[1]); } __attribute__((section(\".preinit_array\"))) typeof(preinit) *__preinit = preinit; int main(int argc, char **argv, char **envp) { printf(\"This is %s\\n\",__FUNCTION__); printf(\"%d , %s , %s\\n\", argc, *argv, *envp); printf(\"CLI arg : %s\\n\", argv[1]); return 0; } On running it with ./unknown_functions.out, I get some expected output.\npreinit 1 , ./unknown_functions.out , ALACRITTY_LOG=/tmp/Alacritty-161582.log CLI arg : (null) This is main 1 , ./unknown_functions.out , ALACRITTY_LOG=/tmp/Alacritty-161582.log CLI arg : (null) And we can also pass CLI argument to the binary like ./unknown_functions.out abcd1 and then it’ll give an output like this-\npreinit 2 , ./unknown_functions.out , ALACRITTY_LOG=/tmp/Alacritty-161582.log CLI arg : abcd1 This is main 2 , ./unknown_functions.out , ALACRITTY_LOG=/tmp/Alacritty-161582.log CLI arg : abcd1 With this, we know that preinit function runs before main(). Let’s move forward with _start. This function is responsible to load main() by default. What if we change this function with our custom function and never call main().\nI am using below code(nomain.c) and compiling it with a (special flag this time) – gcc nomain.c -nostartfiles -o nomain.out\n#include #include // For declaration of exit() void _start() { int x = my_fun(); //calling custom main function exit(x); } int my_fun() // our custom main function { printf(\"Surprise!!\\n\"); return 0; } int main() { printf(\"Not the main anymore\"); return 0; } On running the binary ./nomain.out we get,\nSurprise!! To understand what just happened, we need to look into the disassembly of this binary. – objdump -d nomain.out\nnomain.out: file format elf64-x86-64 Disassembly of section .plt: 0000000000001000 \u003c.plt\u003e: 1000:\tff 35 02 30 00 00 pushq 0x3002(%rip) # 4008 \u003c_GLOBAL_OFFSET_TABLE_+0x8\u003e 1006:\tff 25 04 30 00 00 jmpq *0x3004(%rip) # 4010 \u003c_GLOBAL_OFFSET_TABLE_+0x10\u003e 100c:\t0f 1f 40 00 nopl 0x0(%rax) 0000000000001010 : 1010:\tff 25 02 30 00 00 jmpq *0x3002(%rip) # 4018 1016:\t68 00 00 00 00 pushq $0x0 101b:\te9 e0 ff ff ff jmpq 1000 \u003c.plt\u003e 0000000000001020 : 1020:\tff 25 fa 2f 00 00 jmpq *0x2ffa(%rip) # 4020 1026:\t68 01 00 00 00 pushq $0x1 102b:\te9 d0 ff ff ff jmpq 1000 \u003c.plt\u003e 0000000000001030 : 1030:\tff 25 f2 2f 00 00 jmpq *0x2ff2(%rip) # 4028 1036:\t68 02 00 00 00 pushq $0x2 103b:\te9 c0 ff ff ff jmpq 1000 \u003c.plt\u003e Disassembly of section .text: 0000000000001040 \u003c_start\u003e: 1040:\t55 push %rbp 1041:\t48 89 e5 mov %rsp,%rbp 1044:\t48 83 ec 10 sub $0x10,%rsp 1048:\tb8 00 00 00 00 mov $0x0,%eax 104d:\te8 0d 00 00 00 callq 105f 1052:\t89 45 fc mov %eax,-0x4(%rbp) 1055:\t8b 45 fc mov -0x4(%rbp),%eax 1058:\t89 c7 mov %eax,%edi 105a:\te8 d1 ff ff ff callq 1030 000000000000105f : 105f:\t55 push %rbp 1060:\t48 89 e5 mov %rsp,%rbp 1063:\t48 8d 3d 96 0f 00 00 lea 0xf96(%rip),%rdi # 2000 106a:\te8 a1 ff ff ff callq 1010 106f:\tb8 00 00 00 00 mov $0x0,%eax 1074:\t5d pop %rbp 1075:\tc3 retq 0000000000001076 : 1076:\t55 push %rbp 1077:\t48 89 e5 mov %rsp,%rbp 107a:\t48 8d 3d 8a 0f 00 00 lea 0xf8a(%rip),%rdi # 200b 1081:\tb8 00 00 00 00 mov $0x0,%eax 1086:\te8 95 ff ff ff callq 1020 108b:\tb8 00 00 00 00 mov $0x0,%eax 1090:\t5d pop %rbp 1091:\tc3 retq This is pretty small as compared to the disassembly of simple.out. The reason here is clear that we have changed the _start and not implemented any of the fancy functions in it. And this reduces the size of my binary as well.\n$ du nomain.out simple.out 16\tnomain.out 20\tsimple.out What after _start ?? Till now, we have seen that we can pass our values to loader and replace _start with our custom functions… but this will not start __libc_start_main function.\nWhy do we need __libc_start_main to run??\n__libc_start_main is linked into our code from glibc. In general, it takes care of -\ntakes care of setuid and setguid program security problems. registers init and fini arguments. Calls the main function and exit with the return value of main. (This is something that we did in our custom function - nomain.c) This here is the definition for the __libc_start_main function which is implemented in the libc library.\nAs seen in the disassembly (of simple.out binary)… we can see that while calling (callq) the __libc_start_main function… we are passing main, __libc_csu_init and __libc_csu_fini… along with other things.\n0000000000001040 \u003c_start\u003e: 1040:\tf3 0f 1e fa endbr64 1044:\t31 ed xor %ebp,%ebp 1046:\t49 89 d1 mov %rdx,%r9 1049:\t5e pop %rsi 104a:\t48 89 e2 mov %rsp,%rdx 104d:\t48 83 e4 f0 and $0xfffffffffffffff0,%rsp 1051:\t50 push %rax 1052:\t54 push %rsp 1053:\t4c 8d 05 76 01 00 00 lea 0x176(%rip),%r8 # 11d0 \u003c__libc_csu_fini\u003e 105a:\t48 8d 0d ff 00 00 00 lea 0xff(%rip),%rcx # 1160 \u003c__libc_csu_init\u003e 1061:\t48 8d 3d d1 00 00 00 lea 0xd1(%rip),%rdi # 1139 1068:\tff 15 72 2f 00 00 callq *0x2f72(%rip) # 3fe0 \u003c__libc_start_main@GLIBC_2.2.5\u003e 106e:\tf4 hlt 106f:\t90 nop What’s next??\nNext thing that executes is __libc_csu_init which will call all the initializing functions. This phase runs before the main() function. The sequence which is followed(roughly) by the __libc_csu_init function is:\n__init __gmon_start__ frame_dummy __do_global_ctors_aux C level global constructors init array We’ll add our custom c level global constructor and init array function in below code(pre-main.c)…. and complie it with gcc pre-main.c -o pre-main.out.\n#include void init(int argc, char **argv, char **envp) { printf(\"%s\\n\", __FUNCTION__); } void __attribute__ ((constructor)) constructor() { printf(\"%s\\n\", __FUNCTION__); } __attribute__((section(\".init_array\"))) typeof(init) *__init = init; int main() { printf(\"Hello main\"); return 0; } This will give output as below\nconstructor init Hello main After main ?? As we have in the diagram, after main, exit function is called… which calls multiple functions in the below order:-\nat_exit fini_array constructor. The below code(after-main.c) can be used to demonstrate that.\n#include void fini() { printf(\"%s\\n\", __FUNCTION__); } void __attribute__ ((destructor)) destructor() { printf(\"%s\\n\", __FUNCTION__); } __attribute__((section(\".fini_array\"))) typeof(fini) *__fini = fini; void do_something_at_end() { printf(\"Bye bye\\n\"); } int main() { atexit(do_something_at_end); printf(\"Hello main\\n\"); return 0; } This will return the below output - which confirms the order of execution.\nHello main Bye bye fini destructor Here we can see that the atexit function is called before the printf function but in output the atexit output is after the printf is called. The reason here is that here atexit() is simply registering do_something_at_end function to run at exit. It’s not responsible to run it right away.\nThe end. This is pretty much what happens when we run an ELF binary or a C program in linux. In this article, I haven’t talked about a lot of other stuff that happens when a program executes… like setting up the environments variable for the program, how the memory layout is done or what is procedure linkage table(plt), etc…\nIf you find any information wrongly presented in this article, feel free to correct me. I am still learning this whole stuff and there are a lot of things yet to discover.\n","wordCount":"2038","inLanguage":"en","datePublished":"2021-01-27T14:58:51+05:30","dateModified":"2024-04-02T17:19:43+05:30","author":[{"@type":"Person","name":"ayedaemon"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://ayedaemon.github.io/post/2022/01/debugging-c-code/"},"publisher":{"@type":"Organization","name":"Connected","logo":{"@type":"ImageObject","url":"https://ayedaemon.github.io/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://ayedaemon.github.io/ accesskey=h title="Connected (Alt + H)">Connected</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://ayedaemon.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://ayedaemon.github.io/series/ title=Series><span>Series</span></a></li><li><a href=https://ayedaemon.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ayedaemon.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Debugging C Code</h1><div class=post-meta><span title='2021-01-27 14:58:51 +0530 +0530'>January 27, 2021</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;2038 words&nbsp;·&nbsp;ayedaemon&nbsp;|&nbsp;<a href=https://github.com/ayedaemon/ayedaemon.github.io/tree/main/content/post/2022/01/Debugging-C-code.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#basic-c-program aria-label="Basic C program">Basic C program</a></li><li><a href=#lets-decompile-our-simple-binary aria-label="Let&rsquo;s decompile our simple binary.">Let&rsquo;s decompile our simple binary.</a></li><li><a href=#the-whole-picture aria-label="The whole picture">The whole picture</a></li><li><a href=#what-after-_start- aria-label="What after _start ??">What after _start ??</a></li><li><a href=#after-main- aria-label="After main ??">After main ??</a></li><li><a href=#the-end aria-label="The end.">The end.</a></li></ul></div></details></div><div class=post-content><blockquote><p>How your x86 program starts up in linux</p></blockquote><p>In this blog, I will assume that you have basic understanding of assembly language. If not, then you should consider learning it. Although I&rsquo;ll try to explain things in the easiest terms as possible.</p><h3 id=basic-c-program>Basic C program<a hidden class=anchor aria-hidden=true href=#basic-c-program>#</a></h3><p>Let&rsquo;s start with a basic C program&mldr;</p><p><strong>CODE:</strong> (Saving it with <code>simple.c</code>)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Hello main&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>&mldr; and compile it the way we have always done it with <code>gcc</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gcc simple.c -o simple.out
</span></span></code></pre></div><p>Now I have got a file <code>simple.out</code> which should be my executable binary.. I have a habit to check the file using <code>file</code> command to be more sure.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ file simple.out
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>simple.out: ELF 64-bit LSB pie executable, x86-64, version <span class=m>1</span> <span class=o>(</span>SYSV<span class=o>)</span>, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID<span class=o>[</span>sha1<span class=o>]=</span>11c9b757baf9a3a8271443682135b7488cb04e52, <span class=k>for</span> GNU/Linux 3.2.0, not stripped
</span></span></code></pre></div><p>And now we know that it is an ELF binary and dynamically linked.</p><p>Let&rsquo;s see what shared objects they use.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ldd simple.out
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>linux-vdso.so.1 <span class=o>(</span>0x00007fffbc364000<span class=o>)</span>
</span></span><span class=line><span class=cl>libc.so.6 <span class=o>=</span>&gt; /usr/lib/libc.so.6 <span class=o>(</span>0x00007f5b0d6a7000<span class=o>)</span>
</span></span><span class=line><span class=cl>/lib64/ld-linux-x86-64.so.2 <span class=o>=</span>&gt; /usr/lib64/ld-linux-x86-64.so.2 <span class=o>(</span>0x00007f5b0d8b9000<span class=o>)</span>
</span></span></code></pre></div><p>The interesting one here is <code>libc.so.6 => /usr/lib/libc.so.6 (0x00007f5b0d6a7000)</code>. This shared object is used in almost every linux command you know. On checking the <code>man</code> page for libc.. I came to know that it is the standard C library used in linux.</p><p>The question I am asking myself here is &ndash;> <strong>Is this somehow responsible to execute the <code>main()</code> function in C programs.</strong></p><p>Maybe. We&rsquo;ll see that later.</p><h3 id=lets-decompile-our-simple-binary>Let&rsquo;s decompile our simple binary.<a hidden class=anchor aria-hidden=true href=#lets-decompile-our-simple-binary>#</a></h3><p>I can check the assembly code of the executable using <code>objdump -d simple.out</code> command on my terminal. It&rsquo;ll give me a lot of output but right now I am concerned about the <code>main()</code> function&mldr; so I&rsquo;ll just <code>grep</code> it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ objdump -d simple.out | grep -A12 &#39;&lt;main&gt;:&#39;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0000000000001139 &lt;main&gt;:
</span></span><span class=line><span class=cl>    1139:	55                   	push   %rbp
</span></span><span class=line><span class=cl>    113a:	48 89 e5             	mov    %rsp,%rbp
</span></span><span class=line><span class=cl>    113d:	48 8d 3d c0 0e 00 00 	lea    0xec0(%rip),%rdi        # 2004 &lt;_IO_stdin_used+0x4&gt;
</span></span><span class=line><span class=cl>    1144:	b8 00 00 00 00       	mov    $0x0,%eax
</span></span><span class=line><span class=cl>    1149:	e8 e2 fe ff ff       	callq  1030 &lt;printf@plt&gt;
</span></span><span class=line><span class=cl>    114e:	b8 00 00 00 00       	mov    $0x0,%eax
</span></span><span class=line><span class=cl>    1153:	5d                   	pop    %rbp
</span></span><span class=line><span class=cl>    1154:	c3                   	retq
</span></span><span class=line><span class=cl>    1155:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
</span></span><span class=line><span class=cl>    115c:	00 00 00
</span></span><span class=line><span class=cl>    115f:	90                   	nop
</span></span></code></pre></div><p><em>If you don&rsquo;t understand assembly, I get what you are feeling right now</em></p><p>But you don&rsquo;t need to understand it completely right now. You can look into some syntax and they&rsquo;ll make sense in some time.
Like <code>callq 1030 &lt;printf@plt></code> - this looks like out <code>printf()</code> function. And we know before calling a function, you need to pass its arguments on the stack. That means the <code>mov</code> just above the <code>callq</code> statement is my string <code>Hello main</code> (which is the argument passed to <code>printf()</code>)</p><p>Another Question &ndash;> <strong>Is <code>main()</code> really the starting point of execution??</strong></p><p>On further looking into the <code>objdump -d simple.out</code> command output&mldr; I can understand that there is another function<code>_start</code> that calls the <code>main()</code> function.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Disassembly of section .text:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0000000000001040 &lt;_start&gt;:
</span></span><span class=line><span class=cl>    1040:	f3 0f 1e fa          	endbr64
</span></span><span class=line><span class=cl>    1044:	31 ed                	xor    %ebp,%ebp
</span></span><span class=line><span class=cl>    1046:	49 89 d1             	mov    %rdx,%r9
</span></span><span class=line><span class=cl>    1049:	5e                   	pop    %rsi
</span></span><span class=line><span class=cl>    104a:	48 89 e2             	mov    %rsp,%rdx
</span></span><span class=line><span class=cl>    104d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
</span></span><span class=line><span class=cl>    1051:	50                   	push   %rax
</span></span><span class=line><span class=cl>    1052:	54                   	push   %rsp
</span></span><span class=line><span class=cl>    1053:	4c 8d 05 76 01 00 00 	lea    0x176(%rip),%r8        # 11d0 &lt;__libc_csu_fini&gt;
</span></span><span class=line><span class=cl>    105a:	48 8d 0d ff 00 00 00 	lea    0xff(%rip),%rcx        # 1160 &lt;__libc_csu_init&gt;
</span></span><span class=line><span class=cl>    1061:	48 8d 3d d1 00 00 00 	lea    0xd1(%rip),%rdi        # 1139 &lt;main&gt;
</span></span><span class=line><span class=cl>    1068:	ff 15 72 2f 00 00    	callq  *0x2f72(%rip)        # 3fe0 &lt;__libc_start_main@GLIBC_2.2.5&gt;
</span></span><span class=line><span class=cl>    106e:	f4                   	hlt
</span></span><span class=line><span class=cl>    106f:	90                   	nop
</span></span></code></pre></div><p>It does not call the <code>main()</code> directly.. But it takes <code>main()</code> as an argument and then calls __libc_start_main (from GlibC). Along with <code>main()</code>, it also takes <code>__libc_csu_fini</code> and <code>__libc_csu_init</code> as an argument.</p><h3 id=the-whole-picture>The whole picture<a hidden class=anchor aria-hidden=true href=#the-whole-picture>#</a></h3><p><img loading=lazy src=https://cdn-images-1.medium.com/max/640/0*HlrnUq2SuCxLLzuH.png alt=the-whole-picture></p><p><em>This image is taken from <a href=http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html>here</a>&mldr; This is a complete in-depth blog explaining <code>How the heck do we get to main()?</code></em></p><p>Now from the picture, it is very much clear that <code>_start</code> passes <code>main</code> (and other 2 functions) to <code>__libc_start_main</code>(function name was not sure from the disassembly). And <code>__libc_start_main</code> starts the <code>main()</code>.</p><p><strong>But what the hell is everything else??</strong></p><p>To start with, <strong>Loader</strong> is a program that loads executable from disk to RAM (primary memory) for execution. In unix, it is the handler for <code>execve()</code> system call. As per the <a href=https://en.wikipedia.org/wiki/Loader_%28computing%29#Responsibilities>wikipedia page for loader(computing)</a>, It&rsquo;s tasks include:</p><ol><li>validation (permissions, memory requirements etc.);</li><li>copying the program image from the disk into main memory;</li><li>copying the command-line arguments on the stack;</li><li>initializing registers (e.g., the stack pointer);</li><li>jumping to the program entry point (<code>_start</code>).</li></ol><p>But before getting to <code>_start</code>, it pre-initializes some global variables to help <code>_start</code>. You can create your custom <code>preinit</code> function as well. For this, you&rsquo;ll need the constructor function. And yes, it is not C++ and it has a constructor and destructor. Every executable has a global C level constructor and destructor.</p><p>This is a code (<code>unknown_functions.c</code>) to change the <code>preinit</code> function with my own. I have added 3 <code>printf()</code> statements to <code>preinit()</code> (which should be easy to figure out in assembly now).. I&rsquo;ll compile this code using <code>gcc unknown_functions.c -o unknown_functions.out</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>preinit</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>envp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>__FUNCTION__</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d , %s , %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argc</span><span class=p>,</span> <span class=o>*</span><span class=n>argv</span><span class=p>,</span> <span class=o>*</span><span class=n>envp</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;CLI arg : %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>__attribute__</span><span class=p>((</span><span class=nf>section</span><span class=p>(</span><span class=s>&#34;.preinit_array&#34;</span><span class=p>)))</span> <span class=nf>typeof</span><span class=p>(</span><span class=n>preinit</span><span class=p>)</span> <span class=o>*</span><span class=n>__preinit</span> <span class=o>=</span> <span class=n>preinit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>envp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;This is %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>__FUNCTION__</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d , %s , %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argc</span><span class=p>,</span> <span class=o>*</span><span class=n>argv</span><span class=p>,</span> <span class=o>*</span><span class=n>envp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;CLI arg : %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>On running it with <code>./unknown_functions.out</code>, I get some expected output.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>preinit
</span></span><span class=line><span class=cl>1 , ./unknown_functions.out , ALACRITTY_LOG=/tmp/Alacritty-161582.log
</span></span><span class=line><span class=cl>CLI arg : (null)
</span></span><span class=line><span class=cl>This is main
</span></span><span class=line><span class=cl>1 , ./unknown_functions.out , ALACRITTY_LOG=/tmp/Alacritty-161582.log
</span></span><span class=line><span class=cl>CLI arg : (null)
</span></span></code></pre></div><p>And we can also pass CLI argument to the binary like <code>./unknown_functions.out abcd1</code> and then it&rsquo;ll give an output like this-</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>preinit
</span></span><span class=line><span class=cl>2 , ./unknown_functions.out , ALACRITTY_LOG=/tmp/Alacritty-161582.log
</span></span><span class=line><span class=cl>CLI arg : abcd1
</span></span><span class=line><span class=cl>This is main
</span></span><span class=line><span class=cl>2 , ./unknown_functions.out , ALACRITTY_LOG=/tmp/Alacritty-161582.log
</span></span><span class=line><span class=cl>CLI arg : abcd1
</span></span></code></pre></div><p>With this, we know that <code>preinit</code> function runs before <code>main()</code>. Let&rsquo;s move forward with <code>_start</code>. This function is responsible to load <code>main()</code> by default. What if we change this function with our custom function and never call <code>main()</code>.</p><p>I am using below code(<code>nomain.c</code>) and compiling it with a (special flag this time) &ndash; <code>gcc nomain.c -nostartfiles -o nomain.out</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#include&lt;stdio.h&gt;
</span></span><span class=line><span class=cl>#include&lt;stdlib.h&gt; // For declaration of exit()
</span></span><span class=line><span class=cl>void _start()
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    int x = my_fun(); //calling custom main function
</span></span><span class=line><span class=cl>    exit(x);
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int my_fun() // our custom main function
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    printf(&#34;Surprise!!\n&#34;);
</span></span><span class=line><span class=cl>    return 0;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int main()
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  printf(&#34;Not the main anymore&#34;);
</span></span><span class=line><span class=cl>  return 0;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>On running the binary <code>./nomain.out</code> we get,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Surprise!!
</span></span></code></pre></div><p>To understand what just happened, we need to look into the disassembly of this binary. &ndash; <code>objdump -d nomain.out</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>nomain.out:     file format elf64-x86-64
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Disassembly of section .plt:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0000000000001000 &lt;.plt&gt;:
</span></span><span class=line><span class=cl>    1000:	ff 35 02 30 00 00    	pushq  0x3002(%rip)        # 4008 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;
</span></span><span class=line><span class=cl>    1006:	ff 25 04 30 00 00    	jmpq   *0x3004(%rip)        # 4010 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;
</span></span><span class=line><span class=cl>    100c:	0f 1f 40 00          	nopl   0x0(%rax)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0000000000001010 &lt;puts@plt&gt;:
</span></span><span class=line><span class=cl>    1010:	ff 25 02 30 00 00    	jmpq   *0x3002(%rip)        # 4018 &lt;puts@GLIBC_2.2.5&gt;
</span></span><span class=line><span class=cl>    1016:	68 00 00 00 00       	pushq  $0x0
</span></span><span class=line><span class=cl>    101b:	e9 e0 ff ff ff       	jmpq   1000 &lt;.plt&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0000000000001020 &lt;printf@plt&gt;:
</span></span><span class=line><span class=cl>    1020:	ff 25 fa 2f 00 00    	jmpq   *0x2ffa(%rip)        # 4020 &lt;printf@GLIBC_2.2.5&gt;
</span></span><span class=line><span class=cl>    1026:	68 01 00 00 00       	pushq  $0x1
</span></span><span class=line><span class=cl>    102b:	e9 d0 ff ff ff       	jmpq   1000 &lt;.plt&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0000000000001030 &lt;exit@plt&gt;:
</span></span><span class=line><span class=cl>    1030:	ff 25 f2 2f 00 00    	jmpq   *0x2ff2(%rip)        # 4028 &lt;exit@GLIBC_2.2.5&gt;
</span></span><span class=line><span class=cl>    1036:	68 02 00 00 00       	pushq  $0x2
</span></span><span class=line><span class=cl>    103b:	e9 c0 ff ff ff       	jmpq   1000 &lt;.plt&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Disassembly of section .text:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0000000000001040 &lt;_start&gt;:
</span></span><span class=line><span class=cl>    1040:	55                   	push   %rbp
</span></span><span class=line><span class=cl>    1041:	48 89 e5             	mov    %rsp,%rbp
</span></span><span class=line><span class=cl>    1044:	48 83 ec 10          	sub    $0x10,%rsp
</span></span><span class=line><span class=cl>    1048:	b8 00 00 00 00       	mov    $0x0,%eax
</span></span><span class=line><span class=cl>    104d:	e8 0d 00 00 00       	callq  105f &lt;my_fun&gt;
</span></span><span class=line><span class=cl>    1052:	89 45 fc             	mov    %eax,-0x4(%rbp)
</span></span><span class=line><span class=cl>    1055:	8b 45 fc             	mov    -0x4(%rbp),%eax
</span></span><span class=line><span class=cl>    1058:	89 c7                	mov    %eax,%edi
</span></span><span class=line><span class=cl>    105a:	e8 d1 ff ff ff       	callq  1030 &lt;exit@plt&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>000000000000105f &lt;my_fun&gt;:
</span></span><span class=line><span class=cl>    105f:	55                   	push   %rbp
</span></span><span class=line><span class=cl>    1060:	48 89 e5             	mov    %rsp,%rbp
</span></span><span class=line><span class=cl>    1063:	48 8d 3d 96 0f 00 00 	lea    0xf96(%rip),%rdi        # 2000 &lt;main+0xf8a&gt;
</span></span><span class=line><span class=cl>    106a:	e8 a1 ff ff ff       	callq  1010 &lt;puts@plt&gt;
</span></span><span class=line><span class=cl>    106f:	b8 00 00 00 00       	mov    $0x0,%eax
</span></span><span class=line><span class=cl>    1074:	5d                   	pop    %rbp
</span></span><span class=line><span class=cl>    1075:	c3                   	retq
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0000000000001076 &lt;main&gt;:
</span></span><span class=line><span class=cl>    1076:	55                   	push   %rbp
</span></span><span class=line><span class=cl>    1077:	48 89 e5             	mov    %rsp,%rbp
</span></span><span class=line><span class=cl>    107a:	48 8d 3d 8a 0f 00 00 	lea    0xf8a(%rip),%rdi        # 200b &lt;main+0xf95&gt;
</span></span><span class=line><span class=cl>    1081:	b8 00 00 00 00       	mov    $0x0,%eax
</span></span><span class=line><span class=cl>    1086:	e8 95 ff ff ff       	callq  1020 &lt;printf@plt&gt;
</span></span><span class=line><span class=cl>    108b:	b8 00 00 00 00       	mov    $0x0,%eax
</span></span><span class=line><span class=cl>    1090:	5d                   	pop    %rbp
</span></span><span class=line><span class=cl>    1091:	c3                   	retq
</span></span></code></pre></div><p>This is pretty small as compared to the disassembly of <code>simple.out</code>. The reason here is clear that we have changed the <code>_start</code> and not implemented any of the fancy functions in it. And this reduces the size of my binary as well.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ du nomain.out simple.out
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>16	nomain.out
</span></span><span class=line><span class=cl>20	simple.out
</span></span></code></pre></div><hr><h3 id=what-after-_start->What after _start ??<a hidden class=anchor aria-hidden=true href=#what-after-_start->#</a></h3><p>Till now, we have seen that we can pass our values to loader and replace <code>_start</code> with our custom functions&mldr; but this will not start <code>__libc_start_main</code> function.</p><p><strong>Why do we need <code>__libc_start_main</code> to run??</strong></p><p><code>__libc_start_main</code> is linked into our code from glibc. In general, it takes care of -</p><ol><li>takes care of setuid and setguid program security problems.</li><li>registers <code>init</code> and <code>fini</code> arguments.</li><li>Calls the <code>main</code> function and exit with the return value of <code>main</code>. (<em>This is something that we did in our custom function - <code>nomain.c</code></em>)</li></ol><p><a href=https://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/baselib---libc-start-main-.html>This here</a> is the definition for the <code>__libc_start_main</code> function which is implemented in the <code>libc</code> library.</p><p>As seen in the disassembly (of <code>simple.out</code> binary)&mldr; we can see that while calling (<code>callq</code>) the <code>__libc_start_main</code> function&mldr; we are passing <code>main</code>, <code>__libc_csu_init</code> and <code>__libc_csu_fini</code>&mldr; along with other things.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0000000000001040 &lt;_start&gt;:
</span></span><span class=line><span class=cl>    1040:	f3 0f 1e fa          	endbr64
</span></span><span class=line><span class=cl>    1044:	31 ed                	xor    %ebp,%ebp
</span></span><span class=line><span class=cl>    1046:	49 89 d1             	mov    %rdx,%r9
</span></span><span class=line><span class=cl>    1049:	5e                   	pop    %rsi
</span></span><span class=line><span class=cl>    104a:	48 89 e2             	mov    %rsp,%rdx
</span></span><span class=line><span class=cl>    104d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
</span></span><span class=line><span class=cl>    1051:	50                   	push   %rax
</span></span><span class=line><span class=cl>    1052:	54                   	push   %rsp
</span></span><span class=line><span class=cl>    1053:	4c 8d 05 76 01 00 00 	lea    0x176(%rip),%r8        # 11d0 &lt;__libc_csu_fini&gt;
</span></span><span class=line><span class=cl>    105a:	48 8d 0d ff 00 00 00 	lea    0xff(%rip),%rcx        # 1160 &lt;__libc_csu_init&gt;
</span></span><span class=line><span class=cl>    1061:	48 8d 3d d1 00 00 00 	lea    0xd1(%rip),%rdi        # 1139 &lt;main&gt;
</span></span><span class=line><span class=cl>    1068:	ff 15 72 2f 00 00    	callq  *0x2f72(%rip)        # 3fe0 &lt;__libc_start_main@GLIBC_2.2.5&gt;
</span></span><span class=line><span class=cl>    106e:	f4                   	hlt
</span></span><span class=line><span class=cl>    106f:	90                   	nop
</span></span></code></pre></div><p><strong>What&rsquo;s next??</strong></p><p>Next thing that executes is <code>__libc_csu_init</code> which will call all the initializing functions. This phase <em>runs before the <code>main()</code> function</em>. The sequence which is followed(roughly) by the <code>__libc_csu_init</code> function is:</p><ul><li><code>__init</code></li><li><code>__gmon_start__</code></li><li><code>frame_dummy</code></li><li><code>__do_global_ctors_aux</code></li><li><code>C level global constructors</code></li><li><code>init array</code></li></ul><p>We&rsquo;ll add our custom <code>c level global constructor</code> and <code>init array</code> function in below code(<code>pre-main.c</code>)&mldr;. and complie it with <code>gcc pre-main.c -o pre-main.out</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=c1>#include &lt;stdio.h&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>void</span> <span class=n>init</span><span class=p>(</span><span class=ne>int</span> <span class=n>argc</span><span class=p>,</span> <span class=n>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>,</span> <span class=n>char</span> <span class=o>**</span><span class=n>envp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>%s</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>__FUNCTION__</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>void</span>  <span class=n>__attribute__</span> <span class=p>((</span><span class=n>constructor</span><span class=p>))</span> <span class=n>constructor</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>%s</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>__FUNCTION__</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>__attribute__</span><span class=p>((</span><span class=n>section</span><span class=p>(</span><span class=s2>&#34;.init_array&#34;</span><span class=p>)))</span> <span class=nb>typeof</span><span class=p>(</span><span class=n>init</span><span class=p>)</span> <span class=o>*</span><span class=n>__init</span> <span class=o>=</span> <span class=n>init</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=ne>int</span> <span class=n>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;Hello main&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This will give output as below</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>constructor</span>
</span></span><span class=line><span class=cl><span class=n>init</span>
</span></span><span class=line><span class=cl><span class=n>Hello</span> <span class=n>main</span>
</span></span></code></pre></div><h3 id=after-main->After main ??<a hidden class=anchor aria-hidden=true href=#after-main->#</a></h3><p>As we have in the diagram, after <code>main</code>, <code>exit</code> function is called&mldr; which calls multiple functions in the below order:-</p><ol><li>at_exit</li><li>fini_array</li><li>constructor.</li></ol><p>The below code(<code>after-main.c</code>) can be used to demonstrate that.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>fini</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>__FUNCTION__</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>__attribute__</span> <span class=p>((</span><span class=n>destructor</span><span class=p>))</span> <span class=nf>destructor</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>__FUNCTION__</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>__attribute__</span><span class=p>((</span><span class=nf>section</span><span class=p>(</span><span class=s>&#34;.fini_array&#34;</span><span class=p>)))</span> <span class=nf>typeof</span><span class=p>(</span><span class=n>fini</span><span class=p>)</span> <span class=o>*</span><span class=n>__fini</span> <span class=o>=</span> <span class=n>fini</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>do_something_at_end</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Bye bye</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>atexit</span><span class=p>(</span><span class=n>do_something_at_end</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Hello main</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This will return the below output - which confirms the order of execution.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Hello main
</span></span><span class=line><span class=cl>Bye bye
</span></span><span class=line><span class=cl>fini
</span></span><span class=line><span class=cl>destructor
</span></span></code></pre></div><p>Here we can see that the <code>atexit</code> function is called before the <code>printf</code> function but in output the <code>atexit</code> output is after the <code>printf</code> is called. The reason here is that here <code>atexit()</code> is simply registering <code>do_something_at_end</code> function to run at exit. It&rsquo;s not responsible to run it right away.</p><hr><h3 id=the-end>The end.<a hidden class=anchor aria-hidden=true href=#the-end>#</a></h3><p>This is pretty much what happens when we run an ELF binary or a C program in linux. In this article, I haven&rsquo;t talked about a lot of other stuff that happens when a program executes&mldr; like setting up the environments variable for the program, how the memory layout is done or what is procedure linkage table(plt), etc&mldr;</p><p>If you find any information wrongly presented in this article, feel free to correct me. I am still learning this whole stuff and there are a lot of things yet to discover.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ayedaemon.github.io/tags/c-programming/>C programming</a></li><li><a href=https://ayedaemon.github.io/tags/debugging/>Debugging</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ayedaemon.github.io/>Connected</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>