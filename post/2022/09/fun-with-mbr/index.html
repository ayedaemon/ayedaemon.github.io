<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fun with Master Boot Record | Connected</title>
<meta name=keywords content="linux,mbr,bootloader"><meta name=description content="Analysis of bootloader and partition table; And some fun with Master Boot Record"><meta name=author content="ayedaemon"><link rel=canonical href=https://ayedaemon.github.io/post/2022/09/fun-with-mbr/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://ayedaemon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ayedaemon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ayedaemon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ayedaemon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ayedaemon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Fun with Master Boot Record"><meta property="og:description" content="Analysis of bootloader and partition table; And some fun with Master Boot Record"><meta property="og:type" content="article"><meta property="og:url" content="https://ayedaemon.github.io/post/2022/09/fun-with-mbr/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-09-28T01:10:18+05:30"><meta property="article:modified_time" content="2023-12-08T14:55:44+05:30"><meta property="og:site_name" content="Connected"><meta name=twitter:card content="summary"><meta name=twitter:title content="Fun with Master Boot Record"><meta name=twitter:description content="Analysis of bootloader and partition table; And some fun with Master Boot Record"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ayedaemon.github.io/post/"},{"@type":"ListItem","position":2,"name":"Fun with Master Boot Record","item":"https://ayedaemon.github.io/post/2022/09/fun-with-mbr/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Fun with Master Boot Record","name":"Fun with Master Boot Record","description":"Analysis of bootloader and partition table; And some fun with Master Boot Record","keywords":["linux","mbr","bootloader"],"articleBody":"Malware has been used numerous times by attackers to destroy a computer’s Master Boot Record, rendering it inoperable. By erasing the MBR, the machine is unable to load the operating system. There is no easy way to rewrite the Master Boot Record into place without an operating system, and the machine becomes completely useless and unrecoverable. In addition, many ransomwares infect the master boot record by overwriting it with malicious code. The system is then automatically restarted to allow the infection to take place. When the system restarts, the user is locked out, and the ransomware displays a note demanding payment. Simple money!\nTo understand how all of this is possible, and how an attacker can achieve it, we must first understand the MBR and the process of its execution.\nThe boot process The booting procedure of a system has become simpler over time, but this does not always imply that it is any easier. Every computer, big or small, goes through a start-up procedure known as the “Boot” process. Because different types of hardware operate in different ways, the boot procedure is heavily influenced by the type of CPU architecture and other hardware components.\nTo avoid confusion, I won’t go into great detail about each stage of the booting process. However, a typical linux booting procedure involves the following phases at a higher level:\nPower Up\nThis is the step where you press the power button. This triggers the BIOS 1 from motherboard’s flash memory to start executing it’s functions.\nPower On Self Test\nAfter BIOS is up and running, it initiates a quick self test to know if all the required hardware components are in working condition.\nFind a boot device\nThis step finds all the bootable devices from the earlier detected hard drives. The way this works is by checking the MBR (Master Boot Record) for each detected devices. MBR is refered to the first 512 bytes of any bootable device.\nLoad the MBR\nMBR is the first 512 bytes. These 512 bytes contains a bootloader, partition table and the magic number. This is loaded into ram and is responsible to read data from drives and start the operating system.\nLoad GRUB\nThis is a boot loader program which works in 2 stages. First stage is a small machine code binary on MBR. Its sole job is to locate the second stage boot loader and load it in memory. Once the second stage boot loader is in the memory, it presents the user with a graphical screen showing the different operating systems to choose from.\nKernel\nThe above OS selection decides what kernel and optional initramfs is to be loaded into memory. The kernel then initializes and configures the computer’s memory and configures the various hardware attached to the system, including all the I/O subsystems. After some more operations, the kernel is completely loaded into memory and is operational. It’s time to set up the user environment.\ninit\nThis is the first userspace program that is started by kernel. Now this starts and manages all the userspace processes like your web browser, file manager, web servers, etc.\nMBR and other little things Now that we are aware of how the boot procedure works, we can go on to the article’s main objective, the Master Boot Record. (but not this Master Boot Record)\nIf you’re not already aware, this is how a typical hard drive appears from the outside.\nThere are numerous components inside this small semi-metallic box that aid in its proper operation.\nBut we don’t need to know about all of these components; instead, we’ll concentrate on the disc-like structure in the centre. This is known as a platter. A platter is a single recording disc. A hard disc drive may have one or more platters.\nEach platter is divided into several circular tracks, and each track is further divided into several sectors. Each sector on a hard disc drive typically stores 512 bytes of user-accessible data.\nThe first 512 bytes (or first sector) of a hard drive is where the MBR is located. And since everything in Linux is a “file”, if we want to extract MBR data, all we have to do is to read the first 512 bytes of our bootable hard disk file and then write that content to another local file for further analysis. In most of the linux platforms, we can do this by dd 2 command.\ndd if=/dev/sda of=mbr.sample bs=512 count=1 The above command will read a 512-byte block (once) from /dev/sda and save it in the mbr.sample file. Then we can the check the type of this file using file command.\nfile mbr.sample ## Output # mbr.sample: x86 boot sector; partition 1: ID=0x83, active, starthead 32, startsector 2048, 2097152 sectors; partition 2: ID=0x8e, starthead 170, startsector 2099200, 41191424 sectors, code offset 0x63 An x86 boot sector is recognised in this file. Interestingly, it also lists the start head, start sector, total number of sectors, offset, and IDs of all the partitions. This was sufficient reason for me to dig up the file’s hexdump and understand how file command is able to gather all this information.\nhexdump -C mbr.sample Output:-\n00000000 eb 63 90 10 8e d0 bc 00 b0 b8 00 00 8e d8 8e c0 |.c..............| 00000010 fb be 00 7c bf 00 06 b9 00 02 f3 a4 ea 21 06 00 |...|.........!..| 00000020 00 be be 07 38 04 75 0b 83 c6 10 81 fe fe 07 75 |....8.u........u| 00000030 f3 eb 16 b4 02 b0 01 bb 00 7c b2 80 8a 74 01 8b |.........|...t..| 00000040 4c 02 cd 13 ea 00 7c 00 00 eb fe 00 00 00 00 00 |L.....|.........| 00000050 00 00 00 00 00 00 00 00 00 00 00 80 01 00 00 00 |................| 00000060 00 00 00 00 ff fa 90 90 f6 c2 80 74 05 f6 c2 70 |...........t...p| 00000070 74 02 b2 80 ea 79 7c 00 00 31 c0 8e d8 8e d0 bc |t....y|..1......| 00000080 00 20 fb a0 64 7c 3c ff 74 02 88 c2 52 be 05 7c |. ..d|\u003c.t...R..|| 00000090 b4 41 bb aa 55 cd 13 5a 52 72 3d 81 fb 55 aa 75 |.A..U..ZRr=..U.u| 000000a0 37 83 e1 01 74 32 31 c0 89 44 04 40 88 44 ff 89 |7...t21..D.@.D..| 000000b0 44 02 c7 04 10 00 66 8b 1e 5c 7c 66 89 5c 08 66 |D.....f..\\|f.\\.f| 000000c0 8b 1e 60 7c 66 89 5c 0c c7 44 06 00 70 b4 42 cd |..`|f.\\..D..p.B.| 000000d0 13 72 05 bb 00 70 eb 76 b4 08 cd 13 73 0d 5a 84 |.r...p.v....s.Z.| 000000e0 d2 0f 83 de 00 be 85 7d e9 82 00 66 0f b6 c6 88 |.......}...f....| 000000f0 64 ff 40 66 89 44 04 0f b6 d1 c1 e2 02 88 e8 88 |d.@f.D..........| 00000100 f4 40 89 44 08 0f b6 c2 c0 e8 02 66 89 04 66 a1 |.@.D.......f..f.| 00000110 60 7c 66 09 c0 75 4e 66 a1 5c 7c 66 31 d2 66 f7 |`|f..uNf.\\|f1.f.| 00000120 34 88 d1 31 d2 66 f7 74 04 3b 44 08 7d 37 fe c1 |4..1.f.t.;D.}7..| 00000130 88 c5 30 c0 c1 e8 02 08 c1 88 d0 5a 88 c6 bb 00 |..0........Z....| 00000140 70 8e c3 31 db b8 01 02 cd 13 72 1e 8c c3 60 1e |p..1......r...`.| 00000150 b9 00 01 8e db 31 f6 bf 00 80 8e c6 fc f3 a5 1f |.....1..........| 00000160 61 ff 26 5a 7c be 80 7d eb 03 be 8f 7d e8 34 00 |a.\u0026Z|..}....}.4.| 00000170 be 94 7d e8 2e 00 cd 18 eb fe 47 52 55 42 20 00 |..}.......GRUB .| 00000180 47 65 6f 6d 00 48 61 72 64 20 44 69 73 6b 00 52 |Geom.Hard Disk.R| 00000190 65 61 64 00 20 45 72 72 6f 72 0d 0a 00 bb 01 00 |ead. Error......| 000001a0 b4 0e cd 10 ac 3c 00 75 f4 c3 00 00 00 00 00 00 |.....\u003c.u........| 000001b0 00 00 00 00 00 00 00 00 70 7e 04 00 00 00 80 20 |........p~..... | 000001c0 21 00 83 aa 28 82 00 08 00 00 00 00 20 00 00 aa |!...(....... ...| 000001d0 29 82 8e fe ff ff 00 08 20 00 00 88 74 02 00 00 |)....... ...t...| 000001e0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa |..............U.| 00000200 Dissecting the Master Boot Record Without any knowledge of layout, simply looking at the hexdump output is not particularly helpful. Therefore, it is now necessary to understand the MBR layout.\nMBR consists of 3 parts - bootloader, partition table, and magic number.\nThe magic number is found in the final two bytes, as opposed to the regular userspace files. It is 55AA in the file, but be mindful of the processor’s endianness. Since my CPU is little endian, the leftmost bytes are read first. As a result, AA55 will become the magic number.\nAfter that is subtracted, we are left with 512-2 = 510 bytes. Out of these, the bootloader is stored in the first 446 bytes, and the partition tables are stored in the remaining 64 bytes. To evaluate these components separately, let’s extract them into distinct files using the same old dd command.\n## Bootlaoder dd if=mbr.sample of=mbr.bootloader bs=1 count=446 ## Partition table (skip first 446 bytes) dd if=mbr.sample of=mbr.partition_table bs=1 count=64 skip=446 ## magic (skip first 510 bytes) dd if=mbr.sample of=mbr.magic bs=1 count=2 skip=510 ## Check file types file * ## Output # mbr.bootloader: data # mbr.magic: BIOS (ia32) ROM Ext. # mbr.partition_table: 8086 relocatable (Microsoft) # mbr.sample: x86 boot sector; partition 1: ID=0x83, active, starthead 32, startsector 2048, 2097152 sectors; partition 2: ID=0x8e, starthead 170, startsector 2099200, 41191424 sectors, code offset 0x63 It’s fantastic that the file command can recognise each of these MBR components separately. Now with separate files, we can carefully examine the partition table and determine what data it can give us.\nhexdump -C -v mbr.partition_table Output:-\n00000000 80 20 21 00 83 aa 28 82 00 08 00 00 00 00 20 00 |. !...(....... .| 00000010 00 aa 29 82 8e fe ff ff 00 08 20 00 00 88 74 02 |..)....... ...t.| 00000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| The MBR system only supports 4 primary partitions since partition tables actually only contain 4 records. We must divide a primary partition into smaller partitions and keep a separate partition table inside of that primary partition if we want to construct more than four partitions. The term “Expanded partitions” is in fact used to describe these extended partitions. We can see from the result above that there are a total of 64 bytes, giving us a total of 64/4 = 16 bytes for each record. Let’s understand the layout of these 16 bytes and then we can analyze the partition table data using hexdump.\nSize (in bytes) Purpose 1 Boot indicator (0x80 for active and 0x00 for inactive) 1 partition start: head 1 partition start: sector 1 partition start: cylinder 1 Partition ID 1 partition end: head 1 partition end: sector 1 partition end: cylinder 4 Number of sectors before the beginning of this partition (sectors_before) 4 Number of sectors in this partition (number_of_sectors) There are 16 bytes in all of that. Now we know where the information that the file command was displaying previously comes from.\nBased on the information we have now, we can figure out few things on our own…\n00000000 80 20 21 00 83 aa 28 82 00 08 00 00 00 00 20 00 |. !...(....... .| 00000010 00 aa 29 82 8e fe ff ff 00 08 20 00 00 88 74 02 |..)....... ...t.| 00000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| For example, this disk only has 2 partitions because the final 2 records are all zeros. Due to the ‘0x80’ byte in the first records, the first partition is bootable. And the ID for that partition is 83. While the second partition is non bootable partition, and the ID of that partition is 82. If you want, you can even calculate the size of each partition with the help of other information present in these records.\nWe are now down to the first 446 bytes, which include the bootloader. The bootloader is simply a software that reads and loads other applications from the bootable partition.GRUB typically loads the second stage of itself from disk, however this is not a condition.There are bootloaders that load the kernel directly into memory or, even better, some of them are full-fledged application that just works. 3\nNote:- Although I won’t be discussing it today, you can use the ndisasm disassembler to disassemble the bootloader image.This will require for some knowledge of the interrupts and memory management in the BIOS, which is outside the scope of this blog.\nThat settles it; now that we are aware of what is contained within an MBR, why don’t we attempt to construct one?\nCreating your own bootloader To start, we’ll make a simple raw binary file and put AA55 in it. Keep in mind that this is the magic number that belongs in an MBR.\ndw 0xAA55 Save this file as custom bootloader.asm. After compiling it with the nasm compiler, the results should look like this.\n## Compile custom_bootloader.asm nasm -fbin custom_bootloader.asm -o custom_bootloader.bin ## Check the file type file rhel_magic_number custom_bootloader.bin ## Output # rhel_magic_number: ISO-8859 text, with no line terminators # custom_bootloader.bin: ISO-8859 text, with no line terminators ## Check hexdump hexdump -C custom_bootloader.bin ## Ouput # 00000000 55 aa |U.| # 00000002 We now have a 2 byte file containing the magic number. However, because the MBR is 512 bytes long, we must fill 510 more bytes. For the time being, let’s just fill it with zeros and see if it’s a valid MBR file.\ntimes 510 db 0 dw 0xAA55 The above code will write 0 510 times and then write AA55.\n## Compile custom_bootloader.asm nasm -fbin custom_bootloader.asm -o custom_bootloader.bin ## Check the file type file rhel_mbr custom_bootloader.bin ## Ouput # rhel_mbr: DOS/MBR boot sector # custom_bootloader.bin: DOS/MBR boot sector ## Check hexdump hexdump -C custom_bootloader.bin ## Ouput # 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| # * # 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa |..............U.| # 00000200 This is, as expected, a valid MBR file with no information about the partition table or the bootloader. Can we, however, use this to boot the system?\nLet’s make an attempt.\nI first tried without any mbr data to see what errors I would get when it fails.\nqemu-system-x86_64 And, as I was expecting, it said “no bootable device.”\nLet’s run the test again, but this time with the MBR file we made.\nIt did not give me the error this time. That must imply that our MBR is functional. Since it lacks bootloader code, it does nothing. However, it is not returning the same previous error.\nWe can now add new instructions to our assembly file. However, we must keep in mind that we do not exceed the file’s 512-byte limit. That means we’ll have to take care of the zeros we’re padding with. Because this is a very simple problem, there are special characters that can assist us in calculating the memory address of the beginning of the file and the current address in the file.\ntimes 510-($-$$) db 0 ;$ - Start addr; $$ - current addr dw 0xAA55 We can calculate the exact number of zeros required for padding using these special characters. Let’s compile it and put it to the test.\nnasm -fbin custom_bootloader.asm -o custom_bootloader.bin qemu-system-x86_64 custom_bootloader.bin This produces the same results as before, and the output file size remains 512 bytes. Let’s add some more instructions to help us write some text on the screen.\nUnlike userspace and kernelspace programs, we do not have any helper functions that can take a string and automatically print it to the screen. We’ll have to tell the BIOS to do what we want here. And the only way I’m aware of is through interrupts. It is the same facility that operating systems and application programmes use to access BIOS functions.\nHere is a list of common BIOS interrupts. Not all BIOS (especially older ones) support all of these interrupts. The basic idea of using interrupts is we place proper values in some specific registers, and then trigger the interrupt. The interrupt routine will then fetch the values from those registers and based on that, it’ll perform some action.\nAnyway, using the above table, I determined that we needed to use interrupt vector 10h (or 0x10) with interrupt vector 03h (or 0x03) in AH register. Consider it as invoking the 10h function with the parameter value 03h. This returns the cursor’s current position and shape.\nmov ah, 0x03; int 10h times 510-($-$$) db 0 dw 0xAA55 We can see that some initial bytes are written to the binary file after compiling and inspecting the hexdump…. And, thanks to $ and $$, the file size remains 512 bytes.\n# Compiling the binary nasm -fbin custom_bootloader.asm -o custom_bootloader.bin ## Checking hexdump hexdump -C custom_bootloader.bin ## Output # 00000000 b8 03 00 cd 10 00 00 00 00 00 00 00 00 00 00 00 |................| # 00000010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| # * # 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa |..............U.| # 00000200 This switches the BIOS to TTY mode, allowing me to print characters using the same interrupt 10h but with a different value in the ah register.\nmov ah, 0x03 int 10h mov ah, 0xE mov al, 'H' int 0x10 mov al, 'E' int 0x10 mov al, 'Y' int 0x10 times 510-($-$$) db 0 dw 0xAA55 When we compile and run this with qemu, we get the message “HEY” printed on the screen.\nNow that we know how to write characters on the screen, let’s make a string and loop through it until the end, printing each character on the screen one by one using the same interrupt combination.\n; Setup TTY mode mov ax, 0x03 int 10h mov si, msg ; si register now points to msg mov ah, 0Eh ; Use write function from 10h interrupt .loop: lodsb ; load first char from msg and point to next char or al, al ; Check if end of string jz halt ; if end of string, jump to halt int 10h ; else, print char via interrupt jmp .loop ; loop halt: msg: db \"Hack the world\", 0 times 510-($-$$) db 0 dw 0xAA55 Unfortunately, testing the above code does not produce the desired results, but instead produces some garbage values.\nFurther investigation revealed that our bootloader in memory is not properly aligned. This led me down another rabbit hole, this time about how the contents of the computer’s physical memory look when the BIOS jumps to my bootloader code. Here is a dedicated page on the same topic here which covers a lot of details about it.\nFor us, we need to add a few more instructions to our code to properly align it. Finally, our code will look like this.\nbits 16 ; BIOS works in 16 bit mode org 0x7c00 ; MBR is loaded at 0x7c00 memory location mov ax, 0x03 int 10h mov si, msg mov ah, 0Eh .loop: lodsb or al, al jz halt int 10h jmp .loop halt: cli ; disable further interrupts hlt ; halt msg: db \"Hack the world!!\", 0 times 510-($-$$) db 0 dw 0xAA55 This time we get the desired result after compiling and testing the above. We successfully created a bootloader that prints some message on the screen.\nConclusions We know that a MBR sector is comprised of 3 parts:\nbootloader (446 bytes) partition table (64 bytes) magic number (2 bytes) And each component can be extracted separately and treated as a regular binary file. This means that we can create backups of only partition tables if necessary. Alternatively, we can replace the bootloader code with another code without affecting the partition table.(Obviously for fun; like a friendly joke, nothing malicious) 😈 😈\nWe know our above “Hack the World!!” code does not use all 510 bytes, so why not shrink it a little to fit in 446 bytes? This way we can protect the original partition table.\nbits 16 org 0x7c00 mov ax, 0x03 int 10h mov si, msg mov ah, 0Eh .loop: lodsb or al, al jz halt int 10h jmp .loop halt: cli hlt msg: db \"Hack the world!!\", 0 times 446-($-$$) db 0 ; Just change 510 to 446 :) dw 0xAA55 This will generate the raw data file containing the bootloader program, which we can quickly test in a virtual machine.\nVagrant.configure(\"2\") do |config| config.vm.box = \"archlinux/archlinux\" config.vm.box_check_update = true config.vm.provider \"virtualbox\" do |vb| vb.gui = true vb.memory = \"512\" end config.vm.provision \"shell\", inline: \u003c\u003c-SHELL # Backup the original bootloader dd \\ if=/dev/sda \\ of=/vagrant/backedup_bootloader.bin \\ bs=1 \\ count=446 # Copy the fun bootloader to first 446 bytes of sda dd \\ if=/vagrant/custom_bootloader.bin \\ of=/dev/sda \\ bs=1 \\ count=446 # Reboot the system to see the effect reboot SHELL end The Vagrantfile above will launch a quick test VM. We just need to sit back and relax.\nAfter successful bootup and reboot, It displayed the expected message.\nhttps://en.wikipedia.org/wiki/BIOS ↩︎\nhttps://www.man7.org/linux/man-pages/man1/dd.1.html ↩︎\nhttps://forum.osdev.org/viewtopic.php?f=2\u0026t=18763 ↩︎\n","wordCount":"3702","inLanguage":"en","datePublished":"2022-09-28T01:10:18+05:30","dateModified":"2023-12-08T14:55:44+05:30","author":[{"@type":"Person","name":"ayedaemon"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://ayedaemon.github.io/post/2022/09/fun-with-mbr/"},"publisher":{"@type":"Organization","name":"Connected","logo":{"@type":"ImageObject","url":"https://ayedaemon.github.io/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://ayedaemon.github.io/ accesskey=h title="Connected (Alt + H)">Connected</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://ayedaemon.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://ayedaemon.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ayedaemon.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ayedaemon.github.io/series/ title=Series><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ayedaemon.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ayedaemon.github.io/post/>Posts</a></div><h1 class=post-title>Fun with Master Boot Record</h1><div class=post-description>Analysis of bootloader and partition table; And some fun with Master Boot Record</div><div class=post-meta><span title='2022-09-28 01:10:18 +0530 +0530'>September 28, 2022</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;3702 words&nbsp;·&nbsp;ayedaemon&nbsp;|&nbsp;<a href=https://github.com/ayedaemon/ayedaemon.github.io/tree/main/content/post/2022/09/fun-with-mbr.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#the-boot-process>The boot process</a></li><li><a href=#mbr-and-other-little-things>MBR and other little things</a><ul><li><a href=#dissecting-the-master-boot-record>Dissecting the Master Boot Record</a></li></ul></li><li><a href=#creating-your-own-bootloader>Creating your own bootloader</a></li><li><a href=#conclusions>Conclusions</a></li></ul></nav></div></details></div><div class=post-content><p>Malware has been used numerous times by attackers to destroy a computer&rsquo;s Master Boot Record, rendering it inoperable. By erasing the MBR, the machine is unable to load the operating system. There is no easy way to rewrite the Master Boot Record into place without an operating system, and the machine becomes completely useless and unrecoverable. In addition, many ransomwares infect the master boot record by overwriting it with malicious code. The system is then automatically restarted to allow the infection to take place. When the system restarts, the user is locked out, and the ransomware displays a note demanding payment. Simple money!</p><p>To understand how all of this is possible, and how an attacker can achieve it, we must first understand the MBR and the process of its execution.</p><h2 id=the-boot-process>The boot process<a hidden class=anchor aria-hidden=true href=#the-boot-process>#</a></h2><p>The booting procedure of a system has become simpler over time, but this does not always imply that it is any easier. Every computer, big or small, goes through a start-up procedure known as the &ldquo;Boot&rdquo; process. Because different types of hardware operate in different ways, the boot procedure is heavily influenced by the type of CPU architecture and other hardware components.</p><p>To avoid confusion, I won&rsquo;t go into great detail about each stage of the booting process. However, a typical linux booting procedure involves the following phases at a higher level:</p><ol><li><p><strong>Power Up</strong></p><p>This is the step where you press the power button. This triggers the <a href=https://en.wikipedia.org/wiki/BIOS>BIOS</a> <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> from motherboard&rsquo;s flash memory to start executing it&rsquo;s functions.</p></li><li><p><strong>Power On Self Test</strong></p><p>After BIOS is up and running, it initiates a quick self test to know if all the required hardware components are in working condition.</p></li><li><p><strong>Find a boot device</strong></p><p>This step finds all the bootable devices from the earlier detected hard drives. The way this works is by checking the MBR (Master Boot Record) for each detected devices. MBR is refered to the first 512 bytes of any bootable device.</p></li><li><p><strong>Load the MBR</strong></p><p>MBR is the first 512 bytes. These 512 bytes contains a bootloader, partition table and the magic number. This is loaded into ram and is responsible to read data from drives and start the operating system.</p></li><li><p><strong>Load GRUB</strong></p><p>This is a boot loader program which works in 2 stages. First stage is a small machine code binary on MBR. Its sole job is to locate the second stage boot loader and load it in memory. Once the second stage boot loader is in the memory, it presents the user with a graphical screen showing the different operating systems to choose from.</p></li><li><p><strong>Kernel</strong></p><p>The above OS selection decides what kernel and optional initramfs is to be loaded into memory. The kernel then initializes and configures the computer&rsquo;s memory and configures the various hardware attached to the system, including all the I/O subsystems. After some more operations, the kernel is completely loaded into memory and is operational. It&rsquo;s time to set up the user environment.</p></li><li><p><strong>init</strong></p><p>This is the first userspace program that is started by kernel. Now this starts and manages all the userspace processes like your web browser, file manager, web servers, etc.</p></li></ol><h2 id=mbr-and-other-little-things>MBR and other little things<a hidden class=anchor aria-hidden=true href=#mbr-and-other-little-things>#</a></h2><p>Now that we are aware of how the boot procedure works, we can go on to the article&rsquo;s main objective, the <a href=https://en.wikipedia.org/wiki/Master_boot_record>Master Boot Record</a>. (but not this <a href=https://www.youtube.com/c/MasterBootRecord>Master Boot Record</a>)</p><p>If you&rsquo;re not already aware, this is how a typical hard drive appears from the outside.</p><p><img loading=lazy src="https://external-preview.redd.it/MNhQwTRxl_vXaEKZikrhbSz0A_vSK0zMzRFH5g7ZvOM.jpg?auto=webp&amp;s=7ac34d2a3701d51967d02fab59eea9bb2db7f1da#center" alt="source: reddit"></p><p>There are numerous components inside this small semi-metallic box that aid in its proper operation.</p><p><img loading=lazy src=https://www.researchgate.net/profile/Mostafa-Sabbaghi/publication/317472565/figure/fig2/AS:613957429645317@1523390266281/Intact-HDD-with-the-cover-removed-left-and-exploded-image-of-a-HDD-showing-individual.png#center alt="source: researchgate.net"></p><p>But we don&rsquo;t need to know about all of these components; instead, we&rsquo;ll concentrate on the disc-like structure in the centre. This is known as a <strong>platter</strong>. A platter is a single recording disc. A hard disc drive may have one or more platters.</p><p><img loading=lazy src=https://safemode.com.au/wp-content/uploads/2020/01/hard-drive-parts-min.png#center alt="source: safemode.com"></p><p>Each platter is divided into several circular tracks, and each track is further divided into several sectors. Each sector on a hard disc drive typically stores 512 bytes of user-accessible data.</p><p><img loading=lazy src=https://qph.fs.quoracdn.net/main-qimg-0763e88136c511a9f93c49ce3e84360f#center alt="source: quora"></p><p>The first 512 bytes (or first sector) of a hard drive is where the MBR is located. And since everything in Linux is a &ldquo;file&rdquo;, if we want to extract MBR data, all we have to do is to read the first 512 bytes of our bootable hard disk file and then write that content to another local file for further analysis. In most of the linux platforms, we can do this by <a href=https://www.man7.org/linux/man-pages/man1/dd.1.html><code>dd</code></a> <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> command.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dd if=/dev/sda of=mbr.sample bs=512 count=1
</span></span></code></pre></div><p>The above command will read a 512-byte block (once) from <code>/dev/sda</code> and save it in the <code>mbr.sample</code> file. Then we can the check the type of this file using <code>file</code> command.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>file mbr.sample
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## Output</span>
</span></span><span class=line><span class=cl><span class=c1># mbr.sample: x86 boot sector; partition 1: ID=0x83, active, starthead 32, startsector 2048, 2097152 sectors; partition 2: ID=0x8e, starthead 170, startsector 2099200, 41191424 sectors, code offset 0x63</span>
</span></span></code></pre></div><p>An x86 boot sector is recognised in this file. Interestingly, it also lists the start head, start sector, total number of sectors, offset, and IDs of all the partitions. This was sufficient reason for me to dig up the file&rsquo;s hexdump and understand how <code>file</code> command is able to gather all this information.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>hexdump -C mbr.sample
</span></span></code></pre></div><p>Output:-</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>00000000  eb 63 90 10 8e d0 bc 00  b0 b8 00 00 8e d8 8e c0  |.c..............|
</span></span><span class=line><span class=cl>00000010  fb be 00 7c bf 00 06 b9  00 02 f3 a4 ea 21 06 00  |...|.........!..|
</span></span><span class=line><span class=cl>00000020  00 be be 07 38 04 75 0b  83 c6 10 81 fe fe 07 75  |....8.u........u|
</span></span><span class=line><span class=cl>00000030  f3 eb 16 b4 02 b0 01 bb  00 7c b2 80 8a 74 01 8b  |.........|...t..|
</span></span><span class=line><span class=cl>00000040  4c 02 cd 13 ea 00 7c 00  00 eb fe 00 00 00 00 00  |L.....|.........|
</span></span><span class=line><span class=cl>00000050  00 00 00 00 00 00 00 00  00 00 00 80 01 00 00 00  |................|
</span></span><span class=line><span class=cl>00000060  00 00 00 00 ff fa 90 90  f6 c2 80 74 05 f6 c2 70  |...........t...p|
</span></span><span class=line><span class=cl>00000070  74 02 b2 80 ea 79 7c 00  00 31 c0 8e d8 8e d0 bc  |t....y|..1......|
</span></span><span class=line><span class=cl>00000080  00 20 fb a0 64 7c 3c ff  74 02 88 c2 52 be 05 7c  |. ..d|&lt;.t...R..||
</span></span><span class=line><span class=cl>00000090  b4 41 bb aa 55 cd 13 5a  52 72 3d 81 fb 55 aa 75  |.A..U..ZRr=..U.u|
</span></span><span class=line><span class=cl>000000a0  37 83 e1 01 74 32 31 c0  89 44 04 40 88 44 ff 89  |7...t21..D.@.D..|
</span></span><span class=line><span class=cl>000000b0  44 02 c7 04 10 00 66 8b  1e 5c 7c 66 89 5c 08 66  |D.....f..\|f.\.f|
</span></span><span class=line><span class=cl>000000c0  8b 1e 60 7c 66 89 5c 0c  c7 44 06 00 70 b4 42 cd  |..`|f.\..D..p.B.|
</span></span><span class=line><span class=cl>000000d0  13 72 05 bb 00 70 eb 76  b4 08 cd 13 73 0d 5a 84  |.r...p.v....s.Z.|
</span></span><span class=line><span class=cl>000000e0  d2 0f 83 de 00 be 85 7d  e9 82 00 66 0f b6 c6 88  |.......}...f....|
</span></span><span class=line><span class=cl>000000f0  64 ff 40 66 89 44 04 0f  b6 d1 c1 e2 02 88 e8 88  |d.@f.D..........|
</span></span><span class=line><span class=cl>00000100  f4 40 89 44 08 0f b6 c2  c0 e8 02 66 89 04 66 a1  |.@.D.......f..f.|
</span></span><span class=line><span class=cl>00000110  60 7c 66 09 c0 75 4e 66  a1 5c 7c 66 31 d2 66 f7  |`|f..uNf.\|f1.f.|
</span></span><span class=line><span class=cl>00000120  34 88 d1 31 d2 66 f7 74  04 3b 44 08 7d 37 fe c1  |4..1.f.t.;D.}7..|
</span></span><span class=line><span class=cl>00000130  88 c5 30 c0 c1 e8 02 08  c1 88 d0 5a 88 c6 bb 00  |..0........Z....|
</span></span><span class=line><span class=cl>00000140  70 8e c3 31 db b8 01 02  cd 13 72 1e 8c c3 60 1e  |p..1......r...`.|
</span></span><span class=line><span class=cl>00000150  b9 00 01 8e db 31 f6 bf  00 80 8e c6 fc f3 a5 1f  |.....1..........|
</span></span><span class=line><span class=cl>00000160  61 ff 26 5a 7c be 80 7d  eb 03 be 8f 7d e8 34 00  |a.&amp;Z|..}....}.4.|
</span></span><span class=line><span class=cl>00000170  be 94 7d e8 2e 00 cd 18  eb fe 47 52 55 42 20 00  |..}.......GRUB .|
</span></span><span class=line><span class=cl>00000180  47 65 6f 6d 00 48 61 72  64 20 44 69 73 6b 00 52  |Geom.Hard Disk.R|
</span></span><span class=line><span class=cl>00000190  65 61 64 00 20 45 72 72  6f 72 0d 0a 00 bb 01 00  |ead. Error......|
</span></span><span class=line><span class=cl>000001a0  b4 0e cd 10 ac 3c 00 75  f4 c3 00 00 00 00 00 00  |.....&lt;.u........|
</span></span><span class=line><span class=cl>000001b0  00 00 00 00 00 00 00 00  70 7e 04 00 00 00 80 20  |........p~..... |
</span></span><span class=line><span class=cl>000001c0  21 00 83 aa 28 82 00 08  00 00 00 00 20 00 00 aa  |!...(....... ...|
</span></span><span class=line><span class=cl>000001d0  29 82 8e fe ff ff 00 08  20 00 00 88 74 02 00 00  |)....... ...t...|
</span></span><span class=line><span class=cl>000001e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
</span></span><span class=line><span class=cl>000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|
</span></span><span class=line><span class=cl>00000200
</span></span></code></pre></div><p><img loading=lazy src=https://media.giphy.com/media/3o6MbbwX2g2GA4MUus/giphy.gif#center alt></p><h3 id=dissecting-the-master-boot-record>Dissecting the Master Boot Record<a hidden class=anchor aria-hidden=true href=#dissecting-the-master-boot-record>#</a></h3><p>Without any knowledge of layout, simply looking at the <code>hexdump</code> output is not particularly helpful. Therefore, it is now necessary to understand the MBR layout.</p><p>MBR consists of 3 parts - <strong>bootloader</strong>, <strong>partition table</strong>, and <strong>magic number</strong>.</p><p>The magic number is found in the final two bytes, as opposed to the regular userspace files. It is <code>55AA</code> in the file, but be mindful of the processor&rsquo;s endianness. Since my CPU is little endian, the leftmost bytes are read first. As a result, <code>AA55</code> will become the magic number.</p><p>After that is subtracted, we are left with <code>512-2 = 510</code> bytes. Out of these, the bootloader is stored in the first <code>446</code> bytes, and the partition tables are stored in the remaining <code>64</code> bytes. To evaluate these components separately, let&rsquo;s extract them into distinct files using the same old <code>dd</code> command.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>## Bootlaoder</span>
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span>mbr.sample <span class=nv>of</span><span class=o>=</span>mbr.bootloader <span class=nv>bs</span><span class=o>=</span><span class=m>1</span> <span class=nv>count</span><span class=o>=</span><span class=m>446</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## Partition table (skip first 446 bytes)</span>
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span>mbr.sample <span class=nv>of</span><span class=o>=</span>mbr.partition_table <span class=nv>bs</span><span class=o>=</span><span class=m>1</span> <span class=nv>count</span><span class=o>=</span><span class=m>64</span> <span class=nv>skip</span><span class=o>=</span><span class=m>446</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## magic (skip first 510 bytes)</span>
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span>mbr.sample <span class=nv>of</span><span class=o>=</span>mbr.magic <span class=nv>bs</span><span class=o>=</span><span class=m>1</span> <span class=nv>count</span><span class=o>=</span><span class=m>2</span> <span class=nv>skip</span><span class=o>=</span><span class=m>510</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## Check file types</span>
</span></span><span class=line><span class=cl>file *
</span></span><span class=line><span class=cl><span class=c1>## Output</span>
</span></span><span class=line><span class=cl><span class=c1># mbr.bootloader:      data</span>
</span></span><span class=line><span class=cl><span class=c1># mbr.magic:           BIOS (ia32) ROM Ext.</span>
</span></span><span class=line><span class=cl><span class=c1># mbr.partition_table: 8086 relocatable (Microsoft)</span>
</span></span><span class=line><span class=cl><span class=c1># mbr.sample:          x86 boot sector; partition 1: ID=0x83, active, starthead 32, startsector 2048, 2097152 sectors; partition 2: ID=0x8e, starthead 170, startsector 2099200, 41191424 sectors, code offset 0x63</span>
</span></span></code></pre></div><p>It&rsquo;s fantastic that the file command can recognise each of these MBR components separately. Now with separate files, we can carefully examine the partition table and determine what data it can give us.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>hexdump -C -v  mbr.partition_table
</span></span></code></pre></div><p>Output:-</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>00000000  80 20 21 00 83 aa 28 82  00 08 00 00 00 00 20 00  |. !...(....... .|
</span></span><span class=line><span class=cl>00000010  00 aa 29 82 8e fe ff ff  00 08 20 00 00 88 74 02  |..)....... ...t.|
</span></span><span class=line><span class=cl>00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
</span></span><span class=line><span class=cl>00000030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
</span></span></code></pre></div><p>The MBR system only supports 4 primary partitions since partition tables actually only contain 4 records. We must divide a primary partition into smaller partitions and keep a separate partition table inside of that primary partition if we want to construct more than four partitions. The term &ldquo;Expanded partitions&rdquo; is in fact used to describe these extended partitions. We can see from the result above that there are a total of 64 bytes, giving us a total of <code>64/4 = 16</code> bytes for each record. Let&rsquo;s understand the layout of these 16 bytes and then we can analyze the partition table data using <code>hexdump</code>.</p><table><thead><tr><th>Size (in bytes)</th><th>Purpose</th></tr></thead><tbody><tr><td>1</td><td>Boot indicator (0x80 for active and 0x00 for inactive)</td></tr><tr><td>1</td><td>partition start: head</td></tr><tr><td>1</td><td>partition start: sector</td></tr><tr><td>1</td><td>partition start: cylinder</td></tr><tr><td>1</td><td>Partition ID</td></tr><tr><td>1</td><td>partition end: head</td></tr><tr><td>1</td><td>partition end: sector</td></tr><tr><td>1</td><td>partition end: cylinder</td></tr><tr><td>4</td><td>Number of sectors before the beginning of this partition (sectors_before)</td></tr><tr><td>4</td><td>Number of sectors in this partition (number_of_sectors)</td></tr></tbody></table><p>There are 16 bytes in all of that. Now we know where the information that the <code>file</code> command was displaying previously comes from.</p><p>Based on the information we have now, we can figure out few things on our own&mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>00000000  80 20 21 00 83 aa 28 82  00 08 00 00 00 00 20 00  |. !...(....... .|
</span></span><span class=line><span class=cl>00000010  00 aa 29 82 8e fe ff ff  00 08 20 00 00 88 74 02  |..)....... ...t.|
</span></span><span class=line><span class=cl>00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
</span></span><span class=line><span class=cl>00000030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
</span></span></code></pre></div><p>For example, this disk only has 2 partitions because the final 2 records are all zeros. Due to the &lsquo;0x80&rsquo; byte in the first records, the first partition is bootable. And the ID for that partition is <code>83</code>. While the second partition is non bootable partition, and the ID of that partition is <code>82</code>. If you want, you can even calculate the size of each partition with the help of other information present in these records.</p><p>We are now down to the first <code>446</code> bytes, which include the bootloader.
The bootloader is simply a software that reads and loads other applications from the bootable partition.GRUB typically loads the second stage of itself from disk, however this is not a condition.There are bootloaders that load the kernel directly into memory or, even better, some of them are <a href="https://forum.osdev.org/viewtopic.php?f=2&amp;t=18763">full-fledged application that just works</a>. <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><p><em>Note:- Although I won&rsquo;t be discussing it today, you can use the <code>ndisasm</code> disassembler to disassemble the bootloader image.This will require for some knowledge of the interrupts and memory management in the BIOS, which is outside the scope of this blog.</em></p><p>That settles it; now that we are aware of what is contained within an MBR, why don&rsquo;t we attempt to construct one?</p><p><img loading=lazy src=https://media.giphy.com/media/R459x856IfF6w/giphy.gif#center alt></p><h2 id=creating-your-own-bootloader>Creating your own bootloader<a hidden class=anchor aria-hidden=true href=#creating-your-own-bootloader>#</a></h2><p>To start, we&rsquo;ll make a simple raw binary file and put <code>AA55</code> in it. Keep in mind that this is the <strong>magic number</strong> that belongs in an MBR.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>dw</span> <span class=mi>0xAA55</span>
</span></span></code></pre></div><p>Save this file as <code>custom bootloader.asm</code>. After compiling it with the <code>nasm</code> compiler, the results should look like this.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>## Compile custom_bootloader.asm</span>
</span></span><span class=line><span class=cl>nasm -fbin custom_bootloader.asm -o custom_bootloader.bin
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## Check the file type</span>
</span></span><span class=line><span class=cl>file rhel_magic_number custom_bootloader.bin
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## Output</span>
</span></span><span class=line><span class=cl><span class=c1># rhel_magic_number:     ISO-8859 text, with no line terminators</span>
</span></span><span class=line><span class=cl><span class=c1># custom_bootloader.bin: ISO-8859 text, with no line terminators</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## Check hexdump</span>
</span></span><span class=line><span class=cl>hexdump -C custom_bootloader.bin
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## Ouput</span>
</span></span><span class=line><span class=cl><span class=c1># 00000000  55 aa                                             |U.|</span>
</span></span><span class=line><span class=cl><span class=c1># 00000002</span>
</span></span></code></pre></div><p>We now have a 2 byte file containing the magic number. However, because the MBR is 512 bytes long, we must fill 510 more bytes. For the time being, let&rsquo;s just fill it with zeros and see if it&rsquo;s a valid MBR file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>times</span> <span class=mi>510</span> <span class=no>db</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=nf>dw</span> <span class=mi>0xAA55</span>
</span></span></code></pre></div><p>The above code will write <code>0</code> 510 times and then write <code>AA55</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>## Compile custom_bootloader.asm</span>
</span></span><span class=line><span class=cl>nasm -fbin custom_bootloader.asm -o custom_bootloader.bin
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## Check the file type</span>
</span></span><span class=line><span class=cl>file rhel_mbr custom_bootloader.bin
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## Ouput</span>
</span></span><span class=line><span class=cl><span class=c1># rhel_mbr:              DOS/MBR boot sector</span>
</span></span><span class=line><span class=cl><span class=c1># custom_bootloader.bin: DOS/MBR boot sector</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## Check hexdump</span>
</span></span><span class=line><span class=cl>hexdump -C custom_bootloader.bin
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## Ouput</span>
</span></span><span class=line><span class=cl><span class=c1># 00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span>
</span></span><span class=line><span class=cl><span class=c1># *</span>
</span></span><span class=line><span class=cl><span class=c1># 000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|</span>
</span></span><span class=line><span class=cl><span class=c1># 00000200</span>
</span></span></code></pre></div><p>This is, as expected, a valid MBR file with no information about the partition table or the bootloader. Can we, however, use this to boot the system?</p><p>Let&rsquo;s make an attempt.</p><p>I first tried without any mbr data to see what errors I would get when it fails.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>qemu-system-x86_64
</span></span></code></pre></div><p>And, as I was expecting, it said &ldquo;no bootable device.&rdquo;</p><p><img loading=lazy src=https://i.imgur.com/wMCYSoo.png#center alt></p><p>Let&rsquo;s run the test again, but this time with the MBR file we made.</p><p><img loading=lazy src=https://i.imgur.com/DJS9nN2.png#center alt></p><p>It did not give me the error this time. That must imply that our MBR is functional. Since it lacks bootloader code, it does nothing. However, it is not returning the same previous error.</p><p>We can now add new instructions to our assembly file. However, we must keep in mind that we do not exceed the file&rsquo;s 512-byte limit. That means we&rsquo;ll have to take care of the zeros we&rsquo;re padding with. Because this is a very simple problem, there are special characters that can assist us in calculating the memory address of the beginning of the file and the current address in the file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>times</span> <span class=mi>510</span><span class=p>-(</span><span class=no>$-$$</span><span class=p>)</span> <span class=no>db</span> <span class=mi>0</span>       <span class=c1>;$ - Start addr; $$ - current addr
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>dw</span> <span class=mi>0xAA55</span>
</span></span></code></pre></div><p>We can calculate the exact number of zeros required for padding using these special characters. Let&rsquo;s compile it and put it to the test.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>nasm</span> <span class=o>-</span><span class=n>fbin</span> <span class=n>custom_bootloader</span><span class=o>.</span><span class=n>asm</span> <span class=o>-</span><span class=n>o</span> <span class=n>custom_bootloader</span><span class=o>.</span><span class=n>bin</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>qemu</span><span class=o>-</span><span class=n>system</span><span class=o>-</span><span class=n>x86_64</span> <span class=n>custom_bootloader</span><span class=o>.</span><span class=n>bin</span>
</span></span></code></pre></div><p>This produces the same results as before, and the output file size remains 512 bytes. Let&rsquo;s add some more instructions to help us write some text on the screen.</p><p>Unlike userspace and kernelspace programs, we do not have any helper functions that can take a string and automatically print it to the screen. We&rsquo;ll have to tell the BIOS to do what we want here. And the only way I&rsquo;m aware of is through <strong>interrupts</strong>. It is the same facility that operating systems and application programmes use to access BIOS functions.</p><p><a href=https://en.wikipedia.org/wiki/BIOS_interrupt_call#Interrupt_table>Here</a> is a list of common BIOS interrupts. Not all BIOS (especially older ones) support all of these interrupts. The basic idea of using interrupts is we place proper values in some specific registers, and then trigger the interrupt. The interrupt routine will then fetch the values from those registers and based on that, it&rsquo;ll perform some action.</p><p>Anyway, using the above table, I determined that we needed to use interrupt vector <code>10h</code> (or 0x10) with interrupt vector <code>03h</code> (or 0x03) in <code>AH</code> register. Consider it as invoking the 10h function with the parameter value 03h. This returns the cursor&rsquo;s current position and shape.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mov ah, 0x03;
</span></span><span class=line><span class=cl>int 10h
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>times 510-($-$$) db 0
</span></span><span class=line><span class=cl>dw 0xAA55
</span></span></code></pre></div><p>We can see that some initial bytes are written to the binary file after compiling and inspecting the hexdump&mldr;. And, thanks to <code>$</code> and <code>$$</code>, the file size remains 512 bytes.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Compiling the binary</span>
</span></span><span class=line><span class=cl>nasm -fbin custom_bootloader.asm -o custom_bootloader.bin
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## Checking hexdump</span>
</span></span><span class=line><span class=cl>hexdump -C custom_bootloader.bin
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## Output</span>
</span></span><span class=line><span class=cl><span class=c1># 00000000  b8 03 00 cd 10 00 00 00  00 00 00 00 00 00 00 00  |................|</span>
</span></span><span class=line><span class=cl><span class=c1># 00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span>
</span></span><span class=line><span class=cl><span class=c1># *</span>
</span></span><span class=line><span class=cl><span class=c1># 000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|</span>
</span></span><span class=line><span class=cl><span class=c1># 00000200</span>
</span></span></code></pre></div><p>This switches the BIOS to TTY mode, allowing me to print characters using the same interrupt <code>10h</code> but with a different value in the <code>ah</code> register.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mov ah, 0x03
</span></span><span class=line><span class=cl>int 10h
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>mov ah, 0xE
</span></span><span class=line><span class=cl>mov al, &#39;H&#39;
</span></span><span class=line><span class=cl>int 0x10
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>mov al, &#39;E&#39;
</span></span><span class=line><span class=cl>int 0x10
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>mov al, &#39;Y&#39;
</span></span><span class=line><span class=cl>int 0x10
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>times 510-($-$$) db 0
</span></span><span class=line><span class=cl>dw 0xAA55
</span></span></code></pre></div><p>When we compile and run this with qemu, we get the message &ldquo;HEY&rdquo; printed on the screen.</p><p><img loading=lazy src=https://i.imgur.com/9YAcZ03.png#center alt></p><p>Now that we know how to write characters on the screen, let&rsquo;s make a string and loop through it until the end, printing each character on the screen one by one using the same interrupt combination.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=p>;</span> <span class=n>Setup</span> <span class=n>TTY</span> <span class=n>mode</span>
</span></span><span class=line><span class=cl><span class=n>mov</span> <span class=n>ax</span><span class=p>,</span> <span class=mh>0x03</span>
</span></span><span class=line><span class=cl><span class=ne>int</span> <span class=mi>10</span><span class=n>h</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>mov</span> <span class=n>si</span><span class=p>,</span> <span class=n>msg</span>      <span class=p>;</span> <span class=n>si</span> <span class=n>register</span> <span class=n>now</span> <span class=n>points</span> <span class=n>to</span> <span class=n>msg</span>
</span></span><span class=line><span class=cl><span class=n>mov</span> <span class=n>ah</span><span class=p>,</span> <span class=mi>0</span><span class=n>Eh</span>      <span class=p>;</span> <span class=n>Use</span> <span class=n>write</span> <span class=n>function</span> <span class=n>from</span> <span class=mi>10</span><span class=n>h</span> <span class=n>interrupt</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>.</span><span class=n>loop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>lodsb</span>          <span class=p>;</span> <span class=nb>load</span> <span class=n>first</span> <span class=n>char</span> <span class=n>from</span> <span class=n>msg</span> <span class=ow>and</span> <span class=n>point</span> <span class=n>to</span> <span class=n>next</span> <span class=n>char</span>
</span></span><span class=line><span class=cl>    <span class=ow>or</span> <span class=n>al</span><span class=p>,</span> <span class=n>al</span>      <span class=p>;</span> <span class=n>Check</span> <span class=k>if</span> <span class=n>end</span> <span class=n>of</span> <span class=n>string</span>
</span></span><span class=line><span class=cl>    <span class=n>jz</span> <span class=n>halt</span>        <span class=p>;</span> <span class=k>if</span> <span class=n>end</span> <span class=n>of</span> <span class=n>string</span><span class=p>,</span> <span class=n>jump</span> <span class=n>to</span> <span class=n>halt</span>
</span></span><span class=line><span class=cl>    <span class=ne>int</span> <span class=mi>10</span><span class=n>h</span>        <span class=p>;</span> <span class=k>else</span><span class=p>,</span> <span class=nb>print</span> <span class=n>char</span> <span class=n>via</span> <span class=n>interrupt</span>
</span></span><span class=line><span class=cl>    <span class=n>jmp</span> <span class=o>.</span><span class=n>loop</span>      <span class=p>;</span> <span class=n>loop</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>halt</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>msg</span><span class=p>:</span> <span class=n>db</span> <span class=s2>&#34;Hack the world&#34;</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>times</span> <span class=mi>510</span><span class=o>-</span><span class=p>(</span><span class=o>$-$$</span><span class=p>)</span> <span class=n>db</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>dw</span> <span class=mh>0xAA55</span>
</span></span></code></pre></div><p>Unfortunately, testing the above code does not produce the desired results, but instead produces some garbage values.</p><p><img loading=lazy src=https://i.imgur.com/LUbZu5D.png#center alt></p><p>Further investigation revealed that our bootloader in memory is not properly aligned. This led me down another rabbit hole, this time about how the contents of the computer&rsquo;s physical memory look when the BIOS jumps to my bootloader code. Here is a <a href=https://wiki.osdev.org/Memory_Map_(x86)>dedicated page</a> on the same topic here which covers a lot of details about it.</p><p>For us, we need to add a few more instructions to our code to properly align it. Finally, our code will look like this.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>bits</span> <span class=mi>16</span>      <span class=p>;</span> <span class=n>BIOS</span> <span class=n>works</span> <span class=ow>in</span> <span class=mi>16</span> <span class=n>bit</span> <span class=n>mode</span>
</span></span><span class=line><span class=cl><span class=n>org</span> <span class=mh>0x7c00</span>   <span class=p>;</span> <span class=n>MBR</span> <span class=n>is</span> <span class=n>loaded</span> <span class=n>at</span> <span class=mh>0x7c00</span> <span class=n>memory</span> <span class=n>location</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>mov</span> <span class=n>ax</span><span class=p>,</span> <span class=mh>0x03</span>
</span></span><span class=line><span class=cl><span class=ne>int</span> <span class=mi>10</span><span class=n>h</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>mov</span> <span class=n>si</span><span class=p>,</span> <span class=n>msg</span>
</span></span><span class=line><span class=cl><span class=n>mov</span> <span class=n>ah</span><span class=p>,</span> <span class=mi>0</span><span class=n>Eh</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>.</span><span class=n>loop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>lodsb</span>
</span></span><span class=line><span class=cl>    <span class=ow>or</span> <span class=n>al</span><span class=p>,</span> <span class=n>al</span>
</span></span><span class=line><span class=cl>    <span class=n>jz</span> <span class=n>halt</span>
</span></span><span class=line><span class=cl>    <span class=ne>int</span> <span class=mi>10</span><span class=n>h</span>
</span></span><span class=line><span class=cl>    <span class=n>jmp</span> <span class=o>.</span><span class=n>loop</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>halt</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=n>cli</span>     <span class=p>;</span> <span class=n>disable</span> <span class=n>further</span> <span class=n>interrupts</span>
</span></span><span class=line><span class=cl><span class=n>hlt</span>     <span class=p>;</span> <span class=n>halt</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>msg</span><span class=p>:</span> <span class=n>db</span> <span class=s2>&#34;Hack the world!!&#34;</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>times</span> <span class=mi>510</span><span class=o>-</span><span class=p>(</span><span class=o>$-$$</span><span class=p>)</span> <span class=n>db</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>dw</span> <span class=mh>0xAA55</span>
</span></span></code></pre></div><p>This time we get the desired result after compiling and testing the above.
<img loading=lazy src=https://i.imgur.com/6eV40TA.png#center alt></p><p>We successfully created a bootloader that prints some message on the screen.</p><h2 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h2><p>We know that a MBR sector is comprised of 3 parts:</p><ul><li>bootloader (446 bytes)</li><li>partition table (64 bytes)</li><li>magic number (2 bytes)</li></ul><p>And each component can be extracted separately and treated as a regular binary file. This means that we can create backups of only partition tables if necessary. Alternatively, we can <strong>replace the bootloader code</strong> with another code without affecting the partition table.(<em>Obviously for fun; like a friendly joke, nothing malicious</em>) 😈 😈</p><p><img loading=lazy src=https://imgs.xkcd.com/comics/fight.png#center alt></p><p>We know our above &ldquo;Hack the World!!&rdquo; code does not use all 510 bytes, so why not shrink it a little to fit in 446 bytes? This way we can protect the original partition table.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>bits</span> <span class=mi>16</span>      
</span></span><span class=line><span class=cl><span class=no>org</span> <span class=mi>0x7c00</span>   
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=no>mov</span> <span class=no>ax</span><span class=p>,</span> <span class=mi>0x03</span>
</span></span><span class=line><span class=cl><span class=nf>int</span> <span class=mi>10</span><span class=no>h</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=no>si</span><span class=p>,</span> <span class=no>msg</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=no>ah</span><span class=p>,</span> <span class=mi>0</span><span class=no>Eh</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>.loop:</span>
</span></span><span class=line><span class=cl>    <span class=nf>lodsb</span>
</span></span><span class=line><span class=cl>    <span class=nf>or</span> <span class=no>al</span><span class=p>,</span> <span class=no>al</span>
</span></span><span class=line><span class=cl>    <span class=nf>jz</span> <span class=no>halt</span>
</span></span><span class=line><span class=cl>    <span class=nf>int</span> <span class=mi>10</span><span class=no>h</span>
</span></span><span class=line><span class=cl>    <span class=nf>jmp</span> <span class=no>.loop</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>halt:</span>
</span></span><span class=line><span class=cl><span class=nf>cli</span>     
</span></span><span class=line><span class=cl><span class=no>hlt</span>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=no>msg</span><span class=p>:</span> <span class=no>db</span> <span class=err>&#34;</span><span class=no>Hack</span> <span class=no>the</span> <span class=no>world</span><span class=p>!!</span><span class=err>&#34;</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>times</span> <span class=mi>446</span><span class=p>-(</span><span class=no>$-$$</span><span class=p>)</span> <span class=no>db</span> <span class=mi>0</span>         <span class=c1>; Just change 510 to 446 :)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>dw</span> <span class=mi>0xAA55</span>
</span></span></code></pre></div><p>This will generate the raw data file containing the bootloader program, which we can quickly test in a virtual machine.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=no>Vagrant</span><span class=o>.</span><span class=n>configure</span><span class=p>(</span><span class=s2>&#34;2&#34;</span><span class=p>)</span> <span class=k>do</span> <span class=o>|</span><span class=n>config</span><span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=n>config</span><span class=o>.</span><span class=n>vm</span><span class=o>.</span><span class=n>box</span> <span class=o>=</span> <span class=s2>&#34;archlinux/archlinux&#34;</span>
</span></span><span class=line><span class=cl>  <span class=n>config</span><span class=o>.</span><span class=n>vm</span><span class=o>.</span><span class=n>box_check_update</span> <span class=o>=</span> <span class=kp>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>config</span><span class=o>.</span><span class=n>vm</span><span class=o>.</span><span class=n>provider</span> <span class=s2>&#34;virtualbox&#34;</span> <span class=k>do</span> <span class=o>|</span><span class=n>vb</span><span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=n>vb</span><span class=o>.</span><span class=n>gui</span> <span class=o>=</span> <span class=kp>true</span>
</span></span><span class=line><span class=cl>    <span class=n>vb</span><span class=o>.</span><span class=n>memory</span> <span class=o>=</span> <span class=s2>&#34;512&#34;</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>config</span><span class=o>.</span><span class=n>vm</span><span class=o>.</span><span class=n>provision</span> <span class=s2>&#34;shell&#34;</span><span class=p>,</span> <span class=ss>inline</span><span class=p>:</span> <span class=s>&lt;&lt;-SHELL
</span></span></span><span class=line><span class=cl><span class=s></span>    <span class=c1># Backup the original bootloader</span>
</span></span><span class=line><span class=cl>    <span class=n>dd</span> <span class=p>\</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=o>=</span><span class=sr>/dev/s</span><span class=n>da</span> <span class=p>\</span>
</span></span><span class=line><span class=cl>      <span class=n>of</span><span class=o>=</span><span class=sr>/vagrant/</span><span class=n>backedup_bootloader</span><span class=o>.</span><span class=n>bin</span> <span class=p>\</span>
</span></span><span class=line><span class=cl>      <span class=n>bs</span><span class=o>=</span><span class=mi>1</span> <span class=p>\</span>
</span></span><span class=line><span class=cl>      <span class=n>count</span><span class=o>=</span><span class=mi>446</span>
</span></span><span class=line><span class=cl>	 
</span></span><span class=line><span class=cl>    <span class=c1># Copy the fun bootloader to first 446 bytes of sda</span>
</span></span><span class=line><span class=cl>    <span class=n>dd</span> <span class=p>\</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=o>=</span><span class=sr>/vagrant/</span><span class=n>custom_bootloader</span><span class=o>.</span><span class=n>bin</span> <span class=p>\</span>
</span></span><span class=line><span class=cl>      <span class=n>of</span><span class=o>=</span><span class=sr>/dev/s</span><span class=n>da</span> <span class=p>\</span>
</span></span><span class=line><span class=cl>      <span class=n>bs</span><span class=o>=</span><span class=mi>1</span> <span class=p>\</span>
</span></span><span class=line><span class=cl>      <span class=n>count</span><span class=o>=</span><span class=mi>446</span>
</span></span><span class=line><span class=cl>	 	
</span></span><span class=line><span class=cl>    <span class=c1># Reboot the system to see the effect</span>
</span></span><span class=line><span class=cl>    <span class=n>reboot</span>
</span></span><span class=line><span class=cl>  <span class=no>SHELL</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>The <a href=https://www.vagrantup.com/intro><code>Vagrantfile</code></a> above will launch a quick test VM. We just need to sit back and relax.</p><p><img loading=lazy src=https://media.giphy.com/media/8ynPshGnD8WnS/giphy.gif#center alt></p><p>After successful bootup and reboot, It displayed the expected message.</p><p><img loading=lazy src=https://i.imgur.com/6eV40TA.png#center alt></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://en.wikipedia.org/wiki/BIOS>https://en.wikipedia.org/wiki/BIOS</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://www.man7.org/linux/man-pages/man1/dd.1.html>https://www.man7.org/linux/man-pages/man1/dd.1.html</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href="https://forum.osdev.org/viewtopic.php?f=2&amp;t=18763">https://forum.osdev.org/viewtopic.php?f=2&amp;t=18763</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ayedaemon.github.io/tags/linux/>Linux</a></li><li><a href=https://ayedaemon.github.io/tags/mbr/>mbr</a></li><li><a href=https://ayedaemon.github.io/tags/bootloader/>bootloader</a></li></ul><nav class=paginav><a class=prev href=https://ayedaemon.github.io/post/2022/12/recording_system_events_with_auditd/><span class=title>« Next</span><br><span>Recording system events with auditd</span>
</a><a class=next href=https://ayedaemon.github.io/post/2022/09/intro-to-re/><span class=title>Prev »</span><br><span>Intro to Re: C : part-1</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://ayedaemon.github.io/>Connected</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>