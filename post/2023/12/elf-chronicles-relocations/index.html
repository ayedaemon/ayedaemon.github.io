<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Elf Chronicles: Relocations (6/?) | Connected</title>
<meta name=keywords content="C,ELF,RE"><meta name=description content="Exploring general concept of ELF relocations"><meta name=author content="ayedaemon"><link rel=canonical href=https://ayedaemon.github.io/post/2023/12/elf-chronicles-relocations/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://ayedaemon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ayedaemon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ayedaemon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ayedaemon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ayedaemon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Elf Chronicles: Relocations (6/?)"><meta property="og:description" content="Exploring general concept of ELF relocations"><meta property="og:type" content="article"><meta property="og:url" content="https://ayedaemon.github.io/post/2023/12/elf-chronicles-relocations/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-12-08T14:17:56+05:30"><meta property="article:modified_time" content="2024-04-05T21:58:47+05:30"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2024/04/elf-chronicles-plt-got/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/10/elf-chronicles-symbol-tables/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/10/elf-chronicles-string-tables/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/10/elf-chronicles-program-headers/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/10/elf-chronicles-section-headers/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Elf Chronicles: Relocations (6/?)"><meta name=twitter:description content="Exploring general concept of ELF relocations"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ayedaemon.github.io/post/"},{"@type":"ListItem","position":2,"name":"Elf Chronicles: Relocations (6/?)","item":"https://ayedaemon.github.io/post/2023/12/elf-chronicles-relocations/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Elf Chronicles: Relocations (6/?)","name":"Elf Chronicles: Relocations (6\/?)","description":"Exploring general concept of ELF relocations","keywords":["C","ELF","RE"],"articleBody":"In previous article about Symbol Tables, we talked about the below diagram ….\n┌────────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ │ │ │ │ libarithmatic.c │ │ libarithmatic.h ├───────► │ main.c │ │ │ │ │ │ │ └─────────┬──────────┘ └─────────────────┘ └────────┬────────┘ │ │ │ │ │ /* Compile + assemble */ │ /* Compile + assemble */ │ │ │ │ ▼ ▼ ┌─────────────────────┐ ┌────────────────────┐ │ │ │ │ │ libarithmatic.o │ │ main.o │ │ │ │ │ └─────────┬───────────┘ └──────────┬─────────┘ │ │ │ │ │ │ │ │ │ /* Linking Magic */ │ └───────────────────────────────────┬──────────────────────────────────────┘ │ │ │ │ │ │ ▼ ┌────────────────┐ │ │ │ calc │ │ │ └────────────────┘ …and how the compiler was unaware of the final addresses for many symbols. When things get a bit confusing for the compiler, it takes the easy route by putting zeros in the addresses and creating relocation entries for the linker/loader to sort out.\nThe linker combines all the .o files, causing changes to the positions of different parts. For example, the main function in main.o and addFunc in libarithmatic.o both start off at position 0x0. But when you link these files, this setup causes issues, so some tweaks are needed.\nIn this situation, the compiler and assembler team up to produce the .o file, but they don’t know for sure where each part will end up in the eventual calc binary. So, they play it safe by leaving these spots empty and make notes in the relocations section. This tells the linker that these positions need some adjustments later on.\nRelocations According to ELF specification (version 1.2)\nRelocation is the process of connecting symbolic references with symbolic definitions.\nRelocation is a straightforward concept in coding. When you’re compiling code, the compiler doesn’t always know the exact addresses for everything in the program. ELF relocations become important when the addresses of symbols are uncertain during compilation, often because the final addresses are determined by the linker or loader at a later stage. It’s similar to arranging pieces in a puzzle without having all the details upfront.\n## Before linking - main.o ❯ objdump -M intel -D -j .text main.o | grep call 26: e8 00 00 00 00 call 2b 49: e8 00 00 00 00 call 4e 86: e8 00 00 00 00 call 8b a3: e8 00 00 00 00 call a8 c0: e8 00 00 00 00 call c5 dd: e8 00 00 00 00 call e2 f5: e8 00 00 00 00 call fa 123: e8 00 00 00 00 call 128 13c: e8 00 00 00 00 call 141 ## After linking - calc ❯ objdump -M intel -D -j .text calc | grep call 1138: e8 63 ff ff ff call 10a0 \u003c_start+0x30\u003e 118f: e8 bc fe ff ff call 1050 11b2: e8 a9 fe ff ff call 1060 \u003c__isoc99_scanf@plt\u003e 11ef: e8 b8 00 00 00 call 12ac 120c: e8 b5 00 00 00 call 12c6 1229: e8 b2 00 00 00 call 12e0 1246: e8 af 00 00 00 call 12fa 125e: e8 cd fd ff ff call 1030 128c: e8 bf fd ff ff call 1050 12a5: e8 96 fd ff ff call 1040 \u003c__stack_chk_fail@plt\u003e Now, there are three essential elements needed for relocation to take place:\nThe spot where the adjustment needs to be made. The symbol that’s part of the adjustment. An algorithm specifying how to calculate and apply the necessary fix. The compiler stores all this information in a special section identified by type - either REL (0x9) or RELA (0x4).\nREL is used for basic relocation entries. RELA is essentially the same as REL, but with an extra addend value. This doesn’t significantly impact the concept, though. You can easily identify these sections using readelf;…\n❯ readelf --section-headers --wide main.o There are 14 section headers, starting at offset 0x5a8: Section Headers: [Nr] Name Type Address Off Size ES Flg Lk Inf Al [ 0] NULL 0000000000000000 000000 000000 00 0 0 0 [ 1] .text PROGBITS 0000000000000000 000040 000143 00 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 0003e0 000138 18 I 11 1 8 [ 3] .data PROGBITS 0000000000000000 000183 000000 00 WA 0 0 1 [ 4] .bss NOBITS 0000000000000000 000183 000000 00 WA 0 0 1 [ 5] .rodata PROGBITS 0000000000000000 000183 000041 00 A 0 0 1 [ 6] .comment PROGBITS 0000000000000000 0001c4 00001c 01 MS 0 0 1 [ 7] .note.GNU-stack PROGBITS 0000000000000000 0001e0 000000 00 0 0 1 [ 8] .note.gnu.property NOTE 0000000000000000 0001e0 000030 00 A 0 0 8 [ 9] .eh_frame PROGBITS 0000000000000000 000210 000038 00 A 0 0 8 [10] .rela.eh_frame RELA 0000000000000000 000518 000018 18 I 11 9 8 [11] .symtab SYMTAB 0000000000000000 000248 000138 18 12 4 8 [12] .strtab STRTAB 0000000000000000 000380 000059 00 0 0 1 [13] .shstrtab STRTAB 0000000000000000 000530 000074 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), D (mbind), l (large), p (processor specific) My parser gives me the same results… (with different looks)\n[ 00 ] Section Name: Type: 0x0 Flags: 0x0 Addr: 0x0 Offset: 0x0 Size: 0 Link: 0 Info: 0x0 Addralign: 0x0 Entsize: 0 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 01 ] Section Name: .text Type: 0x1 Flags: 0x6 Addr: 0x0 Offset: 0x40 Size: 323 Link: 0 Info: 0x0 Addralign: 0x1 Entsize: 0 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 02 ] Section Name: .rela.text Type: 0x4 Flags: 0x40 Addr: 0x0 Offset: 0x3e0 Size: 312 Link: 11 Info: 0x1 Addralign: 0x8 Entsize: 24 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 03 ] Section Name: .data Type: 0x1 Flags: 0x3 Addr: 0x0 Offset: 0x183 Size: 0 Link: 0 Info: 0x0 Addralign: 0x1 Entsize: 0 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 04 ] Section Name: .bss Type: 0x8 Flags: 0x3 Addr: 0x0 Offset: 0x183 Size: 0 Link: 0 Info: 0x0 Addralign: 0x1 Entsize: 0 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 05 ] Section Name: .rodata Type: 0x1 Flags: 0x2 Addr: 0x0 Offset: 0x183 Size: 65 Link: 0 Info: 0x0 Addralign: 0x1 Entsize: 0 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 06 ] Section Name: .comment Type: 0x1 Flags: 0x30 Addr: 0x0 Offset: 0x1c4 Size: 28 Link: 0 Info: 0x0 Addralign: 0x1 Entsize: 1 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 07 ] Section Name: .note.GNU-stack Type: 0x1 Flags: 0x0 Addr: 0x0 Offset: 0x1e0 Size: 0 Link: 0 Info: 0x0 Addralign: 0x1 Entsize: 0 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 08 ] Section Name: .note.gnu.property Type: 0x7 Flags: 0x2 Addr: 0x0 Offset: 0x1e0 Size: 48 Link: 0 Info: 0x0 Addralign: 0x8 Entsize: 0 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 09 ] Section Name: .eh_frame Type: 0x1 Flags: 0x2 Addr: 0x0 Offset: 0x210 Size: 56 Link: 0 Info: 0x0 Addralign: 0x8 Entsize: 0 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 10 ] Section Name: .rela.eh_frame Type: 0x4 Flags: 0x40 Addr: 0x0 Offset: 0x518 Size: 24 Link: 11 Info: 0x9 Addralign: 0x8 Entsize: 24 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 11 ] Section Name: .symtab Type: 0x2 Flags: 0x0 Addr: 0x0 Offset: 0x248 Size: 312 Link: 12 Info: 0x4 Addralign: 0x8 Entsize: 24 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 12 ] Section Name: .strtab Type: 0x3 Flags: 0x0 Addr: 0x0 Offset: 0x380 Size: 89 Link: 0 Info: 0x0 Addralign: 0x1 Entsize: 0 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 13 ] Section Name: .shstrtab Type: 0x3 Flags: 0x0 Addr: 0x0 Offset: 0x530 Size: 116 Link: 0 Info: 0x0 Addralign: 0x1 Entsize: 0 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- In any case, identifying the relocation sections is straightforward – REL (0x9) or RELA (0x4).\n# From readelf [Nr] Name Type Address Off Size ES Flg Lk Inf Al [ 2] .rela.text RELA 0000000000000000 0003e0 000138 18 I 11 1 8 [10] .rela.eh_frame RELA 0000000000000000 000518 000018 18 I 11 9 8 # From my parser [ 02 ] Section Name: .rela.text Type: 0x4 Flags: 0x40 Addr: 0x0 Offset: 0x3e0 Size: 312 Link: 11 Info: 0x1 Addralign: 0x8 Entsize: 24 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 10 ] Section Name: .rela.eh_frame Type: 0x4 Flags: 0x40 Addr: 0x0 Offset: 0x518 Size: 24 Link: 11 Info: 0x9 Addralign: 0x8 Entsize: 24 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- (Note: To keep things clear in this article and to maintain simplicity, we’re going to ignore the .rela.eh_frame. We can dive into that particular aspect another time.)\nWe can use the details shared earlier to pinpoint the real data of the relocation section. This means we’ll be finding the section data by using the section header entry – a process we’ve gone through multiple times before.\n[ 02 ] Section Name: .rela.text Type: 0x4 Flags: 0x40 Addr: 0x0 ┌─────────Offset: 0x3e0 │ ┌──Size: 312 │ │ Link: 11 │ │ Info: 0x1 │ │ Addralign: 0x8 │ │ Entsize: 24 │ │ │ │ │ │ │ │ │ ▼ ▼ ▼ ❯ xxd -s 0x3e0 -l 0x138 -c 0x18 main.o | nl -v0 - 0 000003e0: 1a00 0000 0000 0000 0200 0000 0300 0000 fcff ffff ffff ffff ........................ 1 000003f8: 2700 0000 0000 0000 0400 0000 0500 0000 fcff ffff ffff ffff '....................... 2 00000410: 3d00 0000 0000 0000 0200 0000 0300 0000 1500 0000 0000 0000 =....................... 3 00000428: 4a00 0000 0000 0000 0400 0000 0600 0000 fcff ffff ffff ffff J....................... 4 00000440: 8700 0000 0000 0000 0400 0000 0700 0000 fcff ffff ffff ffff ........................ 5 00000458: a400 0000 0000 0000 0400 0000 0800 0000 fcff ffff ffff ffff ........................ 6 00000470: c100 0000 0000 0000 0400 0000 0900 0000 fcff ffff ffff ffff ........................ 7 00000488: de00 0000 0000 0000 0400 0000 0a00 0000 fcff ffff ffff ffff ........................ 8 000004a0: ee00 0000 0000 0000 0200 0000 0300 0000 1e00 0000 0000 0000 ........................ 9 000004b8: f600 0000 0000 0000 0400 0000 0b00 0000 fcff ffff ffff ffff ........................ 10 000004d0: 1701 0000 0000 0000 0200 0000 0300 0000 2f00 0000 0000 0000 ................/....... 11 000004e8: 2401 0000 0000 0000 0400 0000 0500 0000 fcff ffff ffff ffff $....................... 12 00000500: 3d01 0000 0000 0000 0400 0000 0c00 0000 fcff ffff ffff ffff =....................... Linux kernel has some specific structures to define REL and RELA entries….\n/* https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/elf.h#L171 */ typedef struct elf64_rel { Elf64_Addr r_offset;\t/* Location at which to apply the action */ Elf64_Xword r_info;\t/* index and type of relocation */ } Elf64_Rel; /* https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/elf.h#L182 */ typedef struct elf64_rela { Elf64_Addr r_offset;\t/* Location at which to apply the action */ Elf64_Xword r_info;\t/* index and type of relocation */ Elf64_Sxword r_addend;\t/* Constant addend used to compute value */ } Elf64_Rela; /* https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/elf.h#L163 */ #define ELF64_R_SYM(i)\t((i) \u003e\u003e 32) #define ELF64_R_TYPE(i)\t((i) \u0026 0xffffffff) After parsing this section’s data, I got following results.\n[ 02 ] Section Name: .rela.text Type: 0x4 Flags: 0x40 Addr: 0x0 Offset: 0x3e0 Size: 312 Link: 11 Info: 0x1 Addralign: 0x8 Entsize: 24 [ 0 ] Offset: 0x1a Info: 0x000300000002 (Sym: 0x3 | Type: 0x2) Addend: -4 [ 1 ] Offset: 0x27 Info: 0x000500000004 (Sym: 0x5 | Type: 0x4) Addend: -4 [ 2 ] Offset: 0x3d Info: 0x000300000002 (Sym: 0x3 | Type: 0x2) Addend: 21 [ 3 ] Offset: 0x4a Info: 0x000600000004 (Sym: 0x6 | Type: 0x4) Addend: -4 [ 4 ] Offset: 0x87 Info: 0x000700000004 (Sym: 0x7 | Type: 0x4) Addend: -4 [ 5 ] Offset: 0xa4 Info: 0x000800000004 (Sym: 0x8 | Type: 0x4) Addend: -4 [ 6 ] Offset: 0xc1 Info: 0x000900000004 (Sym: 0x9 | Type: 0x4) Addend: -4 [ 7 ] Offset: 0xde Info: 0x000a00000004 (Sym: 0xa | Type: 0x4) Addend: -4 [ 8 ] Offset: 0xee Info: 0x000300000002 (Sym: 0x3 | Type: 0x2) Addend: 30 [ 9 ] Offset: 0xf6 Info: 0x000b00000004 (Sym: 0xb | Type: 0x4) Addend: -4 [ 10 ] Offset: 0x117 Info: 0x000300000002 (Sym: 0x3 | Type: 0x2) Addend: 47 [ 11 ] Offset: 0x124 Info: 0x000500000004 (Sym: 0x5 | Type: 0x4) Addend: -4 [ 12 ] Offset: 0x13d Info: 0x000c00000004 (Sym: 0xc | Type: 0x4) Addend: -4 Let’s pause for a moment to grasp the significance of each member in this structure and how it aids the linker in the relocation process.\n(👇 Shamelessly stolen from man 5 elf 👇)\nr_offset This member gives the location at which to apply the relocation.\nFor a relocatable file, the value is the byte offset from the beginning of the section where relocation is to be applied. For an executable file or shared object, the value is the virtual address of the storage unit affected by the relocation. r_info This member gives both the symbol table index with respect to which the relocation must be made and the type of relocation to apply. (Linux kernel provides a macro to filter these values out from it - ELF64_R_SYM and ELF64_R_TYPE)\nr_addend This member specifies a constant addend used to compute the value to be stored into the relocatable field.\nAnalysis Now armed with the theoretical knowledge, let’s delve into how the linker utilizes this information to perform a relocation. We’ll begin by examining the details of the first relocation entry.\n[ 0 ] Offset: 0x1a Info: 0x000300000002 (Sym: 0x3 | Type: 0x2) Addend: -4 Now there are 2 things I want you to think about before we even start with the relocation process…\nWe know r_offset holds the offset from beginning of the section where relocation is to be applied. Which section is that here?? And ELF64_R_SYM from r_info stores the index in symbol table. But we can obviously have more than 1 symbol table, so Which symbol table we are talking about here?? Answer » To identify that, you just have to check sh_info and sh_link members from the section header entry.\nIn our case, the associated symbol table and the section where relocations will apply can be viewed like this:-\n┌────────────────────────────────────┐ │ [ 11 ] Section Name: .symtab │◄───────┐ │ Type: 0x2 │ │ │ Flags: 0x0 │ │ │ Addr: 0x0 │ │ │ Offset: 0x248 │ │ │ Size: 312 │ │ │ Link: 12 │ │ │ Info: 0x4 │ │ │ Addralign: 0x8 │ │ │ Entsize: 24 │ │ │ │ │ └────────────────────────────────────┘ │ │ /* all the symbols associated │ are in section 11 */ │ │ │ ┌────────────────────────────────────┐ │ │ [ 02 ] Section Name: .rela.text │ │ │ Type: 0x4 │ │ │ Flags: 0x40 │ │ │ Addr: 0x0 │ │ │ Offset: 0x3e0 │ │ │ Size: 312 │ │ │ Link: 11 ─────────────────┼────────┘ ┌───────┼───────── Info: 0x1 │ │ │ Addralign: 0x8 │ │ │ Entsize: 24 │ │ │ │ │ └────────────────────────────────────┘ │ │ │ /* relocations apply to section with index 1 */ │ │ ┌───────────────────────────────────┐ └──────►│ [ 01 ] Section Name: .text │ │ Type: 0x1 │ │ Flags: 0x6 │ │ Addr: 0x0 │ │ Offset: 0x40 │ │ Size: 323 │ │ Link: 0 │ │ Info: 0x0 │ │ Addralign: 0x1 │ │ Entsize: 0 │ │ │ └───────────────────────────────────┘ Traditionally, the chosen naming scheme for the relocation section indicates the section where relocations are intended to be applied. For example, if relocations are to be applied on .text section, then the relocation entries will be under .rela.text or .rel.text. However, it’s crucial to note that this is merely a tradition and not a strict requirement.\nIn the wisdom of ancient gods, it is advised not to depend solely on names.\nNow that you know where to apply relocation and where to look for symbols… let’s look at the relocation entry we started with\n[ 0 ] Offset: 0x1a Info: 0x000300000002 (Sym: 0x3 | Type: 0x2) Addend: -4 We can now understand that:\nThe relocation is to be applied at offset 0x1a in .text section. The symbol associated with this relocation is 3rd symbol in .symtab section. So, if you want to see the big picture,\n┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐ │ [ 11 ] Section Name: .symtab Type: 0x2 Flags: 0x0 Addr: 0x0 Offset: 0x248 Size: 312 Link: 12 Info: 0x4 Addralign: 0x8 │ │ [ 0 ] Name: Info: 0x00 (Bind: 0x0 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 │ │ [ 1 ] Name: main.c Info: 0x04 (Bind: 0x0 | Type: 0x4) Other: 0x0 Shndx: 0xfff1 Value: 0x000000000000 Size: 0x0 │ │ [ 2 ] Name: Info: 0x03 (Bind: 0x0 | Type: 0x3) Other: 0x0 Shndx: 0x1 Value: 0x000000000000 Size: 0x0 │ ┌─────┼────► [ 3 ] Name: Info: 0x03 (Bind: 0x0 | Type: 0x3) Other: 0x0 Shndx: 0x5 Value: 0x000000000000 Size: 0x0 │ │ │ [ 4 ] Name: main Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0x1 Value: 0x000000000000 Size: 0x143 │ │ │ [ 5 ] Name: printf Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 │ │ │ [ 6 ] Name: __isoc99_scanf Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 │ │ │ [ 7 ] Name: addFunc Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 │ │ │ [ 8 ] Name: subFunc Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 │ │ │ [ 9 ] Name: mulFunc Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 │ │ │ [ 10 ] Name: divFunc Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 │ │ │ [ 11 ] Name: puts Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 │ │ │ [ 12 ] Name: __stack_chk_fail Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 │ │ │ │ │ └────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘ │ └──────────────────────────────────────────────────────────┐ │ │ │ │ │ [ 0 ] Offset: 0x1a Info: 0x000300000002 (Sym: 0x3 | Type: 0x2) Addend: -4 │ │ │ │ └─────────────────────────┐ │ │ ┌────────────────────────────────┼───────────────────────────────────────────────────┐ │ │ │ │ Disassembly of section .text:│ │ │ │ │ │ 0000000000000000 : │ │ │ 0: 55 │ push rbp │ │ 1: 48 89 e5 │ mov rbp,rsp │ │ 4: 48 83 ec 20 │ sub rsp,0x20 │ │ 8: 64 48 8b 04 25 28 00 │ mov rax,QWORD PTR fs:0x28 │ │ f: 00 00 ┌──┘ │ │ 11: 48 89 45 f8 ▼ mov QWORD PTR [rbp-0x8],rax │ │ 15: 31 c0 ┌───────────┐ xor eax,eax │ │ 17: 48 8d 05│00 00 00 00│ lea rax,[rip+0x0] # 1e │ │ 1e: 48 89 c7└───────────┘ mov rdi,rax │ │ 21: b8 00 00 00 00 mov eax,0x0 │ │ 26: e8 00 00 00 00 call 2b │ │ 2b: 48 8d 4d f0 lea rcx,[rbp-0x10] │ │ │ └────────────────────────────────────────────────────────────────────────────────────┘ I get that things might look like a mess, a real puzzle at first. But trust me, with a bit of experience, you’ll start to figure it out.\nNow that we’ve uncovered the secret behind the symbol and pinpointed where the relocation is going to happen, it’s time to figure out the algorithm we’re going to use for relocation. Just peek into the Type part of r_info. In our case, it’s holding the number 0x2.\nWith a quick look at the gcc source code, I can tell you that this algorithm is R_X86_64_PC32… And another brief look at the source code of mold (a modern linker) helps me fully comprehend the algorithm…\n/* https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/elf.h;hb=2bd00179885928fd95fcabfafc50e7b5c6e660d2#l3579 */ #define R_X86_64_PC32 2 /* PC relative 32 bit signed */ /* https://github.com/rui314/mold/blob/main/elf/arch-x86-64.cc#L433C1-L436C13 */ case R_X86_64_PC32: case R_X86_64_PLT32: write32s(S + A - P); break; Alright, so the magical spell for this relocation is S + A - P…. Now, let’s break it down\nS = value of symbol A = Addend (r_addend) P = place of relocation (r_offset is used to calculate this) The addend (A) is simply -4. Why -4?? I don’t know 🤷 ¯\\_(ツ)_/¯ (If you happen to know it, please share your wisdom with this stuppid child… pretty please! 🥺👉👈)\nAnd the place of relocation (P) should be 0x1a… right? WRONG!!… the place of relocation will be location of .text section + 0x1a. Linker will know where .text will be after the merge process, so it’ll be easy for the linker to get the exact location.\nFinally, value of symbol (S), this one is a bit tricky here… You need to take a look at the symbol table for this\n[ 11 ] Section Name: .symtab Type: 0x2 Flags: 0x0 Addr: 0x0 Offset: 0x248 Size: 312 Link: 12 Info: 0x4 Addralign: 0x8 Entsize: 24 [ 0 ] Name: Info: 0x00 (Bind: 0x0 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 1 ] Name: main.c Info: 0x04 (Bind: 0x0 | Type: 0x4) Other: 0x0 Shndx: 0xfff1 Value: 0x000000000000 Size: 0x0 [ 2 ] Name: Info: 0x03 (Bind: 0x0 | Type: 0x3) Other: 0x0 Shndx: 0x1 Value: 0x000000000000 Size: 0x0 [ 3 ] Name: Info: 0x03 (Bind: 0x0 | Type: 0x3) Other: 0x0 Shndx: 0x5 Value: 0x000000000000 Size: 0x0 [ 4 ] Name: main Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0x1 Value: 0x000000000000 Size: 0x143 [ 5 ] Name: printf Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 6 ] Name: __isoc99_scanf Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 7 ] Name: addFunc Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 8 ] Name: subFunc Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 9 ] Name: mulFunc Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 10 ] Name: divFunc Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 11 ] Name: puts Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 12 ] Name: __stack_chk_fail Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 Just focus on the symbol for our case… index 3.\n[ 3 ] Name: /* No name for symbol */ Info: 0x03 (Bind: 0x0 | Type: 0x3) /* Bind: STB_LOCAL | Type: STT_SECTION */ Other: 0x0 /* default visibility */ Shndx: 0x5 /* section 5; .rodata in our case */ Value: 0x000000000000 /* no value; I wonder what could be the value for \"STT_SECTION\" type symbol */ Size: 0x0 /* Unknown size */ Putting all the pieces together, it’s crystal clear now that this symbol is casually pointing towards .rodata section. Picture this section as a treasure trove of read-only data. An example? Think of it like a collection of strings that printf and its buddies use to sprinkle some magic onto your screen. It’s like the VIP lounge for data that’s there to be seen but not messed with.\nlooking back at our relocation entry, we can now understand it better\n[ 0 ] Offset: 0x1a Info: 0x000300000002 (Sym: 0x3 | Type: 0x2) Addend: -4 Apply relocation at offset 0x1a in .text section. Use symbol 3 for relocation… that points to .rodata section. Relocation algorithm will be R_X86_64_PC32 (S + A - P) There are many tools like readelf and objdump, that can show you relocation entries with all these things simplified.\n❯ readelf --relocs --wide calc/main.o Relocation section '.rela.text' at offset 0x3e0 contains 13 entries: Offset Info Type Symbol's Value Symbol's Name + Addend 000000000000001a 0000000300000002 R_X86_64_PC32 0000000000000000 .rodata - 4 0000000000000027 0000000500000004 R_X86_64_PLT32 0000000000000000 printf - 4 000000000000003d 0000000300000002 R_X86_64_PC32 0000000000000000 .rodata + 15 000000000000004a 0000000600000004 R_X86_64_PLT32 0000000000000000 __isoc99_scanf - 4 0000000000000087 0000000700000004 R_X86_64_PLT32 0000000000000000 addFunc - 4 00000000000000a4 0000000800000004 R_X86_64_PLT32 0000000000000000 subFunc - 4 00000000000000c1 0000000900000004 R_X86_64_PLT32 0000000000000000 mulFunc - 4 00000000000000de 0000000a00000004 R_X86_64_PLT32 0000000000000000 divFunc - 4 00000000000000ee 0000000300000002 R_X86_64_PC32 0000000000000000 .rodata + 1e 00000000000000f6 0000000b00000004 R_X86_64_PLT32 0000000000000000 puts - 4 0000000000000117 0000000300000002 R_X86_64_PC32 0000000000000000 .rodata + 2f 0000000000000124 0000000500000004 R_X86_64_PLT32 0000000000000000 printf - 4 000000000000013d 0000000c00000004 R_X86_64_PLT32 0000000000000000 __stack_chk_fail - 4 ❯ objdump -M intel -dr calc/main.o calc/main.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 : 0: 55 push rbp 1: 48 89 e5 mov rbp,rsp 4: 48 83 ec 20 sub rsp,0x20 8: 64 48 8b 04 25 28 00 mov rax,QWORD PTR fs:0x28 f: 00 00 11: 48 89 45 f8 mov QWORD PTR [rbp-0x8],rax 15: 31 c0 xor eax,eax 17: 48 8d 05 00 00 00 00 lea rax,[rip+0x0] # 1e 1a: R_X86_64_PC32 .rodata-0x4 1e: 48 89 c7 mov rdi,rax 21: b8 00 00 00 00 mov eax,0x0 26: e8 00 00 00 00 call 2b 27: R_X86_64_PLT32 printf-0x4 2b: 48 8d 4d f0 lea rcx,[rbp-0x10] 2f: 48 8d 55 eb lea rdx,[rbp-0x15] 33: 48 8d 45 ec lea rax,[rbp-0x14] 37: 48 89 c6 mov rsi,rax 3a: 48 8d 05 00 00 00 00 lea rax,[rip+0x0] # 41 3d: R_X86_64_PC32 .rodata+0x15 41: 48 89 c7 mov rdi,rax 44: b8 00 00 00 00 mov eax,0x0 49: e8 00 00 00 00 call 4e 4a: R_X86_64_PLT32 __isoc99_scanf-0x4 4e: 0f b6 45 eb movzx eax,BYTE PTR [rbp-0x15] 52: 0f be c0 movsx eax,al 55: 83 f8 2f cmp eax,0x2f 58: 74 74 je ce 5a: 83 f8 2f cmp eax,0x2f 5d: 0f 8f 88 00 00 00 jg eb 63: 83 f8 2d cmp eax,0x2d 66: 74 2c je 94 68: 83 f8 2d cmp eax,0x2d 6b: 7f 7e jg eb 6d: 83 f8 2a cmp eax,0x2a 70: 74 3f je b1 72: 83 f8 2b cmp eax,0x2b 75: 75 74 jne eb 77: f3 0f 10 45 f0 movss xmm0,DWORD PTR [rbp-0x10] 7c: 8b 45 ec mov eax,DWORD PTR [rbp-0x14] 7f: 0f 28 c8 movaps xmm1,xmm0 82: 66 0f 6e c0 movd xmm0,eax 86: e8 00 00 00 00 call 8b 87: R_X86_64_PLT32 addFunc-0x4 8b: 66 0f 7e c0 movd eax,xmm0 8f: 89 45 f4 mov DWORD PTR [rbp-0xc],eax 92: eb 6d jmp 101 94: f3 0f 10 45 f0 movss xmm0,DWORD PTR [rbp-0x10] 99: 8b 45 ec mov eax,DWORD PTR [rbp-0x14] 9c: 0f 28 c8 movaps xmm1,xmm0 9f: 66 0f 6e c0 movd xmm0,eax a3: e8 00 00 00 00 call a8 a4: R_X86_64_PLT32 subFunc-0x4 a8: 66 0f 7e c0 movd eax,xmm0 ac: 89 45 f4 mov DWORD PTR [rbp-0xc],eax af: eb 50 jmp 101 b1: f3 0f 10 45 f0 movss xmm0,DWORD PTR [rbp-0x10] b6: 8b 45 ec mov eax,DWORD PTR [rbp-0x14] b9: 0f 28 c8 movaps xmm1,xmm0 bc: 66 0f 6e c0 movd xmm0,eax c0: e8 00 00 00 00 call c5 c1: R_X86_64_PLT32 mulFunc-0x4 c5: 66 0f 7e c0 movd eax,xmm0 c9: 89 45 f4 mov DWORD PTR [rbp-0xc],eax cc: eb 33 jmp 101 ce: f3 0f 10 45 f0 movss xmm0,DWORD PTR [rbp-0x10] d3: 8b 45 ec mov eax,DWORD PTR [rbp-0x14] d6: 0f 28 c8 movaps xmm1,xmm0 d9: 66 0f 6e c0 movd xmm0,eax dd: e8 00 00 00 00 call e2 de: R_X86_64_PLT32 divFunc-0x4 e2: 66 0f 7e c0 movd eax,xmm0 e6: 89 45 f4 mov DWORD PTR [rbp-0xc],eax e9: eb 16 jmp 101 eb: 48 8d 05 00 00 00 00 lea rax,[rip+0x0] # f2 ee: R_X86_64_PC32 .rodata+0x1e f2: 48 89 c7 mov rdi,rax f5: e8 00 00 00 00 call fa f6: R_X86_64_PLT32 puts-0x4 fa: b8 01 00 00 00 mov eax,0x1 ff: eb 2c jmp 12d 101: 66 0f ef d2 pxor xmm2,xmm2 105: f3 0f 5a 55 f4 cvtss2sd xmm2,DWORD PTR [rbp-0xc] 10a: 66 48 0f 7e d0 movq rax,xmm2 10f: 66 48 0f 6e c0 movq xmm0,rax 114: 48 8d 05 00 00 00 00 lea rax,[rip+0x0] # 11b 117: R_X86_64_PC32 .rodata+0x2f 11b: 48 89 c7 mov rdi,rax 11e: b8 01 00 00 00 mov eax,0x1 123: e8 00 00 00 00 call 128 124: R_X86_64_PLT32 printf-0x4 128: b8 00 00 00 00 mov eax,0x0 12d: 48 8b 55 f8 mov rdx,QWORD PTR [rbp-0x8] 131: 64 48 2b 14 25 28 00 sub rdx,QWORD PTR fs:0x28 138: 00 00 13a: 74 05 je 141 13c: e8 00 00 00 00 call 141 13d: R_X86_64_PLT32 __stack_chk_fail-0x4 141: c9 leave 142: c3 ret Conclustion Throughout this article, we explored the significance of relocations in ELF binaries, examining how compilers, assemblers, and linkers collaborate to produce executable files. We delved into the role of relocation sections, uncovering their purpose in accommodating changes to addresses and offsets during both compile-time and link-time.\nSince symbols and relocations combined are a huge topic in itself, I’m adding few links that I think are interesting and will help to better grasp the whole concept in practicality\n@xianeizhang’s notes (https://people.cs.pitt.edu/~xianeizhang/notes/Linking.html)\nUnderstanding the ELF specimen (https://hub.packtpub.com/understanding-elf-specimen/)\nCloudflare blogs on “How to execute an object file” - part 1 and part 2\nAn amazing talk by @Anders Schau Knatten on “How symbols work and why we need them” (youtube)\nSee you next time.\n","wordCount":"4801","inLanguage":"en","datePublished":"2023-12-08T14:17:56+05:30","dateModified":"2024-04-05T21:58:47+05:30","author":[{"@type":"Person","name":"ayedaemon"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://ayedaemon.github.io/post/2023/12/elf-chronicles-relocations/"},"publisher":{"@type":"Organization","name":"Connected","logo":{"@type":"ImageObject","url":"https://ayedaemon.github.io/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://ayedaemon.github.io/ accesskey=h title="Connected (Alt + H)">Connected</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://ayedaemon.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://ayedaemon.github.io/series/ title=Series><span>Series</span></a></li><li><a href=https://ayedaemon.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ayedaemon.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Elf Chronicles: Relocations (6/?)</h1><div class=post-description>Exploring general concept of ELF relocations</div><div class=post-meta><span title='2023-12-08 14:17:56 +0530 +0530'>December 8, 2023</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;4801 words&nbsp;·&nbsp;ayedaemon&nbsp;|&nbsp;<a href=https://github.com/ayedaemon/ayedaemon.github.io/tree/main/content/post/2023/12/elf-chronicles-relocations.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#relocations aria-label=Relocations>Relocations</a><ul><li><a href=#r_offset aria-label=r_offset>r_offset</a></li><li><a href=#r_info aria-label=r_info>r_info</a></li><li><a href=#r_addend aria-label=r_addend>r_addend</a></li></ul></li><li><a href=#analysis aria-label=Analysis>Analysis</a></li><li><a href=#conclustion aria-label=Conclustion>Conclustion</a></li></ul></div></details></div><div class=post-content><p>In previous article about Symbol Tables, we talked about the below diagram &mldr;.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     ┌────────────────────┐                        ┌─────────────────┐         ┌─────────────────┐
</span></span><span class=line><span class=cl>     │                    │                        │                 │         │                 │
</span></span><span class=line><span class=cl>     │   libarithmatic.c  │                        │ libarithmatic.h ├───────► │     main.c      │
</span></span><span class=line><span class=cl>     │                    │                        │                 │         │                 │
</span></span><span class=line><span class=cl>     └─────────┬──────────┘                        └─────────────────┘         └────────┬────────┘
</span></span><span class=line><span class=cl>               │                                                                        │
</span></span><span class=line><span class=cl>               │                                                                        │
</span></span><span class=line><span class=cl>               │ /* Compile + assemble */                                               │ /* Compile + assemble */
</span></span><span class=line><span class=cl>               │                                                                        │
</span></span><span class=line><span class=cl>               │                                                                        │
</span></span><span class=line><span class=cl>               ▼                                                                        ▼
</span></span><span class=line><span class=cl>    ┌─────────────────────┐                                                   ┌────────────────────┐
</span></span><span class=line><span class=cl>    │                     │                                                   │                    │
</span></span><span class=line><span class=cl>    │   libarithmatic.o   │                                                   │       main.o       │
</span></span><span class=line><span class=cl>    │                     │                                                   │                    │
</span></span><span class=line><span class=cl>    └─────────┬───────────┘                                                   └──────────┬─────────┘
</span></span><span class=line><span class=cl>              │                                                                          │
</span></span><span class=line><span class=cl>              │                                                                          │
</span></span><span class=line><span class=cl>              │                                                                          │
</span></span><span class=line><span class=cl>              │                                                                          │
</span></span><span class=line><span class=cl>              │                          /* Linking Magic */                             │
</span></span><span class=line><span class=cl>              └───────────────────────────────────┬──────────────────────────────────────┘
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  ▼
</span></span><span class=line><span class=cl>                                           ┌────────────────┐
</span></span><span class=line><span class=cl>                                           │                │
</span></span><span class=line><span class=cl>                                           │     calc       │
</span></span><span class=line><span class=cl>                                           │                │
</span></span><span class=line><span class=cl>                                           └────────────────┘
</span></span></code></pre></div><p>&mldr;and how the compiler was unaware of the final addresses for many symbols. When things get a bit confusing for the compiler, it takes the easy route by putting zeros in the addresses and creating relocation entries for the linker/loader to sort out.</p><p>The linker combines all the <code>.o</code> files, causing changes to the positions of different parts. For example, the <code>main</code> function in <code>main.o</code> and <code>addFunc</code> in <code>libarithmatic.o</code> both start off at position <code>0x0</code>. But when you link these files, this setup causes issues, so some tweaks are needed.</p><p>In this situation, the compiler and assembler team up to produce the <code>.o</code> file, but they don&rsquo;t know for sure where each part will end up in the eventual <code>calc</code> binary. So, they play it safe by leaving these spots empty and make notes in the relocations section. This tells the linker that these positions need some adjustments later on.</p><h2 id=relocations>Relocations<a hidden class=anchor aria-hidden=true href=#relocations>#</a></h2><p>According to <a href=https://refspecs.linuxbase.org/elf/elf.pdf>ELF specification (version 1.2)</a></p><blockquote><blockquote><p>Relocation is the process of connecting symbolic references with symbolic definitions.</p></blockquote></blockquote><p>Relocation is a straightforward concept in coding. When you&rsquo;re compiling code, the compiler doesn&rsquo;t always know the exact addresses for everything in the program. ELF relocations become important when the addresses of symbols are uncertain during compilation, often because the final addresses are determined by the linker or loader at a later stage. It&rsquo;s similar to arranging pieces in a puzzle without having all the details upfront.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>## Before linking - main.o
</span></span><span class=line><span class=cl>❯ objdump -M intel -D -j .text main.o | grep call
</span></span><span class=line><span class=cl> 26:        e8 00 00 00 00          call   2b &lt;main+0x2b&gt;
</span></span><span class=line><span class=cl> 49:        e8 00 00 00 00          call   4e &lt;main+0x4e&gt;
</span></span><span class=line><span class=cl> 86:        e8 00 00 00 00          call   8b &lt;main+0x8b&gt;
</span></span><span class=line><span class=cl> a3:        e8 00 00 00 00          call   a8 &lt;main+0xa8&gt;
</span></span><span class=line><span class=cl> c0:        e8 00 00 00 00          call   c5 &lt;main+0xc5&gt;
</span></span><span class=line><span class=cl> dd:        e8 00 00 00 00          call   e2 &lt;main+0xe2&gt;
</span></span><span class=line><span class=cl> f5:        e8 00 00 00 00          call   fa &lt;main+0xfa&gt;
</span></span><span class=line><span class=cl>123:        e8 00 00 00 00          call   128 &lt;main+0x128&gt;
</span></span><span class=line><span class=cl>13c:        e8 00 00 00 00          call   141 &lt;main+0x141&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>## After linking - calc
</span></span><span class=line><span class=cl>❯ objdump -M intel -D -j .text calc | grep call
</span></span><span class=line><span class=cl>1138:       e8 63 ff ff ff          call   10a0 &lt;_start+0x30&gt;
</span></span><span class=line><span class=cl>118f:       e8 bc fe ff ff          call   1050 &lt;printf@plt&gt;
</span></span><span class=line><span class=cl>11b2:       e8 a9 fe ff ff          call   1060 &lt;__isoc99_scanf@plt&gt;
</span></span><span class=line><span class=cl>11ef:       e8 b8 00 00 00          call   12ac &lt;addFunc&gt;
</span></span><span class=line><span class=cl>120c:       e8 b5 00 00 00          call   12c6 &lt;subFunc&gt;
</span></span><span class=line><span class=cl>1229:       e8 b2 00 00 00          call   12e0 &lt;mulFunc&gt;
</span></span><span class=line><span class=cl>1246:       e8 af 00 00 00          call   12fa &lt;divFunc&gt;
</span></span><span class=line><span class=cl>125e:       e8 cd fd ff ff          call   1030 &lt;puts@plt&gt;
</span></span><span class=line><span class=cl>128c:       e8 bf fd ff ff          call   1050 &lt;printf@plt&gt;
</span></span><span class=line><span class=cl>12a5:       e8 96 fd ff ff          call   1040 &lt;__stack_chk_fail@plt&gt;
</span></span></code></pre></div><p>Now, there are three essential elements needed for relocation to take place:</p><ol><li>The spot where the adjustment needs to be made.</li><li>The symbol that&rsquo;s part of the adjustment.</li><li>An algorithm specifying how to calculate and apply the necessary fix.</li></ol><p>The compiler stores all this information in a special section identified by type - either <code>REL</code> (0x9) or <code>RELA</code> (0x4).</p><ul><li><code>REL</code> is used for basic relocation entries.</li><li><code>RELA</code> is essentially the same as <code>REL</code>, but with an extra addend value. <em>This doesn&rsquo;t significantly impact the concept, though.</em></li></ul><p>You can easily identify these sections using <code>readelf</code>;&mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>❯ readelf --section-headers --wide main.o
</span></span><span class=line><span class=cl>There are 14 section headers, starting at offset 0x5a8:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Section Headers:
</span></span><span class=line><span class=cl>  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
</span></span><span class=line><span class=cl>  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0
</span></span><span class=line><span class=cl>  [ 1] .text             PROGBITS        0000000000000000 000040 000143 00  AX  0   0  1
</span></span><span class=line><span class=cl>  [ 2] .rela.text        RELA            0000000000000000 0003e0 000138 18   I 11   1  8
</span></span><span class=line><span class=cl>  [ 3] .data             PROGBITS        0000000000000000 000183 000000 00  WA  0   0  1
</span></span><span class=line><span class=cl>  [ 4] .bss              NOBITS          0000000000000000 000183 000000 00  WA  0   0  1
</span></span><span class=line><span class=cl>  [ 5] .rodata           PROGBITS        0000000000000000 000183 000041 00   A  0   0  1
</span></span><span class=line><span class=cl>  [ 6] .comment          PROGBITS        0000000000000000 0001c4 00001c 01  MS  0   0  1
</span></span><span class=line><span class=cl>  [ 7] .note.GNU-stack   PROGBITS        0000000000000000 0001e0 000000 00      0   0  1
</span></span><span class=line><span class=cl>  [ 8] .note.gnu.property NOTE            0000000000000000 0001e0 000030 00   A  0   0  8
</span></span><span class=line><span class=cl>  [ 9] .eh_frame         PROGBITS        0000000000000000 000210 000038 00   A  0   0  8
</span></span><span class=line><span class=cl>  [10] .rela.eh_frame    RELA            0000000000000000 000518 000018 18   I 11   9  8
</span></span><span class=line><span class=cl>  [11] .symtab           SYMTAB          0000000000000000 000248 000138 18     12   4  8
</span></span><span class=line><span class=cl>  [12] .strtab           STRTAB          0000000000000000 000380 000059 00      0   0  1
</span></span><span class=line><span class=cl>  [13] .shstrtab         STRTAB          0000000000000000 000530 000074 00      0   0  1
</span></span><span class=line><span class=cl>Key to Flags:
</span></span><span class=line><span class=cl>  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
</span></span><span class=line><span class=cl>  L (link order), O (extra OS processing required), G (group), T (TLS),
</span></span><span class=line><span class=cl>  C (compressed), x (unknown), o (OS specific), E (exclude),
</span></span><span class=line><span class=cl>  D (mbind), l (large), p (processor specific)
</span></span></code></pre></div><p>My parser gives me the same results&mldr; (with different looks)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> [ 00 ] Section Name:                            Type: 0x0       Flags: 0x0      Addr: 0x0       Offset: 0x0             Size: 0         Link: 0         Info: 0x0       Addralign: 0x0          Entsize: 0
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> [ 01 ] Section Name: .text                      Type: 0x1       Flags: 0x6      Addr: 0x0       Offset: 0x40            Size: 323       Link: 0         Info: 0x0       Addralign: 0x1          Entsize: 0
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> [ 02 ] Section Name: .rela.text                 Type: 0x4       Flags: 0x40     Addr: 0x0       Offset: 0x3e0           Size: 312       Link: 11        Info: 0x1       Addralign: 0x8          Entsize: 24
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> [ 03 ] Section Name: .data                      Type: 0x1       Flags: 0x3      Addr: 0x0       Offset: 0x183           Size: 0         Link: 0         Info: 0x0       Addralign: 0x1          Entsize: 0
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> [ 04 ] Section Name: .bss                       Type: 0x8       Flags: 0x3      Addr: 0x0       Offset: 0x183           Size: 0         Link: 0         Info: 0x0       Addralign: 0x1          Entsize: 0
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> [ 05 ] Section Name: .rodata                    Type: 0x1       Flags: 0x2      Addr: 0x0       Offset: 0x183           Size: 65        Link: 0         Info: 0x0       Addralign: 0x1          Entsize: 0
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> [ 06 ] Section Name: .comment                   Type: 0x1       Flags: 0x30     Addr: 0x0       Offset: 0x1c4           Size: 28        Link: 0         Info: 0x0       Addralign: 0x1          Entsize: 1
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> [ 07 ] Section Name: .note.GNU-stack            Type: 0x1       Flags: 0x0      Addr: 0x0       Offset: 0x1e0           Size: 0         Link: 0         Info: 0x0       Addralign: 0x1          Entsize: 0
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> [ 08 ] Section Name: .note.gnu.property         Type: 0x7       Flags: 0x2      Addr: 0x0       Offset: 0x1e0           Size: 48        Link: 0         Info: 0x0       Addralign: 0x8          Entsize: 0
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> [ 09 ] Section Name: .eh_frame                  Type: 0x1       Flags: 0x2      Addr: 0x0       Offset: 0x210           Size: 56        Link: 0         Info: 0x0       Addralign: 0x8          Entsize: 0
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> [ 10 ] Section Name: .rela.eh_frame             Type: 0x4       Flags: 0x40     Addr: 0x0       Offset: 0x518           Size: 24        Link: 11        Info: 0x9       Addralign: 0x8          Entsize: 24
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> [ 11 ] Section Name: .symtab                    Type: 0x2       Flags: 0x0      Addr: 0x0       Offset: 0x248           Size: 312       Link: 12        Info: 0x4       Addralign: 0x8          Entsize: 24
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> [ 12 ] Section Name: .strtab                    Type: 0x3       Flags: 0x0      Addr: 0x0       Offset: 0x380           Size: 89        Link: 0         Info: 0x0       Addralign: 0x1          Entsize: 0
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> [ 13 ] Section Name: .shstrtab                  Type: 0x3       Flags: 0x0      Addr: 0x0       Offset: 0x530           Size: 116       Link: 0         Info: 0x0       Addralign: 0x1          Entsize: 0
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span></code></pre></div><p>In any case, identifying the relocation sections is straightforward &ndash; REL (0x9) or RELA (0x4).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># From readelf
</span></span><span class=line><span class=cl>  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
</span></span><span class=line><span class=cl>  [ 2] .rela.text        RELA            0000000000000000 0003e0 000138 18   I 11   1  8
</span></span><span class=line><span class=cl>  [10] .rela.eh_frame    RELA            0000000000000000 000518 000018 18   I 11   9  8
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># From my parser
</span></span><span class=line><span class=cl> [ 02 ] Section Name: .rela.text                 Type: 0x4       Flags: 0x40     Addr: 0x0       Offset: 0x3e0           Size: 312       Link: 11        Info: 0x1       Addralign: 0x8          Entsize: 24
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> [ 10 ] Section Name: .rela.eh_frame             Type: 0x4       Flags: 0x40     Addr: 0x0       Offset: 0x518           Size: 24        Link: 11        Info: 0x9       Addralign: 0x8          Entsize: 24
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span></code></pre></div><p>(Note: To keep things clear in this article and to maintain simplicity, we&rsquo;re going to ignore the <code>.rela.eh_frame</code>. We can dive into that particular aspect another time.)</p><p>We can use the details shared earlier to pinpoint the real data of the relocation section. This means we&rsquo;ll be finding the section data by using the section header entry &ndash; a process we&rsquo;ve gone through multiple times before.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            [ 02 ] Section Name: .rela.text
</span></span><span class=line><span class=cl>                      Type: 0x4
</span></span><span class=line><span class=cl>                      Flags: 0x40
</span></span><span class=line><span class=cl>                      Addr: 0x0
</span></span><span class=line><span class=cl>            ┌─────────Offset: 0x3e0
</span></span><span class=line><span class=cl>            │      ┌──Size: 312
</span></span><span class=line><span class=cl>            │      │  Link: 11
</span></span><span class=line><span class=cl>            │      │  Info: 0x1
</span></span><span class=line><span class=cl>            │      │  Addralign: 0x8
</span></span><span class=line><span class=cl>            │      │  Entsize: 24
</span></span><span class=line><span class=cl>            │      │        │
</span></span><span class=line><span class=cl>            │      │        │
</span></span><span class=line><span class=cl>            │      │        │
</span></span><span class=line><span class=cl>            ▼      ▼        ▼
</span></span><span class=line><span class=cl>❯ xxd -s 0x3e0 -l 0x138 -c 0x18 main.o | nl -v0 -
</span></span><span class=line><span class=cl>     0  000003e0: 1a00 0000 0000 0000 0200 0000 0300 0000 fcff ffff ffff ffff  ........................
</span></span><span class=line><span class=cl>     1  000003f8: 2700 0000 0000 0000 0400 0000 0500 0000 fcff ffff ffff ffff  &#39;.......................
</span></span><span class=line><span class=cl>     2  00000410: 3d00 0000 0000 0000 0200 0000 0300 0000 1500 0000 0000 0000  =.......................
</span></span><span class=line><span class=cl>     3  00000428: 4a00 0000 0000 0000 0400 0000 0600 0000 fcff ffff ffff ffff  J.......................
</span></span><span class=line><span class=cl>     4  00000440: 8700 0000 0000 0000 0400 0000 0700 0000 fcff ffff ffff ffff  ........................
</span></span><span class=line><span class=cl>     5  00000458: a400 0000 0000 0000 0400 0000 0800 0000 fcff ffff ffff ffff  ........................
</span></span><span class=line><span class=cl>     6  00000470: c100 0000 0000 0000 0400 0000 0900 0000 fcff ffff ffff ffff  ........................
</span></span><span class=line><span class=cl>     7  00000488: de00 0000 0000 0000 0400 0000 0a00 0000 fcff ffff ffff ffff  ........................
</span></span><span class=line><span class=cl>     8  000004a0: ee00 0000 0000 0000 0200 0000 0300 0000 1e00 0000 0000 0000  ........................
</span></span><span class=line><span class=cl>     9  000004b8: f600 0000 0000 0000 0400 0000 0b00 0000 fcff ffff ffff ffff  ........................
</span></span><span class=line><span class=cl>    10  000004d0: 1701 0000 0000 0000 0200 0000 0300 0000 2f00 0000 0000 0000  ................/.......
</span></span><span class=line><span class=cl>    11  000004e8: 2401 0000 0000 0000 0400 0000 0500 0000 fcff ffff ffff ffff  $.......................
</span></span><span class=line><span class=cl>    12  00000500: 3d01 0000 0000 0000 0400 0000 0c00 0000 fcff ffff ffff ffff  =.......................
</span></span></code></pre></div><p>Linux kernel has some specific structures to define <code>REL</code> and <code>RELA</code> entries&mldr;.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/elf.h#L171 */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>elf64_rel</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Addr</span> <span class=n>r_offset</span><span class=p>;</span>	<span class=cm>/* Location at which to apply the action */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span> <span class=n>r_info</span><span class=p>;</span>	<span class=cm>/* index and type of relocation */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf64_Rel</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/elf.h#L182 */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>elf64_rela</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Addr</span> <span class=n>r_offset</span><span class=p>;</span>	<span class=cm>/* Location at which to apply the action */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span> <span class=n>r_info</span><span class=p>;</span>	<span class=cm>/* index and type of relocation */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Sxword</span> <span class=n>r_addend</span><span class=p>;</span>	<span class=cm>/* Constant addend used to compute value */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf64_Rela</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/elf.h#L163 */</span>
</span></span><span class=line><span class=cl><span class=cp>#define ELF64_R_SYM(i)			((i) &gt;&gt; 32)
</span></span></span><span class=line><span class=cl><span class=cp>#define ELF64_R_TYPE(i)			((i) &amp; 0xffffffff)
</span></span></span></code></pre></div><p>After parsing this section&rsquo;s data, I got following results.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[ 02 ] Section Name: .rela.text        Type: 0x4       Flags: 0x40     Addr: 0x0       Offset: 0x3e0           Size: 312       Link: 11        Info: 0x1       Addralign: 0x8          Entsize: 24
</span></span><span class=line><span class=cl>     [  0 ] Offset: 0x1a         Info: 0x000300000002 (Sym: 0x3 | Type: 0x2)     Addend: -4
</span></span><span class=line><span class=cl>     [  1 ] Offset: 0x27         Info: 0x000500000004 (Sym: 0x5 | Type: 0x4)     Addend: -4
</span></span><span class=line><span class=cl>     [  2 ] Offset: 0x3d         Info: 0x000300000002 (Sym: 0x3 | Type: 0x2)     Addend: 21
</span></span><span class=line><span class=cl>     [  3 ] Offset: 0x4a         Info: 0x000600000004 (Sym: 0x6 | Type: 0x4)     Addend: -4
</span></span><span class=line><span class=cl>     [  4 ] Offset: 0x87         Info: 0x000700000004 (Sym: 0x7 | Type: 0x4)     Addend: -4
</span></span><span class=line><span class=cl>     [  5 ] Offset: 0xa4         Info: 0x000800000004 (Sym: 0x8 | Type: 0x4)     Addend: -4
</span></span><span class=line><span class=cl>     [  6 ] Offset: 0xc1         Info: 0x000900000004 (Sym: 0x9 | Type: 0x4)     Addend: -4
</span></span><span class=line><span class=cl>     [  7 ] Offset: 0xde         Info: 0x000a00000004 (Sym: 0xa | Type: 0x4)     Addend: -4
</span></span><span class=line><span class=cl>     [  8 ] Offset: 0xee         Info: 0x000300000002 (Sym: 0x3 | Type: 0x2)     Addend: 30
</span></span><span class=line><span class=cl>     [  9 ] Offset: 0xf6         Info: 0x000b00000004 (Sym: 0xb | Type: 0x4)     Addend: -4
</span></span><span class=line><span class=cl>     [ 10 ] Offset: 0x117        Info: 0x000300000002 (Sym: 0x3 | Type: 0x2)     Addend: 47
</span></span><span class=line><span class=cl>     [ 11 ] Offset: 0x124        Info: 0x000500000004 (Sym: 0x5 | Type: 0x4)     Addend: -4
</span></span><span class=line><span class=cl>     [ 12 ] Offset: 0x13d        Info: 0x000c00000004 (Sym: 0xc | Type: 0x4)     Addend: -4
</span></span></code></pre></div><p>Let&rsquo;s pause for a moment to grasp the significance of each member in this structure and how it aids the linker in the relocation process.</p><p>(👇 <em>Shamelessly stolen from <a href=https://www.man7.org/linux/man-pages/man5/elf.5.html><code>man 5 elf</code></a></em> 👇)</p><h3 id=r_offset>r_offset<a hidden class=anchor aria-hidden=true href=#r_offset>#</a></h3><p>This member gives the location at which to apply the relocation.</p><ul><li>For a relocatable file, the value is the byte offset from the beginning of the section where relocation is to be applied.</li><li>For an executable file or shared object, the value is the virtual address of the storage unit affected by the relocation.</li></ul><h3 id=r_info>r_info<a hidden class=anchor aria-hidden=true href=#r_info>#</a></h3><p>This member gives both the symbol table index with respect to which the relocation must be made and the type of relocation to apply. (Linux kernel provides a macro to filter these values out from it - <code>ELF64_R_SYM</code> and <code>ELF64_R_TYPE</code>)</p><h3 id=r_addend>r_addend<a hidden class=anchor aria-hidden=true href=#r_addend>#</a></h3><p>This member specifies a constant addend used to compute the value to be stored into the relocatable field.</p><h2 id=analysis>Analysis<a hidden class=anchor aria-hidden=true href=#analysis>#</a></h2><p>Now armed with the theoretical knowledge, let&rsquo;s delve into how the linker utilizes this information to perform a relocation. We&rsquo;ll begin by examining the details of the first relocation entry.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[  0 ] Offset: 0x1a         Info: 0x000300000002 (Sym: 0x3 | Type: 0x2)     Addend: -4
</span></span></code></pre></div><p>Now there are 2 things I want you to think about before we even start with the relocation process&mldr;</p><ol><li>We know <code>r_offset</code> holds the offset from beginning of the section where relocation is to be applied. <strong>Which section is that here??</strong></li><li>And <code>ELF64_R_SYM</code> from <code>r_info</code> stores the index in symbol table. But we can obviously have more than 1 symbol table, so <strong>Which symbol table we are talking about here??</strong></li></ol><p>Answer &#187; To identify that, you just have to check <code>sh_info</code> and <code>sh_link</code> members from the section header entry.</p><p>In our case, the associated symbol table and the section where relocations will apply can be viewed like this:-</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>             ┌────────────────────────────────────┐
</span></span><span class=line><span class=cl>             │  [ 11 ] Section Name: .symtab      │◄───────┐
</span></span><span class=line><span class=cl>             │          Type: 0x2                 │        │
</span></span><span class=line><span class=cl>             │          Flags: 0x0                │        │
</span></span><span class=line><span class=cl>             │          Addr: 0x0                 │        │
</span></span><span class=line><span class=cl>             │          Offset: 0x248             │        │
</span></span><span class=line><span class=cl>             │          Size: 312                 │        │
</span></span><span class=line><span class=cl>             │          Link: 12                  │        │
</span></span><span class=line><span class=cl>             │          Info: 0x4                 │        │
</span></span><span class=line><span class=cl>             │          Addralign: 0x8            │        │
</span></span><span class=line><span class=cl>             │          Entsize: 24               │        │
</span></span><span class=line><span class=cl>             │                                    │        │
</span></span><span class=line><span class=cl>             └────────────────────────────────────┘        │
</span></span><span class=line><span class=cl>                                                           │
</span></span><span class=line><span class=cl>                         /* all the symbols associated     │
</span></span><span class=line><span class=cl>                            are in section 11 */           │
</span></span><span class=line><span class=cl>                                                           │
</span></span><span class=line><span class=cl>                                                           │
</span></span><span class=line><span class=cl>             ┌────────────────────────────────────┐        │
</span></span><span class=line><span class=cl>             │  [ 02 ] Section Name: .rela.text   │        │
</span></span><span class=line><span class=cl>             │          Type: 0x4                 │        │
</span></span><span class=line><span class=cl>             │          Flags: 0x40               │        │
</span></span><span class=line><span class=cl>             │          Addr: 0x0                 │        │
</span></span><span class=line><span class=cl>             │          Offset: 0x3e0             │        │
</span></span><span class=line><span class=cl>             │          Size: 312                 │        │
</span></span><span class=line><span class=cl>             │          Link: 11 ─────────────────┼────────┘
</span></span><span class=line><span class=cl>     ┌───────┼───────── Info: 0x1                 │
</span></span><span class=line><span class=cl>     │       │          Addralign: 0x8            │
</span></span><span class=line><span class=cl>     │       │          Entsize: 24               │
</span></span><span class=line><span class=cl>     │       │                                    │
</span></span><span class=line><span class=cl>     │       └────────────────────────────────────┘
</span></span><span class=line><span class=cl>     │
</span></span><span class=line><span class=cl>     │
</span></span><span class=line><span class=cl>     │ /* relocations apply to section with index 1 */
</span></span><span class=line><span class=cl>     │
</span></span><span class=line><span class=cl>     │       ┌───────────────────────────────────┐
</span></span><span class=line><span class=cl>     └──────►│   [ 01 ] Section Name: .text      │
</span></span><span class=line><span class=cl>             │           Type: 0x1               │
</span></span><span class=line><span class=cl>             │           Flags: 0x6              │
</span></span><span class=line><span class=cl>             │           Addr: 0x0               │
</span></span><span class=line><span class=cl>             │           Offset: 0x40            │
</span></span><span class=line><span class=cl>             │           Size: 323               │
</span></span><span class=line><span class=cl>             │           Link: 0                 │
</span></span><span class=line><span class=cl>             │           Info: 0x0               │
</span></span><span class=line><span class=cl>             │           Addralign: 0x1          │
</span></span><span class=line><span class=cl>             │           Entsize: 0              │
</span></span><span class=line><span class=cl>             │                                   │
</span></span><span class=line><span class=cl>             └───────────────────────────────────┘
</span></span></code></pre></div><p>Traditionally, the chosen naming scheme for the relocation section indicates the section where relocations are intended to be applied. For example, if relocations are to be applied on <code>.text</code> section, then the relocation entries will be under <code>.rela.text</code> or <code>.rel.text</code>. However, it&rsquo;s crucial to note that this is merely a tradition and not a strict requirement.</p><p><em>In the wisdom of ancient gods, it is advised not to depend solely on names.</em></p><p><img loading=lazy src=https://media.giphy.com/media/Y3ptrXcCeZZdj0yPZH/giphy.gif#center alt></p><p>Now that you know where to apply relocation and where to look for symbols&mldr; let&rsquo;s look at the relocation entry we started with</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[  0 ] Offset: 0x1a         Info: 0x000300000002 (Sym: 0x3 | Type: 0x2)     Addend: -4
</span></span></code></pre></div><p>We can now understand that:</p><ul><li>The relocation is to be applied at offset <code>0x1a</code> in <code>.text</code> section.</li><li>The symbol associated with this relocation is 3rd symbol in <code>.symtab</code> section.</li></ul><p>So, if you want to see the big picture,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>              ┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
</span></span><span class=line><span class=cl>              │ [ 11 ] Section Name: .symtab                    Type: 0x2       Flags: 0x0      Addr: 0x0       Offset: 0x248           Size: 312       Link: 12        Info: 0x4       Addralign: 0x8 │
</span></span><span class=line><span class=cl>              │      [  0 ] Name:                                        Info: 0x00 (Bind: 0x0 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0                     │
</span></span><span class=line><span class=cl>              │      [  1 ] Name: main.c                                 Info: 0x04 (Bind: 0x0 | Type: 0x4)      Other: 0x0      Shndx: 0xfff1   Value: 0x000000000000   Size: 0x0                     │
</span></span><span class=line><span class=cl>              │      [  2 ] Name:                                        Info: 0x03 (Bind: 0x0 | Type: 0x3)      Other: 0x0      Shndx: 0x1      Value: 0x000000000000   Size: 0x0                     │
</span></span><span class=line><span class=cl>        ┌─────┼────► [  3 ] Name:                                        Info: 0x03 (Bind: 0x0 | Type: 0x3)      Other: 0x0      Shndx: 0x5      Value: 0x000000000000   Size: 0x0                     │
</span></span><span class=line><span class=cl>        │     │      [  4 ] Name: main                                   Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0x1      Value: 0x000000000000   Size: 0x143                   │
</span></span><span class=line><span class=cl>        │     │      [  5 ] Name: printf                                 Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0                     │
</span></span><span class=line><span class=cl>        │     │      [  6 ] Name: __isoc99_scanf                         Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0                     │
</span></span><span class=line><span class=cl>        │     │      [  7 ] Name: addFunc                                Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0                     │
</span></span><span class=line><span class=cl>        │     │      [  8 ] Name: subFunc                                Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0                     │
</span></span><span class=line><span class=cl>        │     │      [  9 ] Name: mulFunc                                Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0                     │
</span></span><span class=line><span class=cl>        │     │      [ 10 ] Name: divFunc                                Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0                     │
</span></span><span class=line><span class=cl>        │     │      [ 11 ] Name: puts                                   Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0                     │
</span></span><span class=line><span class=cl>        │     │      [ 12 ] Name: __stack_chk_fail                       Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0                     │
</span></span><span class=line><span class=cl>        │     │                                                                                                                                                                                        │
</span></span><span class=line><span class=cl>        │     └────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
</span></span><span class=line><span class=cl>        │
</span></span><span class=line><span class=cl>        └──────────────────────────────────────────────────────────┐
</span></span><span class=line><span class=cl>                                                                   │
</span></span><span class=line><span class=cl>                                                                   │
</span></span><span class=line><span class=cl>                                                                   │
</span></span><span class=line><span class=cl>                                                                   │
</span></span><span class=line><span class=cl>                                                                   │
</span></span><span class=line><span class=cl>          [  0 ] Offset: 0x1a         Info: 0x000300000002 (Sym: 0x3 | Type: 0x2)     Addend: -4
</span></span><span class=line><span class=cl>                           │
</span></span><span class=line><span class=cl>                           │
</span></span><span class=line><span class=cl>                           │
</span></span><span class=line><span class=cl>                           │
</span></span><span class=line><span class=cl>                           └─────────────────────────┐
</span></span><span class=line><span class=cl>                                                     │
</span></span><span class=line><span class=cl>                                                     │
</span></span><span class=line><span class=cl>                    ┌────────────────────────────────┼───────────────────────────────────────────────────┐
</span></span><span class=line><span class=cl>                    │                                │                                                   │
</span></span><span class=line><span class=cl>                    │   Disassembly of section .text:│                                                   │
</span></span><span class=line><span class=cl>                    │                                │                                                   │
</span></span><span class=line><span class=cl>                    │   0000000000000000 &lt;main&gt;:     │                                                   │
</span></span><span class=line><span class=cl>                    │      0:   55                   │  push   rbp                                       │
</span></span><span class=line><span class=cl>                    │      1:   48 89 e5             │  mov    rbp,rsp                                   │
</span></span><span class=line><span class=cl>                    │      4:   48 83 ec 20          │  sub    rsp,0x20                                  │
</span></span><span class=line><span class=cl>                    │      8:   64 48 8b 04 25 28 00 │  mov    rax,QWORD PTR fs:0x28                     │
</span></span><span class=line><span class=cl>                    │      f:   00 00             ┌──┘                                                   │
</span></span><span class=line><span class=cl>                    │     11:   48 89 45 f8       ▼     mov    QWORD PTR [rbp-0x8],rax                   │
</span></span><span class=line><span class=cl>                    │     15:   31 c0   ┌───────────┐   xor    eax,eax                                   │
</span></span><span class=line><span class=cl>                    │     17:   48 8d 05│00 00 00 00│   lea    rax,[rip+0x0]        # 1e &lt;main+0x1e&gt;     │
</span></span><span class=line><span class=cl>                    │     1e:   48 89 c7└───────────┘   mov    rdi,rax                                   │
</span></span><span class=line><span class=cl>                    │     21:   b8 00 00 00 00          mov    eax,0x0                                   │
</span></span><span class=line><span class=cl>                    │     26:   e8 00 00 00 00          call   2b &lt;main+0x2b&gt;                            │
</span></span><span class=line><span class=cl>                    │     2b:   48 8d 4d f0             lea    rcx,[rbp-0x10]                            │
</span></span><span class=line><span class=cl>                    │                                                                                    │
</span></span><span class=line><span class=cl>                    └────────────────────────────────────────────────────────────────────────────────────┘
</span></span></code></pre></div><p>I get that things might look like a mess, a real puzzle at first. But trust me, with a bit of experience, you&rsquo;ll start to figure it out.</p><p>Now that we&rsquo;ve uncovered the secret behind the symbol and pinpointed where the relocation is going to happen, it&rsquo;s time to figure out the algorithm we&rsquo;re going to use for relocation. Just peek into the <code>Type</code> part of <code>r_info</code>. In our case, it&rsquo;s holding the number <code>0x2</code>.</p><p>With a quick look at the gcc source code, I can tell you that this algorithm is <code>R_X86_64_PC32</code>&mldr; And another brief look at the source code of <a href=https://github.com/rui314/mold/><code>mold</code> (a modern linker)</a> helps me fully comprehend the algorithm&mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/elf.h;hb=2bd00179885928fd95fcabfafc50e7b5c6e660d2#l3579 */</span>
</span></span><span class=line><span class=cl><span class=cp>#define R_X86_64_PC32           2       </span><span class=cm>/* PC relative 32 bit signed */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* https://github.com/rui314/mold/blob/main/elf/arch-x86-64.cc#L433C1-L436C13 */</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nl>R_X86_64_PC32</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nl>R_X86_64_PLT32</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nf>write32s</span><span class=p>(</span><span class=n>S</span> <span class=o>+</span> <span class=n>A</span> <span class=o>-</span> <span class=n>P</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>break</span><span class=p>;</span>
</span></span></code></pre></div><p>Alright, so the magical spell for this relocation is <code>S + A - P</code>&mldr;. Now, let&rsquo;s break it down</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>S = value of symbol
</span></span><span class=line><span class=cl>A = Addend (r_addend)
</span></span><span class=line><span class=cl>P = place of relocation (r_offset is used to calculate this)
</span></span></code></pre></div><p>The addend (<code>A</code>) is simply <code>-4</code>. Why <code>-4</code>?? I don&rsquo;t know 🤷 <code>¯\_(ツ)_/¯</code> (If you happen to know it, please share your wisdom with this stuppid child&mldr; pretty please! 🥺👉👈)</p><p>And the place of relocation (<code>P</code>) should be <code>0x1a</code>&mldr; right? <strong>WRONG!!</strong>&mldr; the place of relocation will be location of <code>.text</code> section + <code>0x1a</code>. Linker will know where <code>.text</code> will be after the merge process, so it&rsquo;ll be easy for the linker to get the exact location.</p><p>Finally, value of symbol (<code>S</code>), this one is a bit tricky here&mldr; You need to take a look at the symbol table for this</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[ 11 ] Section Name: .symtab                    Type: 0x2       Flags: 0x0      Addr: 0x0       Offset: 0x248           Size: 312       Link: 12        Info: 0x4       Addralign: 0x8          Entsize: 24
</span></span><span class=line><span class=cl>    [  0 ] Name:                                        Info: 0x00 (Bind: 0x0 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>    [  1 ] Name: main.c                                 Info: 0x04 (Bind: 0x0 | Type: 0x4)      Other: 0x0      Shndx: 0xfff1   Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>    [  2 ] Name:                                        Info: 0x03 (Bind: 0x0 | Type: 0x3)      Other: 0x0      Shndx: 0x1      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>    [  3 ] Name:                                        Info: 0x03 (Bind: 0x0 | Type: 0x3)      Other: 0x0      Shndx: 0x5      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>    [  4 ] Name: main                                   Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0x1      Value: 0x000000000000   Size: 0x143
</span></span><span class=line><span class=cl>    [  5 ] Name: printf                                 Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>    [  6 ] Name: __isoc99_scanf                         Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>    [  7 ] Name: addFunc                                Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>    [  8 ] Name: subFunc                                Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>    [  9 ] Name: mulFunc                                Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>    [ 10 ] Name: divFunc                                Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>    [ 11 ] Name: puts                                   Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>    [ 12 ] Name: __stack_chk_fail                       Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span></code></pre></div><p>Just focus on the symbol for our case&mldr; index 3.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>[</span>  <span class=mi>3</span> <span class=p>]</span> <span class=nl>Name</span><span class=p>:</span>                                 <span class=cm>/* No name for symbol */</span>
</span></span><span class=line><span class=cl>        <span class=nl>Info</span><span class=p>:</span> <span class=mh>0x03</span> <span class=p>(</span><span class=nl>Bind</span><span class=p>:</span> <span class=mh>0x0</span> <span class=o>|</span> <span class=nl>Type</span><span class=p>:</span> <span class=mh>0x3</span><span class=p>)</span>   <span class=cm>/* Bind: STB_LOCAL | Type: STT_SECTION */</span>
</span></span><span class=line><span class=cl>        <span class=nl>Other</span><span class=p>:</span> <span class=mh>0x0</span>                           <span class=cm>/* default visibility */</span>
</span></span><span class=line><span class=cl>        <span class=nl>Shndx</span><span class=p>:</span> <span class=mh>0x5</span>                           <span class=cm>/* section 5; .rodata in our case */</span>
</span></span><span class=line><span class=cl>        <span class=nl>Value</span><span class=p>:</span> <span class=mh>0x000000000000</span>                <span class=cm>/* no value; I wonder what could be the value for &#34;STT_SECTION&#34; type symbol */</span>
</span></span><span class=line><span class=cl>        <span class=nl>Size</span><span class=p>:</span> <span class=mh>0x0</span>                            <span class=cm>/* Unknown size */</span>
</span></span></code></pre></div><p>Putting all the pieces together, it&rsquo;s crystal clear now that this symbol is casually pointing towards <code>.rodata</code> section. Picture this section as a treasure trove of read-only data. An example? Think of it like a collection of strings that <code>printf</code> and its buddies use to sprinkle some magic onto your screen. It&rsquo;s like the VIP lounge for data that&rsquo;s there to be seen but not messed with.</p><p>looking back at our relocation entry, we can now understand it better</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[  0 ] Offset: 0x1a         Info: 0x000300000002 (Sym: 0x3 | Type: 0x2)     Addend: -4
</span></span></code></pre></div><ul><li>Apply relocation at offset <code>0x1a</code> in <code>.text</code> section.</li><li>Use symbol <code>3</code> for relocation&mldr; that points to <code>.rodata</code> section.</li><li>Relocation algorithm will be <code>R_X86_64_PC32</code> (<code>S + A - P</code>)</li></ul><p>There are many tools like <code>readelf</code> and <code>objdump</code>, that can show you relocation entries with all these things simplified.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>❯ readelf --relocs  --wide calc/main.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Relocation section &#39;.rela.text&#39; at offset 0x3e0 contains 13 entries:
</span></span><span class=line><span class=cl>    Offset             Info             Type               Symbol&#39;s Value  Symbol&#39;s Name + Addend
</span></span><span class=line><span class=cl>000000000000001a  0000000300000002 R_X86_64_PC32          0000000000000000 .rodata - 4
</span></span><span class=line><span class=cl>0000000000000027  0000000500000004 R_X86_64_PLT32         0000000000000000 printf - 4
</span></span><span class=line><span class=cl>000000000000003d  0000000300000002 R_X86_64_PC32          0000000000000000 .rodata + 15
</span></span><span class=line><span class=cl>000000000000004a  0000000600000004 R_X86_64_PLT32         0000000000000000 __isoc99_scanf - 4
</span></span><span class=line><span class=cl>0000000000000087  0000000700000004 R_X86_64_PLT32         0000000000000000 addFunc - 4
</span></span><span class=line><span class=cl>00000000000000a4  0000000800000004 R_X86_64_PLT32         0000000000000000 subFunc - 4
</span></span><span class=line><span class=cl>00000000000000c1  0000000900000004 R_X86_64_PLT32         0000000000000000 mulFunc - 4
</span></span><span class=line><span class=cl>00000000000000de  0000000a00000004 R_X86_64_PLT32         0000000000000000 divFunc - 4
</span></span><span class=line><span class=cl>00000000000000ee  0000000300000002 R_X86_64_PC32          0000000000000000 .rodata + 1e
</span></span><span class=line><span class=cl>00000000000000f6  0000000b00000004 R_X86_64_PLT32         0000000000000000 puts - 4
</span></span><span class=line><span class=cl>0000000000000117  0000000300000002 R_X86_64_PC32          0000000000000000 .rodata + 2f
</span></span><span class=line><span class=cl>0000000000000124  0000000500000004 R_X86_64_PLT32         0000000000000000 printf - 4
</span></span><span class=line><span class=cl>000000000000013d  0000000c00000004 R_X86_64_PLT32         0000000000000000 __stack_chk_fail - 4
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>❯ objdump -M intel -dr calc/main.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>calc/main.o:     file format elf64-x86-64
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Disassembly of section .text:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0000000000000000 &lt;main&gt;:
</span></span><span class=line><span class=cl>   0:   55                      push   rbp
</span></span><span class=line><span class=cl>   1:   48 89 e5                mov    rbp,rsp
</span></span><span class=line><span class=cl>   4:   48 83 ec 20             sub    rsp,0x20
</span></span><span class=line><span class=cl>   8:   64 48 8b 04 25 28 00    mov    rax,QWORD PTR fs:0x28
</span></span><span class=line><span class=cl>   f:   00 00
</span></span><span class=line><span class=cl>  11:   48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
</span></span><span class=line><span class=cl>  15:   31 c0                   xor    eax,eax
</span></span><span class=line><span class=cl>  17:   48 8d 05 00 00 00 00    lea    rax,[rip+0x0]        # 1e &lt;main+0x1e&gt;
</span></span><span class=line><span class=cl>                        1a: R_X86_64_PC32       .rodata-0x4
</span></span><span class=line><span class=cl>  1e:   48 89 c7                mov    rdi,rax
</span></span><span class=line><span class=cl>  21:   b8 00 00 00 00          mov    eax,0x0
</span></span><span class=line><span class=cl>  26:   e8 00 00 00 00          call   2b &lt;main+0x2b&gt;
</span></span><span class=line><span class=cl>                        27: R_X86_64_PLT32      printf-0x4
</span></span><span class=line><span class=cl>  2b:   48 8d 4d f0             lea    rcx,[rbp-0x10]
</span></span><span class=line><span class=cl>  2f:   48 8d 55 eb             lea    rdx,[rbp-0x15]
</span></span><span class=line><span class=cl>  33:   48 8d 45 ec             lea    rax,[rbp-0x14]
</span></span><span class=line><span class=cl>  37:   48 89 c6                mov    rsi,rax
</span></span><span class=line><span class=cl>  3a:   48 8d 05 00 00 00 00    lea    rax,[rip+0x0]        # 41 &lt;main+0x41&gt;
</span></span><span class=line><span class=cl>                        3d: R_X86_64_PC32       .rodata+0x15
</span></span><span class=line><span class=cl>  41:   48 89 c7                mov    rdi,rax
</span></span><span class=line><span class=cl>  44:   b8 00 00 00 00          mov    eax,0x0
</span></span><span class=line><span class=cl>  49:   e8 00 00 00 00          call   4e &lt;main+0x4e&gt;
</span></span><span class=line><span class=cl>                        4a: R_X86_64_PLT32      __isoc99_scanf-0x4
</span></span><span class=line><span class=cl>  4e:   0f b6 45 eb             movzx  eax,BYTE PTR [rbp-0x15]
</span></span><span class=line><span class=cl>  52:   0f be c0                movsx  eax,al
</span></span><span class=line><span class=cl>  55:   83 f8 2f                cmp    eax,0x2f
</span></span><span class=line><span class=cl>  58:   74 74                   je     ce &lt;main+0xce&gt;
</span></span><span class=line><span class=cl>  5a:   83 f8 2f                cmp    eax,0x2f
</span></span><span class=line><span class=cl>  5d:   0f 8f 88 00 00 00       jg     eb &lt;main+0xeb&gt;
</span></span><span class=line><span class=cl>  63:   83 f8 2d                cmp    eax,0x2d
</span></span><span class=line><span class=cl>  66:   74 2c                   je     94 &lt;main+0x94&gt;
</span></span><span class=line><span class=cl>  68:   83 f8 2d                cmp    eax,0x2d
</span></span><span class=line><span class=cl>  6b:   7f 7e                   jg     eb &lt;main+0xeb&gt;
</span></span><span class=line><span class=cl>  6d:   83 f8 2a                cmp    eax,0x2a
</span></span><span class=line><span class=cl>  70:   74 3f                   je     b1 &lt;main+0xb1&gt;
</span></span><span class=line><span class=cl>  72:   83 f8 2b                cmp    eax,0x2b
</span></span><span class=line><span class=cl>  75:   75 74                   jne    eb &lt;main+0xeb&gt;
</span></span><span class=line><span class=cl>  77:   f3 0f 10 45 f0          movss  xmm0,DWORD PTR [rbp-0x10]
</span></span><span class=line><span class=cl>  7c:   8b 45 ec                mov    eax,DWORD PTR [rbp-0x14]
</span></span><span class=line><span class=cl>  7f:   0f 28 c8                movaps xmm1,xmm0
</span></span><span class=line><span class=cl>  82:   66 0f 6e c0             movd   xmm0,eax
</span></span><span class=line><span class=cl>  86:   e8 00 00 00 00          call   8b &lt;main+0x8b&gt;
</span></span><span class=line><span class=cl>                        87: R_X86_64_PLT32      addFunc-0x4
</span></span><span class=line><span class=cl>  8b:   66 0f 7e c0             movd   eax,xmm0
</span></span><span class=line><span class=cl>  8f:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
</span></span><span class=line><span class=cl>  92:   eb 6d                   jmp    101 &lt;main+0x101&gt;
</span></span><span class=line><span class=cl>  94:   f3 0f 10 45 f0          movss  xmm0,DWORD PTR [rbp-0x10]
</span></span><span class=line><span class=cl>  99:   8b 45 ec                mov    eax,DWORD PTR [rbp-0x14]
</span></span><span class=line><span class=cl>  9c:   0f 28 c8                movaps xmm1,xmm0
</span></span><span class=line><span class=cl>  9f:   66 0f 6e c0             movd   xmm0,eax
</span></span><span class=line><span class=cl>  a3:   e8 00 00 00 00          call   a8 &lt;main+0xa8&gt;
</span></span><span class=line><span class=cl>                        a4: R_X86_64_PLT32      subFunc-0x4
</span></span><span class=line><span class=cl>  a8:   66 0f 7e c0             movd   eax,xmm0
</span></span><span class=line><span class=cl>  ac:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
</span></span><span class=line><span class=cl>  af:   eb 50                   jmp    101 &lt;main+0x101&gt;
</span></span><span class=line><span class=cl>  b1:   f3 0f 10 45 f0          movss  xmm0,DWORD PTR [rbp-0x10]
</span></span><span class=line><span class=cl>  b6:   8b 45 ec                mov    eax,DWORD PTR [rbp-0x14]
</span></span><span class=line><span class=cl>  b9:   0f 28 c8                movaps xmm1,xmm0
</span></span><span class=line><span class=cl>  bc:   66 0f 6e c0             movd   xmm0,eax
</span></span><span class=line><span class=cl>  c0:   e8 00 00 00 00          call   c5 &lt;main+0xc5&gt;
</span></span><span class=line><span class=cl>                        c1: R_X86_64_PLT32      mulFunc-0x4
</span></span><span class=line><span class=cl>  c5:   66 0f 7e c0             movd   eax,xmm0
</span></span><span class=line><span class=cl>  c9:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
</span></span><span class=line><span class=cl>  cc:   eb 33                   jmp    101 &lt;main+0x101&gt;
</span></span><span class=line><span class=cl>  ce:   f3 0f 10 45 f0          movss  xmm0,DWORD PTR [rbp-0x10]
</span></span><span class=line><span class=cl>  d3:   8b 45 ec                mov    eax,DWORD PTR [rbp-0x14]
</span></span><span class=line><span class=cl>  d6:   0f 28 c8                movaps xmm1,xmm0
</span></span><span class=line><span class=cl>  d9:   66 0f 6e c0             movd   xmm0,eax
</span></span><span class=line><span class=cl>  dd:   e8 00 00 00 00          call   e2 &lt;main+0xe2&gt;
</span></span><span class=line><span class=cl>                        de: R_X86_64_PLT32      divFunc-0x4
</span></span><span class=line><span class=cl>  e2:   66 0f 7e c0             movd   eax,xmm0
</span></span><span class=line><span class=cl>  e6:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
</span></span><span class=line><span class=cl>  e9:   eb 16                   jmp    101 &lt;main+0x101&gt;
</span></span><span class=line><span class=cl>  eb:   48 8d 05 00 00 00 00    lea    rax,[rip+0x0]        # f2 &lt;main+0xf2&gt;
</span></span><span class=line><span class=cl>                        ee: R_X86_64_PC32       .rodata+0x1e
</span></span><span class=line><span class=cl>  f2:   48 89 c7                mov    rdi,rax
</span></span><span class=line><span class=cl>  f5:   e8 00 00 00 00          call   fa &lt;main+0xfa&gt;
</span></span><span class=line><span class=cl>                        f6: R_X86_64_PLT32      puts-0x4
</span></span><span class=line><span class=cl>  fa:   b8 01 00 00 00          mov    eax,0x1
</span></span><span class=line><span class=cl>  ff:   eb 2c                   jmp    12d &lt;main+0x12d&gt;
</span></span><span class=line><span class=cl> 101:   66 0f ef d2             pxor   xmm2,xmm2
</span></span><span class=line><span class=cl> 105:   f3 0f 5a 55 f4          cvtss2sd xmm2,DWORD PTR [rbp-0xc]
</span></span><span class=line><span class=cl> 10a:   66 48 0f 7e d0          movq   rax,xmm2
</span></span><span class=line><span class=cl> 10f:   66 48 0f 6e c0          movq   xmm0,rax
</span></span><span class=line><span class=cl> 114:   48 8d 05 00 00 00 00    lea    rax,[rip+0x0]        # 11b &lt;main+0x11b&gt;
</span></span><span class=line><span class=cl>                        117: R_X86_64_PC32      .rodata+0x2f
</span></span><span class=line><span class=cl> 11b:   48 89 c7                mov    rdi,rax
</span></span><span class=line><span class=cl> 11e:   b8 01 00 00 00          mov    eax,0x1
</span></span><span class=line><span class=cl> 123:   e8 00 00 00 00          call   128 &lt;main+0x128&gt;
</span></span><span class=line><span class=cl>                        124: R_X86_64_PLT32     printf-0x4
</span></span><span class=line><span class=cl> 128:   b8 00 00 00 00          mov    eax,0x0
</span></span><span class=line><span class=cl> 12d:   48 8b 55 f8             mov    rdx,QWORD PTR [rbp-0x8]
</span></span><span class=line><span class=cl> 131:   64 48 2b 14 25 28 00    sub    rdx,QWORD PTR fs:0x28
</span></span><span class=line><span class=cl> 138:   00 00
</span></span><span class=line><span class=cl> 13a:   74 05                   je     141 &lt;main+0x141&gt;
</span></span><span class=line><span class=cl> 13c:   e8 00 00 00 00          call   141 &lt;main+0x141&gt;
</span></span><span class=line><span class=cl>                        13d: R_X86_64_PLT32     __stack_chk_fail-0x4
</span></span><span class=line><span class=cl> 141:   c9                      leave
</span></span><span class=line><span class=cl> 142:   c3                      ret
</span></span></code></pre></div><h2 id=conclustion>Conclustion<a hidden class=anchor aria-hidden=true href=#conclustion>#</a></h2><p>Throughout this article, we explored the significance of relocations in ELF binaries, examining how compilers, assemblers, and linkers collaborate to produce executable files. We delved into the role of relocation sections, uncovering their purpose in accommodating changes to addresses and offsets during both compile-time and link-time.</p><p>Since symbols and relocations combined are a huge topic in itself, I&rsquo;m adding few links that I think are interesting and will help to better grasp the whole concept in practicality</p><ul><li><p>@xianeizhang&rsquo;s notes (<a href=https://people.cs.pitt.edu/~xianeizhang/notes/Linking.html>https://people.cs.pitt.edu/~xianeizhang/notes/Linking.html</a>)</p></li><li><p>Understanding the ELF specimen (<a href=https://hub.packtpub.com/understanding-elf-specimen/>https://hub.packtpub.com/understanding-elf-specimen/</a>)</p></li><li><p>Cloudflare blogs on &ldquo;How to execute an object file&rdquo; - <a href=https://blog.cloudflare.com/how-to-execute-an-object-file-part-1/>part 1</a> and <a href=https://blog.cloudflare.com/how-to-execute-an-object-file-part-2/>part 2</a></p></li><li><p>An amazing talk by <a href=https://no.linkedin.com/in/anders-schau-knatten-34170619>@Anders Schau Knatten</a> on &ldquo;<a href="https://www.youtube.com/watch?v=iBQo962Sx0g">How symbols work and why we need them</a>&rdquo; (youtube)</p></li></ul><p>See you next time.</p><p><img loading=lazy src=https://media.giphy.com/media/xT1R9F8M2RGQtovtni/giphy.gif#center alt></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ayedaemon.github.io/tags/c/>C</a></li><li><a href=https://ayedaemon.github.io/tags/elf/>ELF</a></li><li><a href=https://ayedaemon.github.io/tags/re/>RE</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ayedaemon.github.io/>Connected</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>