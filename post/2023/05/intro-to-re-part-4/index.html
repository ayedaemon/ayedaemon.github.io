<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Intro to Re: C : part-4 | Connected</title><meta name=keywords content="RE,linux,C programming"><meta name=description content="Some things about process and stack memory"><meta name=author content="ayedaemon"><link rel=canonical href=https://ayedaemon.github.io/post/2023/05/intro-to-re-part-4/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ayedaemon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ayedaemon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ayedaemon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ayedaemon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ayedaemon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Intro to Re: C : part-4"><meta property="og:description" content="Some things about process and stack memory"><meta property="og:type" content="article"><meta property="og:url" content="https://ayedaemon.github.io/post/2023/05/intro-to-re-part-4/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-05-01T02:34:50+05:30"><meta property="article:modified_time" content="2023-07-16T23:46:07+05:30"><meta property="og:site_name" content="Connected"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/04/intro-to-re-simple-calculator/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/04/intro-to-re-part-3/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/03/intro-to-re-part-2/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2022/09/intro-to-re/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Intro to Re: C : part-4"><meta name=twitter:description content="Some things about process and stack memory"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ayedaemon.github.io/post/"},{"@type":"ListItem","position":2,"name":"Intro to Re: C : part-4","item":"https://ayedaemon.github.io/post/2023/05/intro-to-re-part-4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Intro to Re: C : part-4","name":"Intro to Re: C : part-4","description":"Some things about process and stack memory","keywords":["RE","linux","C programming"],"articleBody":"When an operating system (OS) runs a program, the program is first loaded into main memory. Memory is utilized for both program’s machine instructions and program’s data…this includes parameters, dynamic variables, (un)initialized variables, and so on.\nMost computers today use paged memory allocations, which allow the amount of memory assigned to a program to increase/decrease as the needs of the application change. Memory is allocated to the program and reclaimed by the operating system in fixed-size chunks known as pages. When a program is loaded into a paged-memory computer, the operating system initially allocates a small number of pages to the program and then allocates additional memory as needed.\nOn a linux machine you can check the memory layout of a running program using cat /proc//map.\n\u003e cat /proc/self/maps 55f5db535000-55f5db537000 r--p 00000000 08:02 917947 /usr/bin/cat 55f5db537000-55f5db53b000 r-xp 00002000 08:02 917947 /usr/bin/cat 55f5db53b000-55f5db53d000 r--p 00006000 08:02 917947 /usr/bin/cat 55f5db53d000-55f5db53e000 r--p 00007000 08:02 917947 /usr/bin/cat 55f5db53e000-55f5db53f000 rw-p 00008000 08:02 917947 /usr/bin/cat 55f5dd440000-55f5dd461000 rw-p 00000000 00:00 0 [heap] 7f0db2800000-7f0db2aea000 r--p 00000000 08:02 929341 /usr/lib/locale/locale-archive 7f0db2ba4000-7f0db2bc9000 rw-p 00000000 00:00 0 7f0db2bc9000-7f0db2beb000 r--p 00000000 08:02 923932 /usr/lib/libc.so.6 7f0db2beb000-7f0db2d45000 r-xp 00022000 08:02 923932 /usr/lib/libc.so.6 7f0db2d45000-7f0db2d9d000 r--p 0017c000 08:02 923932 /usr/lib/libc.so.6 7f0db2d9d000-7f0db2da1000 r--p 001d4000 08:02 923932 /usr/lib/libc.so.6 7f0db2da1000-7f0db2da3000 rw-p 001d8000 08:02 923932 /usr/lib/libc.so.6 7f0db2da3000-7f0db2db2000 rw-p 00000000 00:00 0 7f0db2dd0000-7f0db2dd1000 r--p 00000000 08:02 923793 /usr/lib/ld-linux-x86-64.so.2 7f0db2dd1000-7f0db2df7000 r-xp 00001000 08:02 923793 /usr/lib/ld-linux-x86-64.so.2 7f0db2df7000-7f0db2e01000 r--p 00027000 08:02 923793 /usr/lib/ld-linux-x86-64.so.2 7f0db2e01000-7f0db2e03000 r--p 00031000 08:02 923793 /usr/lib/ld-linux-x86-64.so.2 7f0db2e03000-7f0db2e05000 rw-p 00033000 08:02 923793 /usr/lib/ld-linux-x86-64.so.2 7ffd55089000-7ffd550aa000 rw-p 00000000 00:00 0 [stack] 7ffd550f6000-7ffd550fa000 r--p 00000000 00:00 0 [vvar] 7ffd550fa000-7ffd550fc000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0 [vsyscall] When you read the contents of /proc/self/map, you will encounter multiple lines, with each line representing a separate memory mapping region. Each line contains various fields separated by whitespace, representing different attributes of the memory mapping. The common fields include:\nStart and End Addresses: The starting and ending virtual addresses of the memory mapping region. Permissions: The permissions assigned to the memory mapping, such as read, write, and execute. Offset: The offset in the file (if the mapping is backed by a file) or zero otherwise. Device and Inode: The device and inode number of the file backing the mapping. File descriptor: If the mapping is associated with a file opened by the process, the file descriptor number is mentioned in this field. Flags: Additional flags indicating special characteristics of the mapping. Inode and Path: The inode number and path of the file backing the mapping (if available). Memory layout of a process Memory space allocated to a running program/process is called process memory (AKA virtual memory). It allows multiple programs to run concurrently and provides each program with a dedicated and isolated memory space. The purpose of process memory is to facilitate the execution of programs by providing a private address space for each process, shielding them from interfering with one another.\nA typical memory layout consists of many segments.\nText segment (code segment) Initialized data segment (data segment) Uninitialized data segment (bss segment) Heap Stack Text segment (Code Segment) The code segment contains the executable instructions of the program. It is typically read-only and stores the program’s machine code instructions, constants, and literals.\nInitialized data segment (Data Segment) This segment contains initialized static variables like global variables and local static variables which have a defined value and can be modified.\nUninitialized data segment (BSS Segment) This segment contains uninitialized static data, both variables and constants. On most systems, kernel automatically zeros this segment.\nHeap This segment contains dynamically allocated memory. It is usually managed by malloc, calloc, realloc, free (and their sibling functions too). The heap segment is shared by all threads, shared libraries, and dynamically loaded modules in a process. Heap memory segment grows towards higher memory addresses.\nStack This region of memory is used for managing function calls and local variables. It is an essential part of the execution environment and plays a crucial role in program flow control.\nThis is typically located in higher parts of the memory and grows towards lower parts (towards heap memory). A stack pointer register keeps track of the top of the stack, this gets adjusted each time a new value is pushed to or poped from the stack.\nThis is what the whole memory layout looks like altogether, but in this article we are focusing mainly on stack segment.\nMore about stack (practical) Stack memory is organized into stack frames, each representing the activation record of a function call. A stack frame contains information such as function parameters, local variables, return addresses, and other metadata necessary for function execution.\nLet’s start with a simple example of function calls to understand how stack works.\n#include // Prints are garbage value from stack and returns the same. int func2() { int var2; printf(\"var2 (%p) = %d\\n\", \u0026var2, var2); return var2; } // Prints var1 value as 55 and returns it. int func1() { int var1 = 55; printf(\"var1 (%p) = %d\\n\", \u0026var1, var1); return var1; } // Main function int main() { // Calls both functions and stores their return values int v1 = func1(); int v2 = func2(); // Compares their return values and print message if(v1 == v2) printf(\"Both values are equal\\n\"); else printf(\"Both values are not equal\\n\"); return 10; } To get a better understanding for this, I’ll put this down in steps of what this program will do upon execution.\nCall func1(), get a return value and store that in v1 variable. Call func2(), get a return value and store that in v2 variable Compare both values and print appropriate message. That’s it. Quite straightforward, isn’t it?. Let’s see the output of this program before jumping to conclusions.\nvar1 (0x7ffeaf266d1c) = 55 var2 (0x7ffeaf266d1c) = 55 Both values are equal Both var1 and var2 have same values and infact have same memory addresses… even though they belong to different functions and have separate stack frame and everything.\nTo understand this we’ll have to go deeper with a debugger (I’m using GDB).\n\u003e\u003e\u003e disas main Dump of assembler code for function main: // Prologue 0x00000000000011a6 \u003c+0\u003e:\tpush rbp 0x00000000000011a7 \u003c+1\u003e:\tmov rbp,rsp // Creating space in stack for variables. 0x10 is 16 bytes (4 bytes for each int variable) // 4(v1) + 4(v2) + 8 (padding) 0x00000000000011aa \u003c+4\u003e:\tsub rsp,0x10 // Function call and store value in [rbp-0x4] 0x00000000000011ae \u003c+8\u003e:\tmov eax,0x0 0x00000000000011b3 \u003c+13\u003e:\tcall 0x1174 \u003cfunc1\u003e 0x00000000000011b8 \u003c+18\u003e:\tmov DWORD PTR [rbp-0x4],eax // Another function call and store value in [rbp-0x8] 0x00000000000011bb \u003c+21\u003e:\tmov eax,0x0 0x00000000000011c0 \u003c+26\u003e:\tcall 0x1149 \u003cfunc2\u003e 0x00000000000011c5 \u003c+31\u003e:\tmov DWORD PTR [rbp-0x8],eax // Compare values stored in [rbp-0x4] \u0026 [rbp-0x8] 0x00000000000011c8 \u003c+34\u003e:\tmov eax,DWORD PTR [rbp-0x4] 0x00000000000011cb \u003c+37\u003e:\tcmp eax,DWORD PTR [rbp-0x8] // if not equal then jump to 0x00000000000011ce \u003c+40\u003e:\tjne 0x11e1 \u003cmain+59\u003e // else print this message 0x00000000000011d0 \u003c+42\u003e:\tlea rax,[rip+0xe4d] # 0x2024 0x00000000000011d7 \u003c+49\u003e:\tmov rdi,rax 0x00000000000011da \u003c+52\u003e:\tcall 0x1030 \u003cputs@plt\u003e // And finally jump to (epilogue) 0x00000000000011df \u003c+57\u003e:\tjmp 0x11f0 \u003cmain+74\u003e // if comparision failed: land here and print this message 0x00000000000011e1 \u003c+59\u003e:\tlea rax,[rip+0xe52] # 0x203a 0x00000000000011e8 \u003c+66\u003e:\tmov rdi,rax 0x00000000000011eb \u003c+69\u003e:\tcall 0x1030 \u003cputs@plt\u003e // Finally epilogue - set return value and leave 0x00000000000011f0 \u003c+74\u003e:\tmov eax,0xa 0x00000000000011f5 \u003c+79\u003e:\tleave 0x00000000000011f6 \u003c+80\u003e:\tret End of assembler dump. In the disassembly code, the main function calls both the functions and stores their respective return values in [rbp-0x4] and [rbp-0x8] memory locations. Since these variables are specific to main function, they will be created in the stack memory (inside the stack frame for main function).\n\u003e\u003e\u003e disas func1 Dump of assembler code for function func1: // Prologue 0x0000000000001174 \u003c+0\u003e:\tpush rbp 0x0000000000001175 \u003c+1\u003e:\tmov rbp,rsp // Create memory for the variable -- 4(var1) + 12(padding) = 16 (0x10) 0x0000000000001178 \u003c+4\u003e:\tsub rsp,0x10 // Store 0x37(55) in [rbp-0x4] 0x000000000000117c \u003c+8\u003e:\tmov DWORD PTR [rbp-0x4],0x37 // Print this value with a specific message 0x0000000000001183 \u003c+15\u003e:\tmov edx,DWORD PTR [rbp-0x4] 0x0000000000001186 \u003c+18\u003e:\tlea rax,[rbp-0x4] 0x000000000000118a \u003c+22\u003e:\tmov rsi,rax 0x000000000000118d \u003c+25\u003e:\tlea rax,[rip+0xe80] # 0x2014 0x0000000000001194 \u003c+32\u003e:\tmov rdi,rax 0x0000000000001197 \u003c+35\u003e:\tmov eax,0x0 0x000000000000119c \u003c+40\u003e:\tcall 0x1040 \u003cprintf@plt\u003e // Epilogue: set this value as return value and leave 0x00000000000011a1 \u003c+45\u003e:\tmov eax,DWORD PTR [rbp-0x4] 0x00000000000011a4 \u003c+48\u003e:\tleave 0x00000000000011a5 \u003c+49\u003e:\tret End of assembler dump. The above function, when called, will create another stack frame just after the main function’s stack frame… and will create it’s local variables in that region.\nThis function will print the value of the local variable and then return back to the main function. This action will remove the stack frame created by resetting the stack pointer and base pointer register values… BUT the actual values stored in memory location is still not overwritten by anything. So technically, the values are still present there and can be accessed if the memory location can be pointed to.\n\u003e\u003e\u003e disas func2 Dump of assembler code for function func2: // Prologue 0x0000000000001149 \u003c+0\u003e:\tpush rbp 0x000000000000114a \u003c+1\u003e:\tmov rbp,rsp // Create memory for the variable -- 4(var2) + 12(padding) = 16 (0x10) 0x000000000000114d \u003c+4\u003e:\tsub rsp,0x10 // Print the value with a specific message 0x0000000000001151 \u003c+8\u003e:\tmov edx,DWORD PTR [rbp-0x4] 0x0000000000001154 \u003c+11\u003e:\tlea rax,[rbp-0x4] 0x0000000000001158 \u003c+15\u003e:\tmov rsi,rax 0x000000000000115b \u003c+18\u003e:\tlea rax,[rip+0xea2] # 0x2004 0x0000000000001162 \u003c+25\u003e:\tmov rdi,rax 0x0000000000001165 \u003c+28\u003e:\tmov eax,0x0 0x000000000000116a \u003c+33\u003e:\tcall 0x1040 \u003cprintf@plt\u003e // Epilogue: set this value as return value and leave 0x000000000000116f \u003c+38\u003e:\tmov eax,DWORD PTR [rbp-0x4] 0x0000000000001172 \u003c+41\u003e:\tleave 0x0000000000001173 \u003c+42\u003e:\tret End of assembler dump. After the func1 has returned, it’s time for func2 to create it’s own stack frame and it’s own local variables.\nCoincidently, the memory location used by func2 is exactly the same location that was used by func1 earlier. And on top of that, both functions have int type variables which means that the memory location used by var1 in func1 will be used by var2 in func2.\nStack frame for both functions will kind of overlap each other. That should explain why we we’re getting the same results and same memory locations in the program output earlier.\nThis theory should be enough to understand what’s going on…. But practical is more fun. Accept it!!\nI’m going to place some breakpoints in the code and check the status of the stack on each hit. For me, such interesting points are where new variables or function’s stack frame will be created. This will help me to analyze the change in stack as we go forward.\n(NOTE: Sometimes I over-use breakpoints. Don’t judge me :| )\n\u003e\u003e\u003e info break Num Type Disp Enb Address What // 0x5555555551a6 :\tpush rbp 1 breakpoint keep y 0x00005555555551a6 in main at func_calls.c:16 // 0x5555555551aa :\tsub rsp,0x10 2 breakpoint keep y 0x00005555555551aa in main at func_calls.c:16 // 0x5555555551b3 :\tcall 0x555555555174 3 breakpoint keep y 0x00005555555551b3 in main at func_calls.c:17 // 0x5555555551c0 :\tcall 0x555555555149 4 breakpoint keep y 0x00005555555551c0 in main at func_calls.c:18 // 0x5555555551f5 :\tleave 5 breakpoint keep y 0x00005555555551f5 in main at func_calls.c:26 // 0x555555555174 :\tpush rbp 6 breakpoint keep y 0x0000555555555174 in func1 at func_calls.c:9 // 0x555555555178 :\tsub rsp,0x10 7 breakpoint keep y 0x0000555555555178 in func1 at func_calls.c:9 // 0x5555555551a5 :\tret 8 breakpoint keep y 0x00005555555551a5 in func1 at func_calls.c:13 // 0x555555555149 :\tpush rbp 9 breakpoint keep y 0x0000555555555149 in func2 at func_calls.c:3 // 0x55555555514d :\tsub rsp,0x10 10 breakpoint keep y 0x000055555555514d in func2 at func_calls.c:3 // 0x555555555173 :\tret 11 breakpoint keep y 0x0000555555555173 in func2 at func_calls.c:7 I’ve set up 11 break points here which will help me check the change in stack during the execution of the program.\nAfter running the program in debugger, it’ll stop at the first break point which is just before the point where main function’s stack frame will begin.\n\u003e\u003e\u003e x/10xg $rsp 0x7fffffffe218:\t0x00007ffff7de0790\t0x00007fffffffe310 0x7fffffffe228:\t0x00005555555551a6\t0x0000000155554040 0x7fffffffe238:\t0x00007fffffffe328\t0x00007fffffffe328 0x7fffffffe248:\t0x86b5da47f7ba01f3\t0x0000000000000000 0x7fffffffe258:\t0x00007fffffffe338\t0x0000555555557dd8 Theoretically, we know if we step over another instruction, value from rbp will be stored in the stack. So let’s check the value of rbp right now and then monitor the stack (after stepping over) to see if it is the same value we are expecting it to be.\n// Check the base pointer before stepping over instruction \u003e\u003e\u003e p $rbp $1 = (void *) 0x1 // Check the next instruction to be executed \u003e\u003e\u003e x $rip =\u003e 0x5555555551a6 :\tpush rbp // Step over an instruction \u003e\u003e\u003e ni // Monitor stack \u003e\u003e\u003e x/10xg $rsp 0x7fffffffe210:\t0x0000000000000001\t0x00007ffff7de0790 0x7fffffffe220:\t0x00007fffffffe310\t0x00005555555551a6 0x7fffffffe230:\t0x0000000155554040\t0x00007fffffffe328 0x7fffffffe240:\t0x00007fffffffe328\t0x8f2aa2d53bd1951c 0x7fffffffe250:\t0x0000000000000000\t0x00007fffffffe338 Now our stack has a new item in it, that is rbp value. If you notice, previously the top of the stack was at 0x7fffffffe218, but after adding one item the top of stack is 0x7fffffffe210. It decreased, which indicates that stack grows downwards; towards lower memory addresses.\nThe stack does not change up until the breakpoint 2 on 0x5555555551aa :\tsub rsp,0x10… But on stepping another instruction, we can see a new space of 16 bytes in the stack.\n\u003e\u003e\u003e x/10xg $rsp 0x7fffffffe200:\t0x0000000000000000\t0x00007ffff7ffdab0 0x7fffffffe210:\t0x0000000000000001\t0x00007ffff7de0790 0x7fffffffe220:\t0x00007fffffffe310\t0x00005555555551a6 0x7fffffffe230:\t0x0000000155554040\t0x00007fffffffe328 0x7fffffffe240:\t0x00007fffffffe328\t0x8f2aa2d53bd1951c Before this, the stack pointer was on 0x7fffffffe210, now the stack pointer is on 0x7fffffffe200… so 0x7fffffffe210 - 0x7fffffffe200 = 0x10 (16). Simple maths!!\nWe just moved the stack pointer down to create space required, no cleaning was done… hence the stack is already filled with some garbage value that resided in the memory long before the stack occupied this new memory region.\nNow let’s call the function func1 and see what that function call will add to the stack.\n\u003e\u003e\u003e x/10xg $rsp 0x7fffffffe1f8:\t0x00005555555551b8\t0x0000000000000000 0x7fffffffe208:\t0x00007ffff7ffdab0\t0x0000000000000001 0x7fffffffe218:\t0x00007ffff7de0790\t0x00007fffffffe310 0x7fffffffe228:\t0x00005555555551a6\t0x0000000155554040 0x7fffffffe238:\t0x00007fffffffe328\t0x00007fffffffe328 Just after making the function call and before executing the first instruction of the func1, we have a new value in the stack. This new value is the return address for the main function, which will be used to continue execution after the func1 call is finished.\n\u003e\u003e\u003e x/i 0x00005555555551b8 0x5555555551b8 :\tmov DWORD PTR [rbp-0x4],eax (Note: if this value is somehow overwritten, we can make our function to return to another function or instruction. This is something which comes under a technique called Return Oriented Programming aka ROP.)\nAfter the first instruction of the func1 function, that is pushing the rbp on the stack, we can see an updated stack.\n\u003e\u003e\u003e x/10xg $rsp 0x7fffffffe1f0:\t0x00007fffffffe210\t0x00005555555551b8 0x7fffffffe200:\t0x0000000000000000\t0x00007ffff7ffdab0 0x7fffffffe210:\t0x0000000000000001\t0x00007ffff7de0790 0x7fffffffe220:\t0x00007fffffffe310\t0x00005555555551a6 0x7fffffffe230:\t0x0000000155554040\t0x00007fffffffe328 This points to the place where the main function’s base pointer is. Think this as a chain like connection which links to the next stop.\nNow after creating some space in this new stack frame for var1…. Stack looks like this. (Notice that the stack keeps on growing down, towards low memory regions.)\n\u003e\u003e\u003e x/10xg $rsp 0x7fffffffe1e0:\t0x0000000000000000\t0x0000000000000000 0x7fffffffe1f0:\t0x00007fffffffe210\t0x00005555555551b8 0x7fffffffe200:\t0x0000000000000000\t0x00007ffff7ffdab0 0x7fffffffe210:\t0x0000000000000001\t0x00007ffff7de0790 0x7fffffffe220:\t0x00007fffffffe310\t0x00005555555551a6 The leave instruction does a lot of the work. It copies the rbp to rsp and then restores the old rbp from the stack again.\nThis will move the base pointer back to 0x00007fffffffe210 and the stack pointer to 0x00007fffffffe1f8.\nThis instruction basically releases a stack frame set up by a function. That means now our new stack will look something like this.\n\u003e\u003e\u003e x/10xg $rsp 0x7fffffffe1f8:\t0x00005555555551b8\t0x0000000000000000 0x7fffffffe208:\t0x00007ffff7ffdab0\t0x0000000000000001 0x7fffffffe218:\t0x00007ffff7de0790\t0x00007fffffffe310 0x7fffffffe228:\t0x00005555555551a6\t0x0000000155554040 0x7fffffffe238:\t0x00007fffffffe328\t0x00007fffffffe328 The next ret statement will take off the top of the value from stack and move the instruction control to that memory location… that is, set the rip value to that memory location. This means that the next instruction to be executed will be which stores the eax (return value from the previous function call) into [rbp-0x4] location on stack.\n\u003e\u003e\u003e x/i 0x00005555555551b8 =\u003e 0x5555555551b8 :\tmov DWORD PTR [rbp-0x4],eax So when func1 returns back, our stack looks something like this.\n\u003e\u003e\u003e x/10xg $rsp 0x7fffffffe200:\t0x0000000000000000\t0x00007ffff7ffdab0 0x7fffffffe210:\t0x0000000000000001\t0x00007ffff7de0790 0x7fffffffe220:\t0x00007fffffffe310\t0x00005555555551a6 0x7fffffffe230:\t0x0000000155554040\t0x00007fffffffe328 0x7fffffffe240:\t0x00007fffffffe328\t0x42033bae0bc1441d Now for the next function func2, our stack is like this, just before the sub rsp,0x10 instruction. This instruction will create enough memory for the variables to be.\n\u003e\u003e\u003e x/10xg $rsp 0x7fffffffe1f0:\t0x00007fffffffe210\t0x00005555555551c5 0x7fffffffe200:\t0x0000000000000000\t0x00000037f7ffdab0 0x7fffffffe210:\t0x0000000000000001\t0x00007ffff7de0790 0x7fffffffe220:\t0x00007fffffffe310\t0x00005555555551a6 0x7fffffffe230:\t0x0000000155554040\t0x00007fffffffe328 Once the space in stack memory is created, the stack looks like this\n\u003e\u003e\u003e x/10xg $rsp 0x7fffffffe1e0:\t0x0000000000000000\t0x0000003700000000 0x7fffffffe1f0:\t0x00007fffffffe210\t0x00005555555551c5 0x7fffffffe200:\t0x0000000000000000\t0x00000037f7ffdab0 0x7fffffffe210:\t0x0000000000000001\t0x00007ffff7de0790 0x7fffffffe220:\t0x00007fffffffe310\t0x00005555555551a6 If you notice, these are the same memory locations which were used by func1 to store 0x37 (mov DWORD PTR [rbp-0x4],0x37)…. and since the stack is not cleaned properly, the value from that function is still in the place it was left to be picked by our variable var2.\nThis can be checked with x/w ($rbp-0x4)\n\u003e\u003e\u003e x/w ($rbp-0x4) 0x7fffffffe1ec:\t0x00000037 So the value is just as it was left by func1… :|\nNow after returning back to main function, the stack looks like this.\n\u003e\u003e\u003e x/10xg $rsp 0x7fffffffe200:\t0x0000000000000000\t0x0000003700000037 0x7fffffffe210:\t0x0000000000000001\t0x00007ffff7de0790 0x7fffffffe220:\t0x00007fffffffe310\t0x00005555555551a6 0x7fffffffe230:\t0x0000000155554040\t0x00007fffffffe328 0x7fffffffe240:\t0x00007fffffffe328\t0x42033bae0bc1441d And both v1 and v2, are same values and were picked from the same memory locations when in their respective function frames.\n\u003e\u003e\u003e x/w $rbp-0x4 0x7fffffffe20c:\t0x00000037 \u003e\u003e\u003e x/w $rbp-0x8 0x7fffffffe208:\t0x00000037 This explains the somewhat unusual behaviour of the program. There is nothing special about this, its just the way the stack memory works and a well crafted example presented to you.\nIn next article, I’ll try to cover stack overflows… which is a cool technique to insert the data in a variable which will overflow and overwrite the data for another variable. Try to think around this, if you may.\n","wordCount":"2938","inLanguage":"en","datePublished":"2023-05-01T02:34:50+05:30","dateModified":"2023-07-16T23:46:07+05:30","author":[{"@type":"Person","name":"ayedaemon"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://ayedaemon.github.io/post/2023/05/intro-to-re-part-4/"},"publisher":{"@type":"Organization","name":"Connected","logo":{"@type":"ImageObject","url":"https://ayedaemon.github.io/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://ayedaemon.github.io/ accesskey=h title="Connected (Alt + H)">Connected</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://ayedaemon.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://ayedaemon.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ayedaemon.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ayedaemon.github.io/series/ title=Series><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ayedaemon.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ayedaemon.github.io/post/>Posts</a></div><h1 class=post-title>Intro to Re: C : part-4</h1><div class=post-description>Some things about process and stack memory</div><div class=post-meta><span title='2023-05-01 02:34:50 +0530 IST'>May 1, 2023</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2938 words&nbsp;·&nbsp;ayedaemon&nbsp;|&nbsp;<a href=https://github.com/ayedaemon/ayedaemon.github.io/tree/main/content/post/2023/05/intro-to-re-part-4.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#memory-layout-of-a-process>Memory layout of a process</a><ul><li><a href=#text-segment-code-segment>Text segment (Code Segment)</a></li><li><a href=#initialized-data-segment-data-segment>Initialized data segment (Data Segment)</a></li><li><a href=#uninitialized-data-segment-bss-segment>Uninitialized data segment (BSS Segment)</a></li><li><a href=#heap>Heap</a></li><li><a href=#stack>Stack</a></li></ul></li><li><a href=#more-about-stack-practical>More about stack (practical)</a></li></ul></nav></div></details></div><div class=post-content><p>When an operating system (OS) runs a program, the program is first loaded into main memory. Memory is utilized for both program&rsquo;s machine instructions and program&rsquo;s data&mldr;this includes parameters, dynamic variables, (un)initialized variables, and so on.</p><p>Most computers today use paged memory allocations, which allow the amount of memory assigned to a program to increase/decrease as the needs of the application change. Memory is allocated to the program and reclaimed by the operating system in fixed-size chunks known as <code>pages</code>. When a program is loaded into a paged-memory computer, the operating system initially allocates a small number of pages to the program and then allocates additional memory as needed.</p><p>On a linux machine you can check the memory layout of a running program using <code>cat /proc/&lt;proc_id>/map</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; cat /proc/self/maps
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>55f5db535000-55f5db537000 r--p 00000000 08:02 917947                     /usr/bin/cat
</span></span><span class=line><span class=cl>55f5db537000-55f5db53b000 r-xp 00002000 08:02 917947                     /usr/bin/cat
</span></span><span class=line><span class=cl>55f5db53b000-55f5db53d000 r--p 00006000 08:02 917947                     /usr/bin/cat
</span></span><span class=line><span class=cl>55f5db53d000-55f5db53e000 r--p 00007000 08:02 917947                     /usr/bin/cat
</span></span><span class=line><span class=cl>55f5db53e000-55f5db53f000 rw-p 00008000 08:02 917947                     /usr/bin/cat
</span></span><span class=line><span class=cl>55f5dd440000-55f5dd461000 rw-p 00000000 00:00 0                          [heap]
</span></span><span class=line><span class=cl>7f0db2800000-7f0db2aea000 r--p 00000000 08:02 929341                     /usr/lib/locale/locale-archive
</span></span><span class=line><span class=cl>7f0db2ba4000-7f0db2bc9000 rw-p 00000000 00:00 0 
</span></span><span class=line><span class=cl>7f0db2bc9000-7f0db2beb000 r--p 00000000 08:02 923932                     /usr/lib/libc.so.6
</span></span><span class=line><span class=cl>7f0db2beb000-7f0db2d45000 r-xp 00022000 08:02 923932                     /usr/lib/libc.so.6
</span></span><span class=line><span class=cl>7f0db2d45000-7f0db2d9d000 r--p 0017c000 08:02 923932                     /usr/lib/libc.so.6
</span></span><span class=line><span class=cl>7f0db2d9d000-7f0db2da1000 r--p 001d4000 08:02 923932                     /usr/lib/libc.so.6
</span></span><span class=line><span class=cl>7f0db2da1000-7f0db2da3000 rw-p 001d8000 08:02 923932                     /usr/lib/libc.so.6
</span></span><span class=line><span class=cl>7f0db2da3000-7f0db2db2000 rw-p 00000000 00:00 0 
</span></span><span class=line><span class=cl>7f0db2dd0000-7f0db2dd1000 r--p 00000000 08:02 923793                     /usr/lib/ld-linux-x86-64.so.2
</span></span><span class=line><span class=cl>7f0db2dd1000-7f0db2df7000 r-xp 00001000 08:02 923793                     /usr/lib/ld-linux-x86-64.so.2
</span></span><span class=line><span class=cl>7f0db2df7000-7f0db2e01000 r--p 00027000 08:02 923793                     /usr/lib/ld-linux-x86-64.so.2
</span></span><span class=line><span class=cl>7f0db2e01000-7f0db2e03000 r--p 00031000 08:02 923793                     /usr/lib/ld-linux-x86-64.so.2
</span></span><span class=line><span class=cl>7f0db2e03000-7f0db2e05000 rw-p 00033000 08:02 923793                     /usr/lib/ld-linux-x86-64.so.2
</span></span><span class=line><span class=cl>7ffd55089000-7ffd550aa000 rw-p 00000000 00:00 0                          [stack]
</span></span><span class=line><span class=cl>7ffd550f6000-7ffd550fa000 r--p 00000000 00:00 0                          [vvar]
</span></span><span class=line><span class=cl>7ffd550fa000-7ffd550fc000 r-xp 00000000 00:00 0                          [vdso]
</span></span><span class=line><span class=cl>ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]
</span></span></code></pre></div><p>When you read the contents of <code>/proc/self/map</code>, you will encounter multiple lines, with each line representing a separate memory mapping region. Each line contains various fields separated by whitespace, representing different attributes of the memory mapping. The common fields include:</p><ul><li><strong>Start and End Addresses</strong>: The starting and ending virtual addresses of the memory mapping region.</li><li><strong>Permissions</strong>: The permissions assigned to the memory mapping, such as read, write, and execute.</li><li><strong>Offset</strong>: The offset in the file (if the mapping is backed by a file) or zero otherwise.</li><li><strong>Device and Inode</strong>: The device and inode number of the file backing the mapping.</li><li><strong>File descriptor</strong>: If the mapping is associated with a file opened by the process, the file descriptor number is mentioned in this field.</li><li><strong>Flags</strong>: Additional flags indicating special characteristics of the mapping.</li><li><strong>Inode and Path</strong>: The inode number and path of the file backing the mapping (if available).</li></ul><h2 id=memory-layout-of-a-process>Memory layout of a process<a hidden class=anchor aria-hidden=true href=#memory-layout-of-a-process>#</a></h2><p>Memory space allocated to a running program/process is called process memory (AKA virtual memory). It allows multiple programs to run concurrently and provides each program with a dedicated and isolated memory space. The purpose of process memory is to facilitate the execution of programs by providing a private address space for each process, shielding them from interfering with one another.</p><p>A typical memory layout consists of many segments.</p><ol><li>Text segment (code segment)</li><li>Initialized data segment (data segment)</li><li>Uninitialized data segment (bss segment)</li><li>Heap</li><li>Stack</li></ol><h3 id=text-segment-code-segment>Text segment (Code Segment)<a hidden class=anchor aria-hidden=true href=#text-segment-code-segment>#</a></h3><p>The code segment contains the executable instructions of the program. It is typically read-only and stores the program&rsquo;s machine code instructions, constants, and literals.</p><h3 id=initialized-data-segment-data-segment>Initialized data segment (Data Segment)<a hidden class=anchor aria-hidden=true href=#initialized-data-segment-data-segment>#</a></h3><p>This segment contains initialized static variables like global variables and local static variables which have a defined value and can be modified.</p><h3 id=uninitialized-data-segment-bss-segment>Uninitialized data segment (BSS Segment)<a hidden class=anchor aria-hidden=true href=#uninitialized-data-segment-bss-segment>#</a></h3><p>This segment contains uninitialized static data, both variables and constants. On most systems, kernel automatically zeros this segment.</p><h3 id=heap>Heap<a hidden class=anchor aria-hidden=true href=#heap>#</a></h3><p>This segment contains dynamically allocated memory. It is usually managed by malloc, calloc, realloc, free (and their sibling functions too). The heap segment is shared by all threads, shared libraries, and dynamically loaded modules in a process. Heap memory segment grows towards higher memory addresses.</p><h3 id=stack>Stack<a hidden class=anchor aria-hidden=true href=#stack>#</a></h3><p>This region of memory is used for managing function calls and local variables. It is an essential part of the execution environment and plays a crucial role in program flow control.</p><p>This is typically located in higher parts of the memory and grows towards lower parts (towards heap memory). A <strong>stack pointer</strong> register keeps track of the top of the stack, this gets adjusted each time a new value is pushed to or poped from the stack.</p><p><img loading=lazy src=https://upload.wikimedia.org/wikipedia/commons/thumb/5/50/Program_memory_layout.pdf/page1-225px-Program_memory_layout.pdf.jpg#center alt></p><p>This is what the whole memory layout looks like altogether, but in this article we are focusing mainly on stack segment.</p><h2 id=more-about-stack-practical>More about stack (practical)<a hidden class=anchor aria-hidden=true href=#more-about-stack-practical>#</a></h2><p>Stack memory is organized into stack frames, each representing the activation record of a function call. A stack frame contains information such as function parameters, local variables, return addresses, and other metadata necessary for function execution.</p><p>Let&rsquo;s start with a simple example of function calls to understand how stack works.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Prints are garbage value from stack and returns the same.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>func2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=kt>int</span> <span class=n>var2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;var2 (%p) = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>var2</span><span class=p>,</span> <span class=n>var2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=n>var2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Prints var1 value as 55 and returns it.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>func1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=kt>int</span> <span class=n>var1</span> <span class=o>=</span> <span class=mi>55</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;var1 (%p) = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>var1</span><span class=p>,</span> <span class=n>var1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=n>var1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Main function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Calls both functions and stores their return values
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=kt>int</span> <span class=n>v1</span> <span class=o>=</span> <span class=nf>func1</span><span class=p>();</span>
</span></span><span class=line><span class=cl>   <span class=kt>int</span> <span class=n>v2</span> <span class=o>=</span> <span class=nf>func2</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Compares their return values and print message
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>if</span><span class=p>(</span><span class=n>v1</span> <span class=o>==</span> <span class=n>v2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Both values are equal</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   <span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Both values are not equal</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To get a better understanding for this, I&rsquo;ll put this down in steps of what this program will do upon execution.</p><ol><li>Call <code>func1()</code>, get a return value and store that in <code>v1</code> variable.</li><li>Call <code>func2()</code>, get a return value and store that in <code>v2</code> variable</li><li>Compare both values and print appropriate message.</li></ol><p>That&rsquo;s it. Quite straightforward, isn&rsquo;t it?. Let&rsquo;s see the output of this program before jumping to conclusions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var1 (0x7ffeaf266d1c) = 55
</span></span><span class=line><span class=cl>var2 (0x7ffeaf266d1c) = 55
</span></span><span class=line><span class=cl>Both values are equal
</span></span></code></pre></div><p><img loading=lazy src=https://media.giphy.com/media/edGzBC6GDOhutW32ps/giphy.gif#center alt></p><p>Both <code>var1</code> and <code>var2</code> have same values and infact have same memory addresses&mldr; even though they belong to different functions and have separate stack frame and everything.</p><p>To understand this we&rsquo;ll have to go deeper with a debugger (I&rsquo;m using GDB).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>disas</span> <span class=n>main</span>
</span></span><span class=line><span class=cl><span class=n>Dump</span> <span class=n>of</span> <span class=n>assembler</span> <span class=n>code</span> <span class=k>for</span> <span class=n>function</span> <span class=nl>main</span><span class=p>:</span>
</span></span><span class=line><span class=cl>   <span class=c1>// Prologue
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x00000000000011a6</span> <span class=o>&lt;+</span><span class=mi>0</span><span class=o>&gt;:</span>	    <span class=n>push</span>   <span class=n>rbp</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x00000000000011a7</span> <span class=o>&lt;+</span><span class=mi>1</span><span class=o>&gt;:</span>	    <span class=n>mov</span>    <span class=n>rbp</span><span class=p>,</span><span class=n>rsp</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>   <span class=c1>// Creating space in stack for variables. 0x10 is 16 bytes (4 bytes for each int variable)
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=c1>// 4(v1) + 4(v2) + 8 (padding)
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x00000000000011aa</span> <span class=o>&lt;+</span><span class=mi>4</span><span class=o>&gt;:</span>	    <span class=n>sub</span>    <span class=n>rsp</span><span class=p>,</span><span class=mh>0x10</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>   <span class=c1>// Function call and store value in [rbp-0x4]
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x00000000000011ae</span> <span class=o>&lt;+</span><span class=mi>8</span><span class=o>&gt;:</span>	    <span class=n>mov</span>    <span class=n>eax</span><span class=p>,</span><span class=mh>0x0</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x00000000000011b3</span> <span class=o>&lt;+</span><span class=mi>13</span><span class=o>&gt;:</span>	<span class=n>call</span>   <span class=mh>0x1174</span> <span class=o>&lt;</span><span class=n>func1</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x00000000000011b8</span> <span class=o>&lt;+</span><span class=mi>18</span><span class=o>&gt;:</span>	<span class=n>mov</span>    <span class=n>DWORD</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rbp</span><span class=o>-</span><span class=mh>0x4</span><span class=p>],</span><span class=n>eax</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>   <span class=c1>// Another function call and store value in [rbp-0x8]
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x00000000000011bb</span> <span class=o>&lt;+</span><span class=mi>21</span><span class=o>&gt;:</span>	<span class=n>mov</span>    <span class=n>eax</span><span class=p>,</span><span class=mh>0x0</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x00000000000011c0</span> <span class=o>&lt;+</span><span class=mi>26</span><span class=o>&gt;:</span>	<span class=n>call</span>   <span class=mh>0x1149</span> <span class=o>&lt;</span><span class=n>func2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x00000000000011c5</span> <span class=o>&lt;+</span><span class=mi>31</span><span class=o>&gt;:</span>	<span class=n>mov</span>    <span class=n>DWORD</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rbp</span><span class=o>-</span><span class=mh>0x8</span><span class=p>],</span><span class=n>eax</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>   <span class=c1>// Compare values stored in [rbp-0x4] &amp; [rbp-0x8]
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x00000000000011c8</span> <span class=o>&lt;+</span><span class=mi>34</span><span class=o>&gt;:</span>	<span class=n>mov</span>    <span class=n>eax</span><span class=p>,</span><span class=n>DWORD</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rbp</span><span class=o>-</span><span class=mh>0x4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x00000000000011cb</span> <span class=o>&lt;+</span><span class=mi>37</span><span class=o>&gt;:</span>	<span class=n>cmp</span>    <span class=n>eax</span><span class=p>,</span><span class=n>DWORD</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rbp</span><span class=o>-</span><span class=mh>0x8</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>   <span class=c1>// if not equal then jump to &lt;main+59&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x00000000000011ce</span> <span class=o>&lt;+</span><span class=mi>40</span><span class=o>&gt;:</span>	<span class=n>jne</span>    <span class=mh>0x11e1</span> <span class=o>&lt;</span><span class=n>main</span><span class=o>+</span><span class=mi>59</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>   <span class=c1>// else print this message
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x00000000000011d0</span> <span class=o>&lt;+</span><span class=mi>42</span><span class=o>&gt;:</span>	<span class=n>lea</span>    <span class=n>rax</span><span class=p>,[</span><span class=n>rip</span><span class=o>+</span><span class=mh>0xe4d</span><span class=p>]</span>        <span class=err>#</span> <span class=mh>0x2024</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x00000000000011d7</span> <span class=o>&lt;+</span><span class=mi>49</span><span class=o>&gt;:</span>	<span class=n>mov</span>    <span class=n>rdi</span><span class=p>,</span><span class=n>rax</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x00000000000011da</span> <span class=o>&lt;+</span><span class=mi>52</span><span class=o>&gt;:</span>	<span class=n>call</span>   <span class=mh>0x1030</span> <span class=o>&lt;</span><span class=n>puts</span><span class=err>@</span><span class=n>plt</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>   <span class=c1>// And finally jump to &lt;main+74&gt; (epilogue)
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x00000000000011df</span> <span class=o>&lt;+</span><span class=mi>57</span><span class=o>&gt;:</span>	<span class=n>jmp</span>    <span class=mh>0x11f0</span> <span class=o>&lt;</span><span class=n>main</span><span class=o>+</span><span class=mi>74</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>   <span class=c1>// if comparision failed: land here and print this message
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x00000000000011e1</span> <span class=o>&lt;+</span><span class=mi>59</span><span class=o>&gt;:</span>	<span class=n>lea</span>    <span class=n>rax</span><span class=p>,[</span><span class=n>rip</span><span class=o>+</span><span class=mh>0xe52</span><span class=p>]</span>        <span class=err>#</span> <span class=mh>0x203a</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x00000000000011e8</span> <span class=o>&lt;+</span><span class=mi>66</span><span class=o>&gt;:</span>	<span class=n>mov</span>    <span class=n>rdi</span><span class=p>,</span><span class=n>rax</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x00000000000011eb</span> <span class=o>&lt;+</span><span class=mi>69</span><span class=o>&gt;:</span>	<span class=n>call</span>   <span class=mh>0x1030</span> <span class=o>&lt;</span><span class=n>puts</span><span class=err>@</span><span class=n>plt</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>   <span class=c1>// Finally epilogue - set return value and leave
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x00000000000011f0</span> <span class=o>&lt;+</span><span class=mi>74</span><span class=o>&gt;:</span>	<span class=n>mov</span>    <span class=n>eax</span><span class=p>,</span><span class=mh>0xa</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x00000000000011f5</span> <span class=o>&lt;+</span><span class=mi>79</span><span class=o>&gt;:</span>	<span class=n>leave</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x00000000000011f6</span> <span class=o>&lt;+</span><span class=mi>80</span><span class=o>&gt;:</span>	<span class=n>ret</span>
</span></span><span class=line><span class=cl><span class=n>End</span> <span class=n>of</span> <span class=n>assembler</span> <span class=n>dump</span><span class=p>.</span>
</span></span></code></pre></div><p>In the disassembly code, the <code>main</code> function calls both the functions and stores their respective return values in <code>[rbp-0x4]</code> and <code>[rbp-0x8]</code> memory locations. Since these variables are specific to <code>main</code> function, they will be created in the stack memory (inside the stack frame for <code>main</code> function).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>disas</span> <span class=n>func1</span>
</span></span><span class=line><span class=cl><span class=n>Dump</span> <span class=n>of</span> <span class=n>assembler</span> <span class=n>code</span> <span class=k>for</span> <span class=n>function</span> <span class=nl>func1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>   <span class=c1>// Prologue
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x0000000000001174</span> <span class=o>&lt;+</span><span class=mi>0</span><span class=o>&gt;:</span>	    <span class=n>push</span>   <span class=n>rbp</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x0000000000001175</span> <span class=o>&lt;+</span><span class=mi>1</span><span class=o>&gt;:</span>	    <span class=n>mov</span>    <span class=n>rbp</span><span class=p>,</span><span class=n>rsp</span>
</span></span><span class=line><span class=cl>   <span class=c1>// Create memory for the variable -- 4(var1) + 12(padding) = 16 (0x10)
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x0000000000001178</span> <span class=o>&lt;+</span><span class=mi>4</span><span class=o>&gt;:</span>	    <span class=n>sub</span>    <span class=n>rsp</span><span class=p>,</span><span class=mh>0x10</span>
</span></span><span class=line><span class=cl>   <span class=c1>// Store 0x37(55) in [rbp-0x4]
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x000000000000117c</span> <span class=o>&lt;+</span><span class=mi>8</span><span class=o>&gt;:</span>	    <span class=n>mov</span>    <span class=n>DWORD</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rbp</span><span class=o>-</span><span class=mh>0x4</span><span class=p>],</span><span class=mh>0x37</span>
</span></span><span class=line><span class=cl>   <span class=c1>// Print this value with a specific message
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x0000000000001183</span> <span class=o>&lt;+</span><span class=mi>15</span><span class=o>&gt;:</span>	<span class=n>mov</span>    <span class=n>edx</span><span class=p>,</span><span class=n>DWORD</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rbp</span><span class=o>-</span><span class=mh>0x4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x0000000000001186</span> <span class=o>&lt;+</span><span class=mi>18</span><span class=o>&gt;:</span>	<span class=n>lea</span>    <span class=n>rax</span><span class=p>,[</span><span class=n>rbp</span><span class=o>-</span><span class=mh>0x4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x000000000000118a</span> <span class=o>&lt;+</span><span class=mi>22</span><span class=o>&gt;:</span>	<span class=n>mov</span>    <span class=n>rsi</span><span class=p>,</span><span class=n>rax</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x000000000000118d</span> <span class=o>&lt;+</span><span class=mi>25</span><span class=o>&gt;:</span>	<span class=n>lea</span>    <span class=n>rax</span><span class=p>,[</span><span class=n>rip</span><span class=o>+</span><span class=mh>0xe80</span><span class=p>]</span>        <span class=err>#</span> <span class=mh>0x2014</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x0000000000001194</span> <span class=o>&lt;+</span><span class=mi>32</span><span class=o>&gt;:</span>	<span class=n>mov</span>    <span class=n>rdi</span><span class=p>,</span><span class=n>rax</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x0000000000001197</span> <span class=o>&lt;+</span><span class=mi>35</span><span class=o>&gt;:</span>	<span class=n>mov</span>    <span class=n>eax</span><span class=p>,</span><span class=mh>0x0</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x000000000000119c</span> <span class=o>&lt;+</span><span class=mi>40</span><span class=o>&gt;:</span>	<span class=n>call</span>   <span class=mh>0x1040</span> <span class=o>&lt;</span><span class=n>printf</span><span class=err>@</span><span class=n>plt</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>   <span class=c1>// Epilogue: set this value as return value and leave
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x00000000000011a1</span> <span class=o>&lt;+</span><span class=mi>45</span><span class=o>&gt;:</span>	<span class=n>mov</span>    <span class=n>eax</span><span class=p>,</span><span class=n>DWORD</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rbp</span><span class=o>-</span><span class=mh>0x4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x00000000000011a4</span> <span class=o>&lt;+</span><span class=mi>48</span><span class=o>&gt;:</span>	<span class=n>leave</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x00000000000011a5</span> <span class=o>&lt;+</span><span class=mi>49</span><span class=o>&gt;:</span>	<span class=n>ret</span>
</span></span><span class=line><span class=cl><span class=n>End</span> <span class=n>of</span> <span class=n>assembler</span> <span class=n>dump</span><span class=p>.</span>
</span></span></code></pre></div><p>The above function, when called, will create another stack frame just after the main function&rsquo;s stack frame&mldr; and will create it&rsquo;s local variables in that region.</p><p>This function will print the value of the local variable and then return back to the main function. This action will remove the stack frame created by resetting the stack pointer and base pointer register values&mldr; BUT the actual values stored in memory location is still not overwritten by anything. So technically, the values are still present there and can be accessed if the memory location can be pointed to.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>disas</span> <span class=n>func2</span>
</span></span><span class=line><span class=cl><span class=n>Dump</span> <span class=n>of</span> <span class=n>assembler</span> <span class=n>code</span> <span class=k>for</span> <span class=n>function</span> <span class=nl>func2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>   <span class=c1>// Prologue
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x0000000000001149</span> <span class=o>&lt;+</span><span class=mi>0</span><span class=o>&gt;:</span>	    <span class=n>push</span>   <span class=n>rbp</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x000000000000114a</span> <span class=o>&lt;+</span><span class=mi>1</span><span class=o>&gt;:</span>	    <span class=n>mov</span>    <span class=n>rbp</span><span class=p>,</span><span class=n>rsp</span>
</span></span><span class=line><span class=cl>   <span class=c1>// Create memory for the variable -- 4(var2) + 12(padding) = 16 (0x10)
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x000000000000114d</span> <span class=o>&lt;+</span><span class=mi>4</span><span class=o>&gt;:</span>	    <span class=n>sub</span>    <span class=n>rsp</span><span class=p>,</span><span class=mh>0x10</span>
</span></span><span class=line><span class=cl>   <span class=c1>// Print the value with a specific message
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x0000000000001151</span> <span class=o>&lt;+</span><span class=mi>8</span><span class=o>&gt;:</span>	    <span class=n>mov</span>    <span class=n>edx</span><span class=p>,</span><span class=n>DWORD</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rbp</span><span class=o>-</span><span class=mh>0x4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x0000000000001154</span> <span class=o>&lt;+</span><span class=mi>11</span><span class=o>&gt;:</span>	<span class=n>lea</span>    <span class=n>rax</span><span class=p>,[</span><span class=n>rbp</span><span class=o>-</span><span class=mh>0x4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x0000000000001158</span> <span class=o>&lt;+</span><span class=mi>15</span><span class=o>&gt;:</span>	<span class=n>mov</span>    <span class=n>rsi</span><span class=p>,</span><span class=n>rax</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x000000000000115b</span> <span class=o>&lt;+</span><span class=mi>18</span><span class=o>&gt;:</span>	<span class=n>lea</span>    <span class=n>rax</span><span class=p>,[</span><span class=n>rip</span><span class=o>+</span><span class=mh>0xea2</span><span class=p>]</span>        <span class=err>#</span> <span class=mh>0x2004</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x0000000000001162</span> <span class=o>&lt;+</span><span class=mi>25</span><span class=o>&gt;:</span>	<span class=n>mov</span>    <span class=n>rdi</span><span class=p>,</span><span class=n>rax</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x0000000000001165</span> <span class=o>&lt;+</span><span class=mi>28</span><span class=o>&gt;:</span>	<span class=n>mov</span>    <span class=n>eax</span><span class=p>,</span><span class=mh>0x0</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x000000000000116a</span> <span class=o>&lt;+</span><span class=mi>33</span><span class=o>&gt;:</span>	<span class=n>call</span>   <span class=mh>0x1040</span> <span class=o>&lt;</span><span class=n>printf</span><span class=err>@</span><span class=n>plt</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>   <span class=c1>// Epilogue: set this value as return value and leave
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=mh>0x000000000000116f</span> <span class=o>&lt;+</span><span class=mi>38</span><span class=o>&gt;:</span>	<span class=n>mov</span>    <span class=n>eax</span><span class=p>,</span><span class=n>DWORD</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rbp</span><span class=o>-</span><span class=mh>0x4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x0000000000001172</span> <span class=o>&lt;+</span><span class=mi>41</span><span class=o>&gt;:</span>	<span class=n>leave</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x0000000000001173</span> <span class=o>&lt;+</span><span class=mi>42</span><span class=o>&gt;:</span>	<span class=n>ret</span>
</span></span><span class=line><span class=cl><span class=n>End</span> <span class=n>of</span> <span class=n>assembler</span> <span class=n>dump</span><span class=p>.</span>
</span></span></code></pre></div><p>After the <code>func1</code> has returned, it&rsquo;s time for <code>func2</code> to create it&rsquo;s own stack frame and it&rsquo;s own local variables.</p><p>Coincidently, the memory location used by <code>func2</code> is exactly the same location that was used by <code>func1</code> earlier. And on top of that, both functions have <code>int</code> type variables which means that the memory location used by <code>var1</code> in <code>func1</code> will be used by <code>var2</code> in <code>func2</code>.</p><p>Stack frame for both functions will <em>kind of</em> overlap each other. That should explain why we we&rsquo;re getting the same results and same memory locations in the program output earlier.</p><p>This theory should be enough to understand what&rsquo;s going on&mldr;. But practical is more fun. Accept it!!</p><p><img loading=lazy src=https://media.giphy.com/media/hu0tQXRqT06YOFvd8D/giphy.gif#center alt></p><p>I&rsquo;m going to place some breakpoints in the code and check the status of the stack on each hit. For me, such interesting points are where new variables or function&rsquo;s stack frame will be created. This will help me to analyze the change in stack as we go forward.</p><p>(<em><strong>NOTE</strong>: Sometimes I over-use breakpoints. Don&rsquo;t judge me :|</em> )</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>info</span> <span class=k>break</span>
</span></span><span class=line><span class=cl><span class=n>Num</span>     <span class=n>Type</span>           <span class=n>Disp</span> <span class=n>Enb</span> <span class=n>Address</span>            <span class=n>What</span>
</span></span><span class=line><span class=cl><span class=c1>// 0x5555555551a6 &lt;main+0&gt;:	    push   rbp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mi>1</span>       <span class=n>breakpoint</span>     <span class=n>keep</span> <span class=n>y</span>   <span class=mh>0x00005555555551a6</span> <span class=n>in</span> <span class=n>main</span> <span class=n>at</span> <span class=n>func_calls</span><span class=p>.</span><span class=nl>c</span><span class=p>:</span><span class=mi>16</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 0x5555555551aa &lt;main+4&gt;:	    sub    rsp,0x10
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mi>2</span>       <span class=n>breakpoint</span>     <span class=n>keep</span> <span class=n>y</span>   <span class=mh>0x00005555555551aa</span> <span class=n>in</span> <span class=n>main</span> <span class=n>at</span> <span class=n>func_calls</span><span class=p>.</span><span class=nl>c</span><span class=p>:</span><span class=mi>16</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 0x5555555551b3 &lt;main+13&gt;:	call   0x555555555174 &lt;func1&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mi>3</span>       <span class=n>breakpoint</span>     <span class=n>keep</span> <span class=n>y</span>   <span class=mh>0x00005555555551b3</span> <span class=n>in</span> <span class=n>main</span> <span class=n>at</span> <span class=n>func_calls</span><span class=p>.</span><span class=nl>c</span><span class=p>:</span><span class=mi>17</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 0x5555555551c0 &lt;main+26&gt;:	call   0x555555555149 &lt;func2&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mi>4</span>       <span class=n>breakpoint</span>     <span class=n>keep</span> <span class=n>y</span>   <span class=mh>0x00005555555551c0</span> <span class=n>in</span> <span class=n>main</span> <span class=n>at</span> <span class=n>func_calls</span><span class=p>.</span><span class=nl>c</span><span class=p>:</span><span class=mi>18</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 0x5555555551f5 &lt;main+79&gt;:	leave
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mi>5</span>       <span class=n>breakpoint</span>     <span class=n>keep</span> <span class=n>y</span>   <span class=mh>0x00005555555551f5</span> <span class=n>in</span> <span class=n>main</span> <span class=n>at</span> <span class=n>func_calls</span><span class=p>.</span><span class=nl>c</span><span class=p>:</span><span class=mi>26</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 0x555555555174 &lt;func1&gt;:	    push   rbp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mi>6</span>       <span class=n>breakpoint</span>     <span class=n>keep</span> <span class=n>y</span>   <span class=mh>0x0000555555555174</span> <span class=n>in</span> <span class=n>func1</span> <span class=n>at</span> <span class=n>func_calls</span><span class=p>.</span><span class=nl>c</span><span class=p>:</span><span class=mi>9</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 0x555555555178 &lt;func1+4&gt;:	sub    rsp,0x10
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mi>7</span>       <span class=n>breakpoint</span>     <span class=n>keep</span> <span class=n>y</span>   <span class=mh>0x0000555555555178</span> <span class=n>in</span> <span class=n>func1</span> <span class=n>at</span> <span class=n>func_calls</span><span class=p>.</span><span class=nl>c</span><span class=p>:</span><span class=mi>9</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 0x5555555551a5 &lt;func1+49&gt;:	ret
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mi>8</span>       <span class=n>breakpoint</span>     <span class=n>keep</span> <span class=n>y</span>   <span class=mh>0x00005555555551a5</span> <span class=n>in</span> <span class=n>func1</span> <span class=n>at</span> <span class=n>func_calls</span><span class=p>.</span><span class=nl>c</span><span class=p>:</span><span class=mi>13</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 0x555555555149 &lt;func2&gt;:	    push   rbp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mi>9</span>       <span class=n>breakpoint</span>     <span class=n>keep</span> <span class=n>y</span>   <span class=mh>0x0000555555555149</span> <span class=n>in</span> <span class=n>func2</span> <span class=n>at</span> <span class=n>func_calls</span><span class=p>.</span><span class=nl>c</span><span class=p>:</span><span class=mi>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 0x55555555514d &lt;func2+4&gt;:	sub    rsp,0x10
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mi>10</span>      <span class=n>breakpoint</span>     <span class=n>keep</span> <span class=n>y</span>   <span class=mh>0x000055555555514d</span> <span class=n>in</span> <span class=n>func2</span> <span class=n>at</span> <span class=n>func_calls</span><span class=p>.</span><span class=nl>c</span><span class=p>:</span><span class=mi>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 0x555555555173 &lt;func2+42&gt;:	ret
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mi>11</span>      <span class=n>breakpoint</span>     <span class=n>keep</span> <span class=n>y</span>   <span class=mh>0x0000555555555173</span> <span class=n>in</span> <span class=n>func2</span> <span class=n>at</span> <span class=n>func_calls</span><span class=p>.</span><span class=nl>c</span><span class=p>:</span><span class=mi>7</span>
</span></span></code></pre></div><p>I&rsquo;ve set up 11 break points here which will help me check the change in stack during the execution of the program.</p><p>After running the program in debugger, it&rsquo;ll stop at the first break point which is just before the point where <code>main</code> function&rsquo;s stack frame will begin.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt;&gt;&gt; x/10xg <span class=nv>$rsp</span>
</span></span><span class=line><span class=cl>0x7fffffffe218:	0x00007ffff7de0790	0x00007fffffffe310
</span></span><span class=line><span class=cl>0x7fffffffe228:	0x00005555555551a6	0x0000000155554040
</span></span><span class=line><span class=cl>0x7fffffffe238:	0x00007fffffffe328	0x00007fffffffe328
</span></span><span class=line><span class=cl>0x7fffffffe248:	0x86b5da47f7ba01f3	0x0000000000000000
</span></span><span class=line><span class=cl>0x7fffffffe258:	0x00007fffffffe338	0x0000555555557dd8
</span></span></code></pre></div><p>Theoretically, we know if we step over another instruction, value from <code>rbp</code> will be stored in the stack. So let&rsquo;s check the value of <code>rbp</code> right now and then monitor the stack (after stepping over) to see if it is the same value we are expecting it to be.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>// Check the base pointer before stepping over instruction
</span></span><span class=line><span class=cl>&gt;&gt;&gt; p <span class=nv>$rbp</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span> <span class=o>=</span> <span class=o>(</span>void *<span class=o>)</span> 0x1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// Check the next instruction to be executed
</span></span><span class=line><span class=cl>&gt;&gt;&gt; x <span class=nv>$rip</span>
</span></span><span class=line><span class=cl><span class=o>=</span>&gt; 0x5555555551a6 &lt;main&gt;:	push   rbp
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// Step over an instruction
</span></span><span class=line><span class=cl>&gt;&gt;&gt; ni
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// Monitor stack
</span></span><span class=line><span class=cl>&gt;&gt;&gt; x/10xg <span class=nv>$rsp</span>
</span></span><span class=line><span class=cl>0x7fffffffe210:	0x0000000000000001	0x00007ffff7de0790
</span></span><span class=line><span class=cl>0x7fffffffe220:	0x00007fffffffe310	0x00005555555551a6
</span></span><span class=line><span class=cl>0x7fffffffe230:	0x0000000155554040	0x00007fffffffe328
</span></span><span class=line><span class=cl>0x7fffffffe240:	0x00007fffffffe328	0x8f2aa2d53bd1951c
</span></span><span class=line><span class=cl>0x7fffffffe250:	0x0000000000000000	0x00007fffffffe338
</span></span></code></pre></div><p>Now our stack has a new item in it, that is <code>rbp</code> value. If you notice, previously the top of the stack was at <code>0x7fffffffe218</code>, but after adding one item the top of stack is <code>0x7fffffffe210</code>. It decreased, which indicates that stack grows downwards; towards lower memory addresses.</p><p>The stack does not change up until the breakpoint 2 on <code>0x5555555551aa &lt;main+4>: sub rsp,0x10</code>&mldr; But on stepping another instruction, we can see a new space of <strong>16 bytes</strong> in the stack.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt;&gt;&gt; x/10xg $rsp
</span></span><span class=line><span class=cl>0x7fffffffe200:	0x0000000000000000	0x00007ffff7ffdab0
</span></span><span class=line><span class=cl>0x7fffffffe210:	0x0000000000000001	0x00007ffff7de0790
</span></span><span class=line><span class=cl>0x7fffffffe220:	0x00007fffffffe310	0x00005555555551a6
</span></span><span class=line><span class=cl>0x7fffffffe230:	0x0000000155554040	0x00007fffffffe328
</span></span><span class=line><span class=cl>0x7fffffffe240:	0x00007fffffffe328	0x8f2aa2d53bd1951c
</span></span></code></pre></div><p>Before this, the stack pointer was on <code>0x7fffffffe210</code>, now the stack pointer is on <code>0x7fffffffe200</code>&mldr; so <code>0x7fffffffe210 - 0x7fffffffe200 = 0x10 (16)</code>. Simple maths!!</p><p>We just moved the stack pointer down to create space required, no cleaning was done&mldr; hence the stack is already filled with some garbage value that resided in the memory long before the stack occupied this new memory region.</p><p>Now let&rsquo;s call the function <code>func1</code> and see what that function call will add to the stack.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt;&gt;&gt; x/10xg $rsp
</span></span><span class=line><span class=cl>0x7fffffffe1f8:	0x00005555555551b8	0x0000000000000000
</span></span><span class=line><span class=cl>0x7fffffffe208:	0x00007ffff7ffdab0	0x0000000000000001
</span></span><span class=line><span class=cl>0x7fffffffe218:	0x00007ffff7de0790	0x00007fffffffe310
</span></span><span class=line><span class=cl>0x7fffffffe228:	0x00005555555551a6	0x0000000155554040
</span></span><span class=line><span class=cl>0x7fffffffe238:	0x00007fffffffe328	0x00007fffffffe328
</span></span></code></pre></div><p>Just after making the function call and before executing the first instruction of the <code>func1</code>, we have a new value in the stack. This new value is the return address for the main function, which will be used to continue execution after the func1 call is finished.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt;&gt;&gt; x/i 0x00005555555551b8
</span></span><span class=line><span class=cl>   0x5555555551b8 &lt;main+18&gt;:	mov    DWORD PTR [rbp-0x4],eax
</span></span></code></pre></div><p>(Note: if this value is somehow overwritten, we can make our function to return to another function or instruction. This is something which comes under a technique called Return Oriented Programming aka ROP.)</p><p>After the first instruction of the <code>func1</code> function, that is pushing the <code>rbp</code> on the stack, we can see an updated stack.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt;&gt;&gt; x/10xg $rsp
</span></span><span class=line><span class=cl>0x7fffffffe1f0:	0x00007fffffffe210	0x00005555555551b8
</span></span><span class=line><span class=cl>0x7fffffffe200:	0x0000000000000000	0x00007ffff7ffdab0
</span></span><span class=line><span class=cl>0x7fffffffe210:	0x0000000000000001	0x00007ffff7de0790
</span></span><span class=line><span class=cl>0x7fffffffe220:	0x00007fffffffe310	0x00005555555551a6
</span></span><span class=line><span class=cl>0x7fffffffe230:	0x0000000155554040	0x00007fffffffe328
</span></span></code></pre></div><p>This points to the place where the <code>main</code> function&rsquo;s <code>base pointer</code> is. Think this as a chain like connection which links to the next stop.</p><p>Now after creating some space in this new stack frame for <code>var1</code>&mldr;. Stack looks like this. (<em>Notice that the stack keeps on growing down, towards low memory regions.</em>)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt;&gt;&gt; x/10xg $rsp
</span></span><span class=line><span class=cl>0x7fffffffe1e0:	0x0000000000000000	0x0000000000000000
</span></span><span class=line><span class=cl>0x7fffffffe1f0:	0x00007fffffffe210	0x00005555555551b8
</span></span><span class=line><span class=cl>0x7fffffffe200:	0x0000000000000000	0x00007ffff7ffdab0
</span></span><span class=line><span class=cl>0x7fffffffe210:	0x0000000000000001	0x00007ffff7de0790
</span></span><span class=line><span class=cl>0x7fffffffe220:	0x00007fffffffe310	0x00005555555551a6
</span></span></code></pre></div><p>The <code>leave</code> instruction does a lot of the work. It copies the <code>rbp</code> to <code>rsp</code> and then restores the old <code>rbp</code> from the stack again.</p><p>This will move the base pointer back to <code>0x00007fffffffe210</code> and the stack pointer to <code>0x00007fffffffe1f8</code>.</p><p>This instruction basically releases a stack frame set up by a function. That means now our new stack will look something like this.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt;&gt;&gt; x/10xg $rsp
</span></span><span class=line><span class=cl>0x7fffffffe1f8:	0x00005555555551b8	0x0000000000000000
</span></span><span class=line><span class=cl>0x7fffffffe208:	0x00007ffff7ffdab0	0x0000000000000001
</span></span><span class=line><span class=cl>0x7fffffffe218:	0x00007ffff7de0790	0x00007fffffffe310
</span></span><span class=line><span class=cl>0x7fffffffe228:	0x00005555555551a6	0x0000000155554040
</span></span><span class=line><span class=cl>0x7fffffffe238:	0x00007fffffffe328	0x00007fffffffe328
</span></span></code></pre></div><p>The next <code>ret</code> statement will take off the top of the value from stack and move the instruction control to that memory location&mldr; that is, set the <code>rip</code> value to that memory location. This means that the next instruction to be executed will be &lt;main+18> which stores the <code>eax</code> (return value from the previous function call) into <code>[rbp-0x4]</code> location on stack.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt;&gt;&gt; x/i 0x00005555555551b8
</span></span><span class=line><span class=cl>=&gt; 0x5555555551b8 &lt;main+18&gt;:	mov    DWORD PTR [rbp-0x4],eax
</span></span></code></pre></div><p>So when <code>func1</code> returns back, our stack looks something like this.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt;&gt;&gt; x/10xg $rsp
</span></span><span class=line><span class=cl>0x7fffffffe200:	0x0000000000000000	0x00007ffff7ffdab0
</span></span><span class=line><span class=cl>0x7fffffffe210:	0x0000000000000001	0x00007ffff7de0790
</span></span><span class=line><span class=cl>0x7fffffffe220:	0x00007fffffffe310	0x00005555555551a6
</span></span><span class=line><span class=cl>0x7fffffffe230:	0x0000000155554040	0x00007fffffffe328
</span></span><span class=line><span class=cl>0x7fffffffe240:	0x00007fffffffe328	0x42033bae0bc1441d
</span></span></code></pre></div><p>Now for the next function <code>func2</code>, our stack is like this, just before the <code>sub rsp,0x10</code> instruction. This instruction will create enough memory for the variables to be.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt;&gt;&gt; x/10xg $rsp
</span></span><span class=line><span class=cl>0x7fffffffe1f0:	0x00007fffffffe210	0x00005555555551c5
</span></span><span class=line><span class=cl>0x7fffffffe200:	0x0000000000000000	0x00000037f7ffdab0
</span></span><span class=line><span class=cl>0x7fffffffe210:	0x0000000000000001	0x00007ffff7de0790
</span></span><span class=line><span class=cl>0x7fffffffe220:	0x00007fffffffe310	0x00005555555551a6
</span></span><span class=line><span class=cl>0x7fffffffe230:	0x0000000155554040	0x00007fffffffe328
</span></span></code></pre></div><p>Once the space in stack memory is created, the stack looks like this</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt;&gt;&gt; x/10xg $rsp
</span></span><span class=line><span class=cl>0x7fffffffe1e0:	0x0000000000000000	0x0000003700000000
</span></span><span class=line><span class=cl>0x7fffffffe1f0:	0x00007fffffffe210	0x00005555555551c5
</span></span><span class=line><span class=cl>0x7fffffffe200:	0x0000000000000000	0x00000037f7ffdab0
</span></span><span class=line><span class=cl>0x7fffffffe210:	0x0000000000000001	0x00007ffff7de0790
</span></span><span class=line><span class=cl>0x7fffffffe220:	0x00007fffffffe310	0x00005555555551a6
</span></span></code></pre></div><p>If you notice, these are the same memory locations which were used by <code>func1</code> to store <code>0x37</code> (<code>mov DWORD PTR [rbp-0x4],0x37</code>)&mldr;. and since the stack is not cleaned properly, the value from that function is still in the place it was left to be picked by our variable <code>var2</code>.</p><p>This can be checked with <code>x/w ($rbp-0x4)</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt;&gt;&gt; x/w ($rbp-0x4)
</span></span><span class=line><span class=cl>0x7fffffffe1ec:	0x00000037
</span></span></code></pre></div><p>So the value is just as it was left by <code>func1</code>&mldr; :|</p><p>Now after returning back to <code>main</code> function, the stack looks like this.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt;&gt;&gt; x/10xg $rsp
</span></span><span class=line><span class=cl>0x7fffffffe200:	0x0000000000000000	0x0000003700000037
</span></span><span class=line><span class=cl>0x7fffffffe210:	0x0000000000000001	0x00007ffff7de0790
</span></span><span class=line><span class=cl>0x7fffffffe220:	0x00007fffffffe310	0x00005555555551a6
</span></span><span class=line><span class=cl>0x7fffffffe230:	0x0000000155554040	0x00007fffffffe328
</span></span><span class=line><span class=cl>0x7fffffffe240:	0x00007fffffffe328	0x42033bae0bc1441d
</span></span></code></pre></div><p>And both <code>v1</code> and <code>v2</code>, are same values and were picked from the same memory locations when in their respective function frames.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt;&gt;&gt; x/w $rbp-0x4
</span></span><span class=line><span class=cl>0x7fffffffe20c:	0x00000037
</span></span><span class=line><span class=cl>&gt;&gt;&gt; x/w $rbp-0x8
</span></span><span class=line><span class=cl>0x7fffffffe208:	0x00000037
</span></span></code></pre></div><p><img loading=lazy src=https://media.giphy.com/media/3ohzdNuQy40h2dUCGI/giphy.gif#center alt></p><p>This explains the <em>somewhat</em> unusual behaviour of the program. There is nothing special about this, its just the way the stack memory works and a well crafted example presented to you.</p><p>In next article, I&rsquo;ll try to cover stack overflows&mldr; which is a cool technique to insert the data in a variable which will overflow and overwrite the data for another variable. Try to think around this, if you may.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ayedaemon.github.io/tags/re/>RE</a></li><li><a href=https://ayedaemon.github.io/tags/linux/>Linux</a></li><li><a href=https://ayedaemon.github.io/tags/c-programming/>C programming</a></li></ul><nav class=paginav><a class=prev href=https://ayedaemon.github.io/post/2023/10/elf-chronicles-elf-header/><span class=title>« Next</span><br><span>ELF Chronicles: ELF file Header</span></a>
<a class=next href=https://ayedaemon.github.io/post/2023/05/eudyptula-task-7/><span class=title>Prev »</span><br><span>Eudyptula Task 7</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://ayedaemon.github.io/>Connected</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>