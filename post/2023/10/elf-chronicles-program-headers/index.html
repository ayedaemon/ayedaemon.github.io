<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ELF Chronicles: Program Headers | Connected</title>
<meta name=keywords content="C,ELF,RE"><meta name=description content="Exploring ELF program Headers"><meta name=author content="ayedaemon"><link rel=canonical href=https://ayedaemon.github.io/post/2023/10/elf-chronicles-program-headers/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://ayedaemon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ayedaemon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ayedaemon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ayedaemon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ayedaemon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="ELF Chronicles: Program Headers"><meta property="og:description" content="Exploring ELF program Headers"><meta property="og:type" content="article"><meta property="og:url" content="https://ayedaemon.github.io/post/2023/10/elf-chronicles-program-headers/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-10-20T15:21:49+05:30"><meta property="article:modified_time" content="2023-11-07T00:16:06+05:30"><meta property="og:site_name" content="Connected"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/10/elf-chronicles-section-headers/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/10/elf-chronicles-elf-header/"><meta name=twitter:card content="summary"><meta name=twitter:title content="ELF Chronicles: Program Headers"><meta name=twitter:description content="Exploring ELF program Headers"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ayedaemon.github.io/post/"},{"@type":"ListItem","position":2,"name":"ELF Chronicles: Program Headers","item":"https://ayedaemon.github.io/post/2023/10/elf-chronicles-program-headers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ELF Chronicles: Program Headers","name":"ELF Chronicles: Program Headers","description":"Exploring ELF program Headers","keywords":["C","ELF","RE"],"articleBody":"In preceding articles, we’ve delved into the details of ELF file headers and section headers. Section headers provide insight into how data and instructions are organized based on their characteristics and grouped into distinct sections. These sections remain distinct due to variations in their types and permissions (… and few other things).\nUp to this point, our focus has been on the aspects of the ELF file as it resides on-disk. However, we now turn our attention to what occurs when the file is loaded into memory. How is its arrangement handled? Are all the sections loaded into memory?\nThis is where the concept of program headers comes into play. Program headers are similar to section headers, but instead of section information, they store segment information. A segment encompasses one or more sections from the ELF file. While program headers hold little significance while the file is on disk, they become imperative when the file needs to be loaded and executed in memory, specifically in the case of executables and shared objects.\nSome criteria for grouping sections to form segments can be:\nType and purpose of the sections (like .data and .bss), Memory Access Permissions and mapping, Alignment and Layout, Segment size constraints, OS and platform requirements, etc For this article, I’ll be using the same C code to generate an ELF file\n/* File: hello_world.c Compile: gcc hello_world.c -o hello_world */ #include // A macro #define HELLO_MSG1 \"Hello World1\" // A global variable char HELLO_MSG2[] = \"Hello World2\"; // main function int main() { // local variable for main char HELLO_MSG3[] = \"Hello World3\"; // Print messages printf(\"%s\\n\", HELLO_MSG1); printf(\"%s\\n\", HELLO_MSG2); printf(\"%s\\n\", HELLO_MSG3); return 0; } Once you have the ELF file, you can get the program header related information from ELF file headers - e_phoff, e_phentsize and e_phnum\nI’ll use readelf to get this information from the ELF headers. Feel free to use any method of your choice.\nELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Position-Independent Executable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x1040 Start of program headers: 64 (bytes into file) Start of section headers: 13496 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 13 Size of section headers: 64 (bytes) Number of section headers: 30 Section header string table index: 29 From the the output above, we can deduce that\nthe program headers are located at offset of 64 bytes, each of these header entries is 56 bytes in size, and in total, we’ve got 13 entries Now we can use xxd to get the data out\n❯ xxd -s 64 -l $(( 54*13 )) -c 54 build/hello 00000040: 0600 0000 0400 0000 4000 0000 0000 0000 4000 0000 0000 0000 4000 0000 0000 0000 d802 0000 0000 0000 d802 0000 0000 0000 0800 0000 0000 ........@.......@.......@............................. 00000076: 0000 0300 0000 0400 0000 1803 0000 0000 0000 1803 0000 0000 0000 1803 0000 0000 0000 1c00 0000 0000 0000 1c00 0000 0000 0000 0100 0000 ...................................................... 000000ac: 0000 0000 0100 0000 0400 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 3006 0000 0000 0000 3006 0000 0000 0000 0010 ....................................0.......0......... 000000e2: 0000 0000 0000 0100 0000 0500 0000 0010 0000 0000 0000 0010 0000 0000 0000 0010 0000 0000 0000 8901 0000 0000 0000 8901 0000 0000 0000 ...................................................... 00000118: 0010 0000 0000 0000 0100 0000 0400 0000 0020 0000 0000 0000 0020 0000 0000 0000 0020 0000 0000 0000 b400 0000 0000 0000 b400 0000 0000 ................. ....... ....... .................... 0000014e: 0000 0010 0000 0000 0000 0100 0000 0600 0000 d02d 0000 0000 0000 d03d 0000 0000 0000 d03d 0000 0000 0000 4802 0000 0000 0000 5002 0000 ...................-.......=.......=......H.......P... 00000184: 0000 0000 0010 0000 0000 0000 0200 0000 0600 0000 e02d 0000 0000 0000 e03d 0000 0000 0000 e03d 0000 0000 0000 e001 0000 0000 0000 e001 .....................-.......=.......=................ 000001ba: 0000 0000 0000 0800 0000 0000 0000 0400 0000 0400 0000 3803 0000 0000 0000 3803 0000 0000 0000 3803 0000 0000 0000 4000 0000 0000 0000 ......................8.......8.......8.......@....... 000001f0: 4000 0000 0000 0000 0800 0000 0000 0000 0400 0000 0400 0000 7803 0000 0000 0000 7803 0000 0000 0000 7803 0000 0000 0000 4400 0000 0000 @.......................x.......x.......x.......D..... 00000226: 0000 4400 0000 0000 0000 0400 0000 0000 0000 53e5 7464 0400 0000 3803 0000 0000 0000 3803 0000 0000 0000 3803 0000 0000 0000 4000 0000 ..D...............S.td....8.......8.......8.......@... 0000025c: 0000 0000 4000 0000 0000 0000 0800 0000 0000 0000 50e5 7464 0400 0000 1420 0000 0000 0000 1420 0000 0000 0000 1420 0000 0000 0000 2400 ....@...............P.td..... ....... ....... ......$. 00000292: 0000 0000 0000 2400 0000 0000 0000 0400 0000 0000 0000 51e5 7464 0600 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ......$...............Q.td............................ 000002c8: 0000 0000 0000 0000 0000 0000 0000 0000 1000 0000 0000 0000 52e5 7464 0400 0000 d02d 0000 0000 0000 d03d 0000 0000 0000 d03d 0000 0000 ........................R.td.....-.......=.......=.... Now we just have to map each of these lines to Elf64_Phdr (since we have a 64Bit file)\n/* https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/elf.h#L260 */ typedef struct elf64_phdr { Elf64_Word p_type; /* Segment type */ Elf64_Word p_flags; /* Segment flags */ Elf64_Off p_offset; /* Segment file offset */ Elf64_Addr p_vaddr; /* Segment virtual address */ Elf64_Addr p_paddr; /* Segment physical address */ Elf64_Xword p_filesz; /* Segment size in file */ Elf64_Xword p_memsz; /* Segment size in memory */ Elf64_Xword p_align; /* Segment alignment, file \u0026 memory */ } Elf64_Phdr; Using my nifty little parser, I got this digestible and user-friendly output for the above dump (Feel free to compare it)\n[ + ] Program headers begins at: 0x40 [ 00 ] Type: 0x6 Flags: 0x4 Offset: 0x0040 vaddr: 0x40 paddr: 0x40 filesz: 0x728 memsz: 0x728 align: 0x8 [ 01 ] Type: 0x3 Flags: 0x4 Offset: 0x0318 vaddr: 0x318 paddr: 0x318 filesz: 0x28 memsz: 0x28 align: 0x1 [ 02 ] Type: 0x1 Flags: 0x4 Offset: 0x0000 vaddr: 0x0 paddr: 0x0 filesz: 0x1584 memsz: 0x1584 align: 0x1000 [ 03 ] Type: 0x1 Flags: 0x5 Offset: 0x1000 vaddr: 0x1000 paddr: 0x1000 filesz: 0x393 memsz: 0x393 align: 0x1000 [ 04 ] Type: 0x1 Flags: 0x4 Offset: 0x2000 vaddr: 0x2000 paddr: 0x2000 filesz: 0x180 memsz: 0x180 align: 0x1000 [ 05 ] Type: 0x1 Flags: 0x6 Offset: 0x2dd0 vaddr: 0x3dd0 paddr: 0x3dd0 filesz: 0x584 memsz: 0x592 align: 0x1000 [ 06 ] Type: 0x2 Flags: 0x6 Offset: 0x2de0 vaddr: 0x3de0 paddr: 0x3de0 filesz: 0x480 memsz: 0x480 align: 0x8 [ 07 ] Type: 0x4 Flags: 0x4 Offset: 0x0338 vaddr: 0x338 paddr: 0x338 filesz: 0x64 memsz: 0x64 align: 0x8 [ 08 ] Type: 0x4 Flags: 0x4 Offset: 0x0378 vaddr: 0x378 paddr: 0x378 filesz: 0x68 memsz: 0x68 align: 0x4 [ 09 ] Type: 0xe553 Flags: 0x4 Offset: 0x0338 vaddr: 0x338 paddr: 0x338 filesz: 0x64 memsz: 0x64 align: 0x8 [ 10 ] Type: 0xe550 Flags: 0x4 Offset: 0x2014 vaddr: 0x2014 paddr: 0x2014 filesz: 0x36 memsz: 0x36 align: 0x4 [ 11 ] Type: 0xe551 Flags: 0x6 Offset: 0x0000 vaddr: 0x0 paddr: 0x0 filesz: 0x0 memsz: 0x0 align: 0x10 [ 12 ] Type: 0xe552 Flags: 0x4 Offset: 0x2dd0 vaddr: 0x3dd0 paddr: 0x3dd0 filesz: 0x560 memsz: 0x560 align: 0x1 Now, it’s time to take a deep dive into the inner workings of the Elf64_Phdr struct\n1. p_type Just like sh_type, this member tells the type of the segment. Whether the segment will be loaded in the memory or is it just used to store notes.\n/* https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/elf.h#L25 */ /* These constants are for the segment types stored in the image headers */ #define PT_NULL 0 #define PT_LOAD 1 #define PT_DYNAMIC 2 #define PT_INTERP 3 #define PT_NOTE 4 #define PT_SHLIB 5 #define PT_PHDR 6 #define PT_TLS 7 /* Thread local storage segment */ #define PT_LOOS 0x60000000 /* OS-specific */ #define PT_HIOS 0x6fffffff /* OS-specific */ #define PT_LOPROC 0x70000000 #define PT_HIPROC 0x7fffffff #define PT_GNU_EH_FRAME\t(PT_LOOS + 0x474e550) #define PT_GNU_STACK\t(PT_LOOS + 0x474e551) #define PT_GNU_RELRO\t(PT_LOOS + 0x474e552) #define PT_GNU_PROPERTY\t(PT_LOOS + 0x474e553) 2. p_flags This is quite similar to the the (r)ead, (w)rite and e(x)ecute permissions we are familiar with. This member specifies the permissions for the given segment.\nUsually the segment containing the .text section will have (r)ead and e(x)ecute permissions.\n/* https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/elf.h#L243 */ /* These constants define the permissions on sections in the program header, p_flags. */ #define PF_R 0x4 #define PF_W 0x2 #define PF_X 0x1 3. p_offset This holds the offset from the beginning of the file, where the first byte of the first section in this segment is located.\n4. p_vaddr This member holds the memory/virtual address for the segment.\n5. p_paddr This is same as p_vaddr, but holds the physical/on-disk address for the segment.\n6. p_filesz This holds the on-disk size (in bytes) of the segment.\n7. p_memsz This member holds the memory/virtual size (in bytes) of the segment.\n8. p_align This member holds the value to which the segments are aligned in memory and in the file.\nSimilar to sh_addralign, value of 0 and 1 are treated as “no alignment”, while the positive powers of 2 are taken as the actual alignment values.\nPracticals Let’s start with checking if strip command makes any change to the program headers.\nTry to write a program to parse the program headers and display the information in better way. Try to write a program that gives the information about what sections are grouped together in a segment. readelf gives this information in below format Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000040 0x0000000000000040 0x0000000000000040 0x0002d8 0x0002d8 R 0x8 INTERP 0x000318 0x0000000000000318 0x0000000000000318 0x00001c 0x00001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2 ] LOAD 0x000000 0x0000000000000000 0x0000000000000000 0x000630 0x000630 R 0x1000 LOAD 0x001000 0x0000000000001000 0x0000000000001000 0x000189 0x000189 R E 0x1000 LOAD 0x002000 0x0000000000002000 0x0000000000002000 0x0000b4 0x0000b4 R 0x1000 LOAD 0x002dd0 0x0000000000003dd0 0x0000000000003dd0 0x000248 0x000250 RW 0x1000 DYNAMIC 0x002de0 0x0000000000003de0 0x0000000000003de0 0x0001e0 0x0001e0 RW 0x8 NOTE 0x000338 0x0000000000000338 0x0000000000000338 0x000040 0x000040 R 0x8 NOTE 0x000378 0x0000000000000378 0x0000000000000378 0x000044 0x000044 R 0x4 GNU_PROPERTY 0x000338 0x0000000000000338 0x0000000000000338 0x000040 0x000040 R 0x8 GNU_EH_FRAME 0x002014 0x0000000000002014 0x0000000000002014 0x000024 0x000024 R 0x4 GNU_STACK 0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW 0x10 GNU_RELRO 0x002dd0 0x0000000000003dd0 0x0000000000003dd0 0x000230 0x000230 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 03 .init .plt .text .fini 04 .rodata .eh_frame_hdr .eh_frame 05 .init_array .fini_array .dynamic .got .got.plt .data .bss 06 .dynamic 07 .note.gnu.property 08 .note.gnu.build-id .note.ABI-tag 09 .note.gnu.property 10 .eh_frame_hdr 11 12 .init_array .fini_array .dynamic .got If you want to go extra mile and dig deep,\nTry overwriting the program interpreter with your custom loader program. Things will probably go wrong and then you can dig deep what’s the root cause. Add a new section (.text type), create it’s section header entry, then create it’s program header entry such that it is loadable in memory. Then change the ELF entrypoint to the newly created section. Conclusion Alright, buckle up, because we have just seen what segments are, how sections are grouped into segments, and how program headers act as a table to store information about segments which is helpful for runtime. Picture this -\n┌───────────────────────────┐ │ │ │ File Header │ │ │ │ │ ├───────────────────────────┤ │ │ │ Program Header │ │ │ │ │ ├───────────────────────────┤ ◄───┐ │ │ │ │ │ │ │ Section 1 │ │ │ │ │ ├───────────────────────────┤ │ Segment 1 │ Section 2 │ │ ├───────────────────────────┤ │ │ │ │ │ Section 3 │ │ ├───────────────────────────┤ ◄───┤ │ │ │ │ │ │ │ │ │ │ │ │ Segment 2 │ │ │ │ Section 4 │ │ │ │ │ │ │ ◄───┤ │ │ │ Segment 3 │ │ │ ├───────────────────────────┤ ◄───┤ │ │ │ │ │ │ │ Section 5 │ │ │ │ │ Segment 4 │ │ │ │ │ │ ├───────────────────────────┤ ◄───┤ │ │ │ │ │ │ │ Section 6 │ │ Segment 5 │ │ │ │ │ │ ├───────────────────────────┤ ◄───┘ │ │ │ │ │ Section Header │ │ │ │ │ └───────────────────────────┘ ","wordCount":"2040","inLanguage":"en","datePublished":"2023-10-20T15:21:49+05:30","dateModified":"2023-11-07T00:16:06+05:30","author":[{"@type":"Person","name":"ayedaemon"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://ayedaemon.github.io/post/2023/10/elf-chronicles-program-headers/"},"publisher":{"@type":"Organization","name":"Connected","logo":{"@type":"ImageObject","url":"https://ayedaemon.github.io/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://ayedaemon.github.io/ accesskey=h title="Connected (Alt + H)">Connected</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://ayedaemon.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://ayedaemon.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ayedaemon.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ayedaemon.github.io/series/ title=Series><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ayedaemon.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ayedaemon.github.io/post/>Posts</a></div><h1 class=post-title>ELF Chronicles: Program Headers</h1><div class=post-description>Exploring ELF program Headers</div><div class=post-meta><span title='2023-10-20 15:21:49 +0530 +0530'>October 20, 2023</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;2040 words&nbsp;·&nbsp;ayedaemon&nbsp;|&nbsp;<a href=https://github.com/ayedaemon/ayedaemon.github.io/tree/main/content/post/2023/10/elf-chronicles-program-headers.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#1-p_type>1. p_type</a></li><li><a href=#2-p_flags>2. p_flags</a></li><li><a href=#3-p_offset>3. p_offset</a></li><li><a href=#4-p_vaddr>4. p_vaddr</a></li><li><a href=#5-p_paddr>5. p_paddr</a></li><li><a href=#6-p_filesz>6. p_filesz</a></li><li><a href=#7-p_memsz>7. p_memsz</a></li><li><a href=#8-p_align>8. p_align</a></li></ul></li><li><a href=#practicals>Practicals</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p>In preceding articles, we&rsquo;ve delved into the details of ELF file headers and section headers. Section headers provide insight into how data and instructions are organized based on their characteristics and grouped into distinct sections. These sections remain distinct due to variations in their types and permissions (<em>&mldr; and few other things</em>).</p><p>Up to this point, our focus has been on the aspects of the ELF file as it resides on-disk. However, we now turn our attention to what occurs when the file is loaded into memory. How is its arrangement handled? Are all the sections loaded into memory?</p><p>This is where the concept of program headers comes into play. Program headers are similar to section headers, but instead of section information, they store segment information. A segment encompasses one or more sections from the ELF file. While program headers hold little significance while the file is on disk, they become imperative when the file needs to be loaded and executed in memory, specifically in the case of executables and shared objects.</p><p>Some criteria for grouping sections to form segments can be:</p><ul><li>Type and purpose of the sections (like <code>.data</code> and <code>.bss</code>),</li><li>Memory Access Permissions and mapping,</li><li>Alignment and Layout,</li><li>Segment size constraints,</li><li>OS and platform requirements, etc</li></ul><p>For this article, I&rsquo;ll be using the same C code to generate an ELF file</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>File: hello_world.c
</span></span></span><span class=line><span class=cl><span class=cm>Compile: gcc hello_world.c -o hello_world
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// A macro
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define HELLO_MSG1 &#34;Hello World1&#34;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// A global variable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>HELLO_MSG2</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Hello World2&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// main function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// local variable for main
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=n>HELLO_MSG3</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Hello World3&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Print messages
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>HELLO_MSG1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>HELLO_MSG2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>HELLO_MSG3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Once you have the ELF file, you can get the program header related information from ELF file headers - <code>e_phoff</code>, <code>e_phentsize</code> and <code>e_phnum</code></p><p>I&rsquo;ll use readelf to get this information from the ELF headers. Feel free to use any method of your choice.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ELF Header:
</span></span><span class=line><span class=cl>  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
</span></span><span class=line><span class=cl>  Class:                             ELF64
</span></span><span class=line><span class=cl>  Data:                              2&#39;s complement, little endian
</span></span><span class=line><span class=cl>  Version:                           1 (current)
</span></span><span class=line><span class=cl>  OS/ABI:                            UNIX - System V
</span></span><span class=line><span class=cl>  ABI Version:                       0
</span></span><span class=line><span class=cl>  Type:                              DYN (Position-Independent Executable file)
</span></span><span class=line><span class=cl>  Machine:                           Advanced Micro Devices X86-64
</span></span><span class=line><span class=cl>  Version:                           0x1
</span></span><span class=line><span class=cl>  Entry point address:               0x1040
</span></span><span class=line><span class=cl>  Start of program headers:          64 (bytes into file)
</span></span><span class=line><span class=cl>  Start of section headers:          13496 (bytes into file)
</span></span><span class=line><span class=cl>  Flags:                             0x0
</span></span><span class=line><span class=cl>  Size of this header:               64 (bytes)
</span></span><span class=line><span class=cl>  Size of program headers:           56 (bytes)
</span></span><span class=line><span class=cl>  Number of program headers:         13
</span></span><span class=line><span class=cl>  Size of section headers:           64 (bytes)
</span></span><span class=line><span class=cl>  Number of section headers:         30
</span></span><span class=line><span class=cl>  Section header string table index: 29
</span></span></code></pre></div><p>From the the output above, we can deduce that</p><ul><li>the program headers are located at offset of <code>64</code> bytes,</li><li>each of these header entries is <code>56</code> bytes in size,</li><li>and in total, we&rsquo;ve got <code>13</code> entries</li></ul><p>Now we can use xxd to get the data out</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>❯ xxd -s 64 -l $(( 54*13 )) -c 54 build/hello
</span></span><span class=line><span class=cl>00000040: 0600 0000 0400 0000 4000 0000 0000 0000 4000 0000 0000 0000 4000 0000 0000 0000 d802 0000 0000 0000 d802 0000 0000 0000 0800 0000 0000  ........@.......@.......@.............................
</span></span><span class=line><span class=cl>00000076: 0000 0300 0000 0400 0000 1803 0000 0000 0000 1803 0000 0000 0000 1803 0000 0000 0000 1c00 0000 0000 0000 1c00 0000 0000 0000 0100 0000  ......................................................
</span></span><span class=line><span class=cl>000000ac: 0000 0000 0100 0000 0400 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 3006 0000 0000 0000 3006 0000 0000 0000 0010  ....................................0.......0.........
</span></span><span class=line><span class=cl>000000e2: 0000 0000 0000 0100 0000 0500 0000 0010 0000 0000 0000 0010 0000 0000 0000 0010 0000 0000 0000 8901 0000 0000 0000 8901 0000 0000 0000  ......................................................
</span></span><span class=line><span class=cl>00000118: 0010 0000 0000 0000 0100 0000 0400 0000 0020 0000 0000 0000 0020 0000 0000 0000 0020 0000 0000 0000 b400 0000 0000 0000 b400 0000 0000  ................. ....... ....... ....................
</span></span><span class=line><span class=cl>0000014e: 0000 0010 0000 0000 0000 0100 0000 0600 0000 d02d 0000 0000 0000 d03d 0000 0000 0000 d03d 0000 0000 0000 4802 0000 0000 0000 5002 0000  ...................-.......=.......=......H.......P...
</span></span><span class=line><span class=cl>00000184: 0000 0000 0010 0000 0000 0000 0200 0000 0600 0000 e02d 0000 0000 0000 e03d 0000 0000 0000 e03d 0000 0000 0000 e001 0000 0000 0000 e001  .....................-.......=.......=................
</span></span><span class=line><span class=cl>000001ba: 0000 0000 0000 0800 0000 0000 0000 0400 0000 0400 0000 3803 0000 0000 0000 3803 0000 0000 0000 3803 0000 0000 0000 4000 0000 0000 0000  ......................8.......8.......8.......@.......
</span></span><span class=line><span class=cl>000001f0: 4000 0000 0000 0000 0800 0000 0000 0000 0400 0000 0400 0000 7803 0000 0000 0000 7803 0000 0000 0000 7803 0000 0000 0000 4400 0000 0000  @.......................x.......x.......x.......D.....
</span></span><span class=line><span class=cl>00000226: 0000 4400 0000 0000 0000 0400 0000 0000 0000 53e5 7464 0400 0000 3803 0000 0000 0000 3803 0000 0000 0000 3803 0000 0000 0000 4000 0000  ..D...............S.td....8.......8.......8.......@...
</span></span><span class=line><span class=cl>0000025c: 0000 0000 4000 0000 0000 0000 0800 0000 0000 0000 50e5 7464 0400 0000 1420 0000 0000 0000 1420 0000 0000 0000 1420 0000 0000 0000 2400  ....@...............P.td..... ....... ....... ......$.
</span></span><span class=line><span class=cl>00000292: 0000 0000 0000 2400 0000 0000 0000 0400 0000 0000 0000 51e5 7464 0600 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000  ......$...............Q.td............................
</span></span><span class=line><span class=cl>000002c8: 0000 0000 0000 0000 0000 0000 0000 0000 1000 0000 0000 0000 52e5 7464 0400 0000 d02d 0000 0000 0000 d03d 0000 0000 0000 d03d 0000 0000  ........................R.td.....-.......=.......=....
</span></span></code></pre></div><p>Now we just have to map each of these lines to <code>Elf64_Phdr</code> (since we have a 64Bit file)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/*
</span></span><span class=line><span class=cl>https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/elf.h#L260
</span></span><span class=line><span class=cl>*/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>typedef struct elf64_phdr {
</span></span><span class=line><span class=cl>  Elf64_Word p_type;      /* Segment type */
</span></span><span class=line><span class=cl>  Elf64_Word p_flags;     /* Segment flags */
</span></span><span class=line><span class=cl>  Elf64_Off p_offset;     /* Segment file offset */
</span></span><span class=line><span class=cl>  Elf64_Addr p_vaddr;     /* Segment virtual address */
</span></span><span class=line><span class=cl>  Elf64_Addr p_paddr;     /* Segment physical address */
</span></span><span class=line><span class=cl>  Elf64_Xword p_filesz;   /* Segment size in file */
</span></span><span class=line><span class=cl>  Elf64_Xword p_memsz;    /* Segment size in memory */
</span></span><span class=line><span class=cl>  Elf64_Xword p_align;    /* Segment alignment, file &amp; memory */
</span></span><span class=line><span class=cl>} Elf64_Phdr;
</span></span></code></pre></div><p>Using my nifty little parser, I got this digestible and user-friendly output for the above dump (Feel free to compare it)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[ + ] Program headers begins at: 0x40
</span></span><span class=line><span class=cl> [ 00 ] Type: 0x6        Flags: 0x4      Offset: 0x0040          vaddr: 0x40     paddr: 0x40     filesz: 0x728           memsz: 0x728            align: 0x8
</span></span><span class=line><span class=cl> [ 01 ] Type: 0x3        Flags: 0x4      Offset: 0x0318          vaddr: 0x318    paddr: 0x318    filesz: 0x28            memsz: 0x28             align: 0x1
</span></span><span class=line><span class=cl> [ 02 ] Type: 0x1        Flags: 0x4      Offset: 0x0000          vaddr: 0x0      paddr: 0x0      filesz: 0x1584          memsz: 0x1584           align: 0x1000
</span></span><span class=line><span class=cl> [ 03 ] Type: 0x1        Flags: 0x5      Offset: 0x1000          vaddr: 0x1000   paddr: 0x1000   filesz: 0x393           memsz: 0x393            align: 0x1000
</span></span><span class=line><span class=cl> [ 04 ] Type: 0x1        Flags: 0x4      Offset: 0x2000          vaddr: 0x2000   paddr: 0x2000   filesz: 0x180           memsz: 0x180            align: 0x1000
</span></span><span class=line><span class=cl> [ 05 ] Type: 0x1        Flags: 0x6      Offset: 0x2dd0          vaddr: 0x3dd0   paddr: 0x3dd0   filesz: 0x584           memsz: 0x592            align: 0x1000
</span></span><span class=line><span class=cl> [ 06 ] Type: 0x2        Flags: 0x6      Offset: 0x2de0          vaddr: 0x3de0   paddr: 0x3de0   filesz: 0x480           memsz: 0x480            align: 0x8
</span></span><span class=line><span class=cl> [ 07 ] Type: 0x4        Flags: 0x4      Offset: 0x0338          vaddr: 0x338    paddr: 0x338    filesz: 0x64            memsz: 0x64             align: 0x8
</span></span><span class=line><span class=cl> [ 08 ] Type: 0x4        Flags: 0x4      Offset: 0x0378          vaddr: 0x378    paddr: 0x378    filesz: 0x68            memsz: 0x68             align: 0x4
</span></span><span class=line><span class=cl> [ 09 ] Type: 0xe553     Flags: 0x4      Offset: 0x0338          vaddr: 0x338    paddr: 0x338    filesz: 0x64            memsz: 0x64             align: 0x8
</span></span><span class=line><span class=cl> [ 10 ] Type: 0xe550     Flags: 0x4      Offset: 0x2014          vaddr: 0x2014   paddr: 0x2014   filesz: 0x36            memsz: 0x36             align: 0x4
</span></span><span class=line><span class=cl> [ 11 ] Type: 0xe551     Flags: 0x6      Offset: 0x0000          vaddr: 0x0      paddr: 0x0      filesz: 0x0             memsz: 0x0              align: 0x10
</span></span><span class=line><span class=cl> [ 12 ] Type: 0xe552     Flags: 0x4      Offset: 0x2dd0          vaddr: 0x3dd0   paddr: 0x3dd0   filesz: 0x560           memsz: 0x560            align: 0x1
</span></span></code></pre></div><p>Now, it&rsquo;s time to take a deep dive into the inner workings of the <code>Elf64_Phdr</code> struct</p><h3 id=1-p_type>1. p_type<a hidden class=anchor aria-hidden=true href=#1-p_type>#</a></h3><p>Just like <code>sh_type</code>, this member tells the type of the segment. Whether the segment will be loaded in the memory or is it just used to store notes.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=o>/*</span>
</span></span><span class=line><span class=cl><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>elixir</span><span class=o>.</span><span class=n>bootlin</span><span class=o>.</span><span class=n>com</span><span class=o>/</span><span class=n>linux</span><span class=o>/</span><span class=n>latest</span><span class=o>/</span><span class=n>source</span><span class=o>/</span><span class=n>include</span><span class=o>/</span><span class=n>uapi</span><span class=o>/</span><span class=n>linux</span><span class=o>/</span><span class=n>elf</span><span class=o>.</span><span class=n>h</span><span class=c1>#L25</span>
</span></span><span class=line><span class=cl><span class=o>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>/*</span> <span class=n>These</span> <span class=n>constants</span> <span class=n>are</span> <span class=k>for</span> <span class=n>the</span> <span class=n>segment</span> <span class=n>types</span> <span class=n>stored</span> <span class=ow>in</span> <span class=n>the</span> <span class=n>image</span> <span class=n>headers</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl><span class=c1>#define PT_NULL    0</span>
</span></span><span class=line><span class=cl><span class=c1>#define PT_LOAD    1</span>
</span></span><span class=line><span class=cl><span class=c1>#define PT_DYNAMIC 2</span>
</span></span><span class=line><span class=cl><span class=c1>#define PT_INTERP  3</span>
</span></span><span class=line><span class=cl><span class=c1>#define PT_NOTE    4</span>
</span></span><span class=line><span class=cl><span class=c1>#define PT_SHLIB   5</span>
</span></span><span class=line><span class=cl><span class=c1>#define PT_PHDR    6</span>
</span></span><span class=line><span class=cl><span class=c1>#define PT_TLS     7               /* Thread local storage segment */</span>
</span></span><span class=line><span class=cl><span class=c1>#define PT_LOOS    0x60000000      /* OS-specific */</span>
</span></span><span class=line><span class=cl><span class=c1>#define PT_HIOS    0x6fffffff      /* OS-specific */</span>
</span></span><span class=line><span class=cl><span class=c1>#define PT_LOPROC  0x70000000</span>
</span></span><span class=line><span class=cl><span class=c1>#define PT_HIPROC  0x7fffffff</span>
</span></span><span class=line><span class=cl><span class=c1>#define PT_GNU_EH_FRAME	(PT_LOOS + 0x474e550)</span>
</span></span><span class=line><span class=cl><span class=c1>#define PT_GNU_STACK	(PT_LOOS + 0x474e551)</span>
</span></span><span class=line><span class=cl><span class=c1>#define PT_GNU_RELRO	(PT_LOOS + 0x474e552)</span>
</span></span><span class=line><span class=cl><span class=c1>#define PT_GNU_PROPERTY	(PT_LOOS + 0x474e553)</span>
</span></span></code></pre></div><h3 id=2-p_flags>2. p_flags<a hidden class=anchor aria-hidden=true href=#2-p_flags>#</a></h3><p>This is quite similar to the the <code>(r)ead</code>, <code>(w)rite</code> and <code>e(x)ecute</code> permissions we are familiar with. This member specifies the permissions for the given segment.</p><p>Usually the segment containing the <code>.text</code> section will have <code>(r)ead</code> and <code>e(x)ecute</code> permissions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=o>/*</span>
</span></span><span class=line><span class=cl><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>elixir</span><span class=o>.</span><span class=n>bootlin</span><span class=o>.</span><span class=n>com</span><span class=o>/</span><span class=n>linux</span><span class=o>/</span><span class=n>latest</span><span class=o>/</span><span class=n>source</span><span class=o>/</span><span class=n>include</span><span class=o>/</span><span class=n>uapi</span><span class=o>/</span><span class=n>linux</span><span class=o>/</span><span class=n>elf</span><span class=o>.</span><span class=n>h</span><span class=c1>#L243</span>
</span></span><span class=line><span class=cl><span class=o>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>/*</span> <span class=n>These</span> <span class=n>constants</span> <span class=n>define</span> <span class=n>the</span> <span class=n>permissions</span> <span class=n>on</span> <span class=n>sections</span> <span class=ow>in</span> <span class=n>the</span> <span class=n>program</span>
</span></span><span class=line><span class=cl>   <span class=n>header</span><span class=p>,</span> <span class=n>p_flags</span><span class=o>.</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#define PF_R    0x4</span>
</span></span><span class=line><span class=cl><span class=c1>#define PF_W    0x2</span>
</span></span><span class=line><span class=cl><span class=c1>#define PF_X    0x1</span>
</span></span></code></pre></div><h3 id=3-p_offset>3. p_offset<a hidden class=anchor aria-hidden=true href=#3-p_offset>#</a></h3><p>This holds the offset from the beginning of the file, where the first byte of the first section in this segment is located.</p><h3 id=4-p_vaddr>4. p_vaddr<a hidden class=anchor aria-hidden=true href=#4-p_vaddr>#</a></h3><p>This member holds the memory/virtual address for the segment.</p><h3 id=5-p_paddr>5. p_paddr<a hidden class=anchor aria-hidden=true href=#5-p_paddr>#</a></h3><p>This is same as <code>p_vaddr</code>, but holds the physical/on-disk address for the segment.</p><h3 id=6-p_filesz>6. p_filesz<a hidden class=anchor aria-hidden=true href=#6-p_filesz>#</a></h3><p>This holds the on-disk size (in bytes) of the segment.</p><h3 id=7-p_memsz>7. p_memsz<a hidden class=anchor aria-hidden=true href=#7-p_memsz>#</a></h3><p>This member holds the memory/virtual size (in bytes) of the segment.</p><h3 id=8-p_align>8. p_align<a hidden class=anchor aria-hidden=true href=#8-p_align>#</a></h3><p>This member holds the value to which the segments are aligned in memory and in the file.</p><p>Similar to <code>sh_addralign</code>, value of <code>0</code> and <code>1</code> are treated as &ldquo;no alignment&rdquo;, while the positive powers of <code>2</code> are taken as the actual alignment values.</p><h2 id=practicals>Practicals<a hidden class=anchor aria-hidden=true href=#practicals>#</a></h2><p>Let&rsquo;s start with checking if <code>strip</code> command makes any change to the program headers.</p><ul><li>Try to write a program to parse the program headers and display the information in better way.</li><li>Try to write a program that gives the information about what sections are grouped together in a segment. <code>readelf</code> gives this information in below format</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Program Headers:
</span></span><span class=line><span class=cl>  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align
</span></span><span class=line><span class=cl>  PHDR           0x000040 0x0000000000000040 0x0000000000000040 0x0002d8 0x0002d8 R   0x8
</span></span><span class=line><span class=cl>  INTERP         0x000318 0x0000000000000318 0x0000000000000318 0x00001c 0x00001c R   0x1
</span></span><span class=line><span class=cl>      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2 ]
</span></span><span class=line><span class=cl>  LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x000630 0x000630 R   0x1000
</span></span><span class=line><span class=cl>  LOAD           0x001000 0x0000000000001000 0x0000000000001000 0x000189 0x000189 R E 0x1000
</span></span><span class=line><span class=cl>  LOAD           0x002000 0x0000000000002000 0x0000000000002000 0x0000b4 0x0000b4 R   0x1000
</span></span><span class=line><span class=cl>  LOAD           0x002dd0 0x0000000000003dd0 0x0000000000003dd0 0x000248 0x000250 RW  0x1000
</span></span><span class=line><span class=cl>  DYNAMIC        0x002de0 0x0000000000003de0 0x0000000000003de0 0x0001e0 0x0001e0 RW  0x8
</span></span><span class=line><span class=cl>  NOTE           0x000338 0x0000000000000338 0x0000000000000338 0x000040 0x000040 R   0x8
</span></span><span class=line><span class=cl>  NOTE           0x000378 0x0000000000000378 0x0000000000000378 0x000044 0x000044 R   0x4
</span></span><span class=line><span class=cl>  GNU_PROPERTY   0x000338 0x0000000000000338 0x0000000000000338 0x000040 0x000040 R   0x8
</span></span><span class=line><span class=cl>  GNU_EH_FRAME   0x002014 0x0000000000002014 0x0000000000002014 0x000024 0x000024 R   0x4
</span></span><span class=line><span class=cl>  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10
</span></span><span class=line><span class=cl>  GNU_RELRO      0x002dd0 0x0000000000003dd0 0x0000000000003dd0 0x000230 0x000230 R   0x1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> Section to Segment mapping:
</span></span><span class=line><span class=cl>  Segment Sections...
</span></span><span class=line><span class=cl>   00
</span></span><span class=line><span class=cl>   01     .interp
</span></span><span class=line><span class=cl>   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt
</span></span><span class=line><span class=cl>   03     .init .plt .text .fini
</span></span><span class=line><span class=cl>   04     .rodata .eh_frame_hdr .eh_frame
</span></span><span class=line><span class=cl>   05     .init_array .fini_array .dynamic .got .got.plt .data .bss
</span></span><span class=line><span class=cl>   06     .dynamic
</span></span><span class=line><span class=cl>   07     .note.gnu.property
</span></span><span class=line><span class=cl>   08     .note.gnu.build-id .note.ABI-tag
</span></span><span class=line><span class=cl>   09     .note.gnu.property
</span></span><span class=line><span class=cl>   10     .eh_frame_hdr
</span></span><span class=line><span class=cl>   11
</span></span><span class=line><span class=cl>   12     .init_array .fini_array .dynamic .got
</span></span></code></pre></div><p>If you want to go extra mile and dig deep,</p><ul><li>Try overwriting the program interpreter with your custom loader program. Things will probably go wrong and then you can dig deep what&rsquo;s the root cause.</li><li>Add a new section (<code>.text</code> type), create it&rsquo;s section header entry, then create it&rsquo;s program header entry such that it is loadable in memory. Then change the ELF entrypoint to the newly created section.</li></ul><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Alright, buckle up, because we have just seen what segments are, how sections are grouped into segments, and how program headers act as a table to store information about segments which is helpful for runtime. Picture this -</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  ┌───────────────────────────┐
</span></span><span class=line><span class=cl>  │                           │
</span></span><span class=line><span class=cl>  │      File Header          │
</span></span><span class=line><span class=cl>  │                           │
</span></span><span class=line><span class=cl>  │                           │
</span></span><span class=line><span class=cl>  ├───────────────────────────┤
</span></span><span class=line><span class=cl>  │                           │
</span></span><span class=line><span class=cl>  │     Program Header        │
</span></span><span class=line><span class=cl>  │                           │
</span></span><span class=line><span class=cl>  │                           │
</span></span><span class=line><span class=cl>  ├───────────────────────────┤  ◄───┐
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  │      Section 1            │      │
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  ├───────────────────────────┤      │ Segment 1
</span></span><span class=line><span class=cl>  │      Section 2            │      │
</span></span><span class=line><span class=cl>  ├───────────────────────────┤      │
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  │      Section 3            │      │
</span></span><span class=line><span class=cl>  ├───────────────────────────┤  ◄───┤
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  │                           │      │ Segment 2
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  │      Section 4            │      │
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  │                           │  ◄───┤
</span></span><span class=line><span class=cl>  │                           │      │ Segment 3
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  ├───────────────────────────┤  ◄───┤
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  │      Section 5            │      │
</span></span><span class=line><span class=cl>  │                           │      │ Segment 4
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  ├───────────────────────────┤  ◄───┤
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  │     Section 6             │      │ Segment 5
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  │                           │      │
</span></span><span class=line><span class=cl>  ├───────────────────────────┤  ◄───┘
</span></span><span class=line><span class=cl>  │                           │
</span></span><span class=line><span class=cl>  │                           │
</span></span><span class=line><span class=cl>  │     Section Header        │
</span></span><span class=line><span class=cl>  │                           │
</span></span><span class=line><span class=cl>  │                           │
</span></span><span class=line><span class=cl>  └───────────────────────────┘
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ayedaemon.github.io/tags/c/>C</a></li><li><a href=https://ayedaemon.github.io/tags/elf/>ELF</a></li><li><a href=https://ayedaemon.github.io/tags/re/>RE</a></li></ul><nav class=paginav><a class=next href=https://ayedaemon.github.io/post/2023/10/elf-chronicles-section-headers/><span class=title>Prev »</span><br><span>ELF Chronicles: Section Headers</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://ayedaemon.github.io/>Connected</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>