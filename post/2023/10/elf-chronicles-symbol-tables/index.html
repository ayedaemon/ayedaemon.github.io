<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Elf Chronicles: Symbol Tables (5/?) | Connected</title>
<meta name=keywords content="C,ELF,RE"><meta name=description content="Exploring ELF symbol tables"><meta name=author content="ayedaemon"><link rel=canonical href=https://ayedaemon.github.io/post/2023/10/elf-chronicles-symbol-tables/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://ayedaemon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ayedaemon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ayedaemon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ayedaemon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ayedaemon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Elf Chronicles: Symbol Tables (5/?)"><meta property="og:description" content="Exploring ELF symbol tables"><meta property="og:type" content="article"><meta property="og:url" content="https://ayedaemon.github.io/post/2023/10/elf-chronicles-symbol-tables/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-10-29T22:15:08+05:30"><meta property="article:modified_time" content="2024-04-05T21:58:47+05:30"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2024/04/elf-chronicles-plt-got/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/12/elf-chronicles-relocations/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/10/elf-chronicles-string-tables/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/10/elf-chronicles-program-headers/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/10/elf-chronicles-section-headers/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Elf Chronicles: Symbol Tables (5/?)"><meta name=twitter:description content="Exploring ELF symbol tables"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ayedaemon.github.io/post/"},{"@type":"ListItem","position":2,"name":"Elf Chronicles: Symbol Tables (5/?)","item":"https://ayedaemon.github.io/post/2023/10/elf-chronicles-symbol-tables/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Elf Chronicles: Symbol Tables (5/?)","name":"Elf Chronicles: Symbol Tables (5\/?)","description":"Exploring ELF symbol tables","keywords":["C","ELF","RE"],"articleBody":"… prologue At this point I hope you have a general idea of how a C program goes through multiple stages/passes and finally an ELF file is generated. Below is a diagram to jog your memory on this\n┌──────────────────┐ │ │ │ hello.c │ // C source │ │ └────────┬─────────┘ │ │ │ /* Compile */ │ │ │ ▼ ┌──────────────────┐ │ │ │ hello.s │ // assembler source │ │ └────────┬─────────┘ │ │ │ /* assemble */ │ │ ▼ ┌──────────────────┐ │ │ │ hello.o │ // Assembled program (ELF - relocatable) │ │ └────────┬─────────┘ │ │ │ /* link */ │ │ ▼ ┌──────────────────┐ │ │ │ hello │ // Executable binary (ELF - executable) │ │ └──────────────────┘ Creating a simple hello program is very straight-forward, let me show you how this flow works when we are building something that has more than 1 source file. This is generally what most of the “real-world” projects do, they create multiple files with different functionalities and then merge them together to complete the program with the desired features only.\n┌────────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ │ │ │ │ libarithmatic.c │ │ libarithmatic.h ├───────► │ main.c │ │ │ │ │ │ │ └─────────┬──────────┘ └─────────────────┘ └────────┬────────┘ │ │ │ │ │ /* Compile + assemble */ │ /* Compile + assemble */ │ │ │ │ ▼ ▼ ┌─────────────────────┐ ┌────────────────────┐ │ │ │ │ │ libarithmatic.o │ │ main.o │ │ │ │ │ └─────────┬───────────┘ └──────────┬─────────┘ │ │ │ │ │ │ │ │ │ /* Linking Magic */ │ └───────────────────────────────────┬──────────────────────────────────────┘ │ │ │ │ │ │ ▼ ┌────────────────┐ │ │ │ calc │ │ │ └────────────────┘ /* File: libarithmatic.c */ float addFunc (float a, float b) { return a + b; } float subFunc (float a, float b) { return a - b; } float mulFunc (float a, float b) { return a * b; } float divFunc (float a, float b) { if (b == 0) { return 0.0; } return a / b; } /* File: libarithmatic.h */ #ifndef ARITHMATIC_H #define ARITHMATIC_H float addFunc (float, float); float subFunc (float, float); float mulFunc (float, float); float divFunc (float, float); float magicFunc (float a, float b); #endif /* File: main.c */ #include #include \"libarithmatic.h\" int main() { float num1, num2, result; char operator; printf(\"Enter equation (9 * 6): \"); scanf(\"%f %c %f\", \u0026num1, \u0026operator, \u0026num2); switch (operator) { case '+': result = addFunc(num1, num2); break; case '-': result = subFunc(num1, num2); break; case '*': result = mulFunc(num1, num2); break; case '/': result = divFunc(num1, num2); break; default: printf(\"Invalid operator\\n\"); return 1; } printf(\"Result: %.2f\\n\", result); return 0; } Luckily gcc provides some features, that helps us to make this process easier.\n❯ gcc --help Usage: gcc [options] file... Options: \u003c... OMITTED ...\u003e -E Preprocess only; do not compile, assemble or link. -S Compile only; do not assemble or link. -c Compile and assemble, but do not link. So if you follow these commands, you’ll be fine\n# Compile + assemble -\u003e generates main.o gcc -c main.c # Compile + assemble -\u003e generates libarithmatic.o gcc -c libarithmatic.c # Linking -\u003e generates calc gcc main.o libarithmatic.o -o calc This is our first time so far writing multiple files for a program. So let’s take a moment to understand how this works.\nFirst, we create a libarithmatic.c file with all of the required arithmatic functions - addFunc, subFunc, mulFunc, and divFunc. Since this file contains these functions (function definitions), the intermediate object file for this file will have related information as well.\nThen comes the main.c file, where we have declared the main function. Inside the main function, we have used arithmatic functions which are not defined in this file. This will give an error at compilation time when those functions will not be found, so as a promise we give a declaration that these functions are present somewhere and they will be found in later steps by linker. Here those definitions are present in libarithmatic.h file – header file for libarithmatic.c.\nSo when we are compiling libarithmatic.c, it’ll create a libarithmatic.o file which will have 4 arithmatic functions as defined. On the other hand, main.c will generate a main.o file that will have a main function which will be trying to call the arithmatic functions - addFunc, subFunc, mulFunc, and divFunc.\nQuestion - How did main.o call these functions when the address of these functions is not known to the compiler??\nAnswer - Compiler takes main.c and libarithmatic.h (a promise that these will be present when linking), and then generates the main.o with all of the call instructions… but because of the fact that it does not know the address of the functions to be called these addresses are left blank. These blanks will be filled by linker during relocation process.\nHere is a proof that all of them are empty before linking and have all of the addresses fixed up after linking\n## Before linking - main.o ❯ objdump -M intel -D -j .text main.o | grep call 26: e8 00 00 00 00 call 2b 49: e8 00 00 00 00 call 4e 86: e8 00 00 00 00 call 8b a3: e8 00 00 00 00 call a8 c0: e8 00 00 00 00 call c5 dd: e8 00 00 00 00 call e2 f5: e8 00 00 00 00 call fa 123: e8 00 00 00 00 call 128 13c: e8 00 00 00 00 call 141 ## After linking - calc ❯ objdump -M intel -D -j .text calc | grep call 1138: e8 63 ff ff ff call 10a0 \u003c_start+0x30\u003e 118f: e8 bc fe ff ff call 1050 11b2: e8 a9 fe ff ff call 1060 \u003c__isoc99_scanf@plt\u003e 11ef: e8 b8 00 00 00 call 12ac 120c: e8 b5 00 00 00 call 12c6 1229: e8 b2 00 00 00 call 12e0 1246: e8 af 00 00 00 call 12fa 125e: e8 cd fd ff ff call 1030 128c: e8 bf fd ff ff call 1050 12a5: e8 96 fd ff ff call 1040 \u003c__stack_chk_fail@plt\u003e Symbols and symbol tables Now the question is that how does linker know which blanks to fill and how to fill them?? …here comes the role of symbols and symbol tables.\nWhen writing a program, we often use “names” to reference “objects” in our code, like function “names” and variable “names”. These “names” are commonly referred to as symbols. (yeah, deal with it now!)\nKeep in mind that not all “names” are symbols. For example, a local variables to a function won’t be treated as symbols. If you think it through, you don’t need linker to handle that data so what’s the point of adding that info as a symbol, right?\nAnother worth noting thing is that unlike string tables, symbol tables have a well-defined structure, and both Glibc and the Linux kernel define a struct for this (Elf64_Sym for 64-bit files).\n/* Glibc https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/elf.h;hb=2bd00179885928fd95fcabfafc50e7b5c6e660d2#l530 */ typedef struct { Elf64_Word st_name; /* Symbol name (string tbl index) */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf64_Section st_shndx; /* Section index */ Elf64_Addr st_value; /* Symbol value */ Elf64_Xword st_size; /* Symbol size */ } Elf64_Sym; /* Linux kernel v6.5.8 https://elixir.bootlin.com/linux/v6.5.8/source/include/uapi/linux/elf.h#L197 */ typedef struct elf64_sym { Elf64_Word st_name;\t/* Symbol name, index in string tbl */ unsigned char\tst_info;\t/* Type and binding attributes */ unsigned char\tst_other;\t/* No defined meaning, 0 */ Elf64_Half st_shndx;\t/* Associated section index */ Elf64_Addr st_value;\t/* Value of the symbol */ Elf64_Xword st_size;\t/* Associated symbol size */ } Elf64_Sym; Let’s see what each member of this struct resembles\nst_name Similar to other name fields in the ELF specification, this member stores the index or offset in the associated string table.\nst_info This member represents a combined value derived from two different but related attributes: bind and type.\nBoth, Linux Kernel and glibc provide definitions and macros to work with this member.\n1. Bind The “bind” bits provide information about where this symbol can be seen and used… There are 3 kinds of binding defined by linux kernel\n/* https://elixir.bootlin.com/linux/v6.5.8/source/include/uapi/linux/elf.h#L123 */ #define STB_LOCAL 0 /* not visible outside the object file */ #define STB_GLOBAL 1 /* visible to all object files */ #define STB_WEAK 2 /* like globals, but with lower precedence */ But glibc adds few more to this list\n/* https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/elf.h;hb=2bd00179885928fd95fcabfafc50e7b5c6e660d2#l582 */ #define STB_LOCAL 0 /* Local symbol */ #define STB_GLOBAL 1 /* Global symbol */ #define STB_WEAK 2 /* Weak symbol */ #define STB_NUM 3 /* Number of defined types. */ #define STB_LOOS 10 /* Start of OS-specific */ #define STB_GNU_UNIQUE 10 /* Unique symbol. */ #define STB_HIOS 12 /* End of OS-specific */ #define STB_LOPROC 13 /* Start of processor-specific */ #define STB_HIPROC 15 /* End of processor-specific */ Kernel and glibc both provide a macro to extract the bind value from the provided st_info member - #define ELF_ST_BIND(x)\t((x) \u003e\u003e 4)\n2. Type type bits tells about the type of symbol - function, file, variable, etc. One could say – A general classification for the symbol.\nLinux kernel defines total 7 types\n/* https://elixir.bootlin.com/linux/v6.5.8/source/include/uapi/linux/elf.h#L128 */ #define STT_NOTYPE 0 /* Unspecified */ #define STT_OBJECT 1 /* data objects like variables, arrays, etc*/ #define STT_FUNC 2 /* functions or other executable codes*/ #define STT_SECTION 3 /* associated with a section; mainly used for relocations (we'll see relocations in later articles)*/ #define STT_FILE 4 /* name of the source file*/ #define STT_COMMON 5 /* just like STT_OBJECT, but for tentative values */ #define STT_TLS 6 /* stores thread local data which is unique to each thread */ And again our beloved glibc expanded these definitions\n/* https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/elf.h;hb=2bd00179885928fd95fcabfafc50e7b5c6e660d2#l595 */ #define STT_NOTYPE 0 /* Symbol type is unspecified */ #define STT_OBJECT 1 /* Symbol is a data object */ #define STT_FUNC 2 /* Symbol is a code object */ #define STT_SECTION 3 /* Symbol associated with a section */ #define STT_FILE 4 /* Symbol's name is file name */ #define STT_COMMON 5 /* Symbol is a common data object */ #define STT_TLS 6 /* Symbol is thread-local data object*/ #define STT_NUM 7 /* Number of defined types. */ #define STT_LOOS 10 /* Start of OS-specific */ #define STT_GNU_IFUNC 10 /* Symbol is indirect code object */ #define STT_HIOS 12 /* End of OS-specific */ #define STT_LOPROC 13 /* Start of processor-specific */ #define STT_HIPROC 15 /* End of processor-specific */ Kernel and glibc both provide a macro to extract the type value from the provided st_info member - #define ELF_ST_TYPE(x) ((x) \u0026 0xf)\nst_other If you examine the Elf64_Sym struct in both the kernel and Glibc source code, you’ll notice that the kernel doesn’t currently have any use case for this field and marks it as such. However, Glibc uses this field to track the visibility of the symbol.\n/* https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/elf.h;hb=2bd00179885928fd95fcabfafc50e7b5c6e660d2#l626 */ #define STV_DEFAULT 0 /* Default symbol visibility rules - as specified by symbol binding*/ #define STV_INTERNAL 1 /* Processor specific hidden class */ #define STV_HIDDEN 2 /* Sym unavailable in other modules */ #define STV_PROTECTED 3 /* Not preemptible, not exported */ From what I understand, symbol visibility (yup, this is what glibc calls st_other) extends the concept of symbol binding and provides more control over symbol access.\nYou can read more about this member from here 1 and here 2.\nst_shndx This attribute indicates the section associated with this symbol. It holds the section index corresponding to the sections in the section header.\nst_value Indeed, each symbol should have both a name and an associated value. This member holds the value associated with the respective symbol.\nst_size Many symbols come with associated sizes, for function type symbols this will be the size of that function. If a symbol doesn’t have a size or its size is unknown, this member holds a value of zero.\nAnalysis Now that we have a foundational understanding, we can apply this knowledge to analyze our previous files.\n1. libarithmatic.o To keep things straightforward, I’ll begin by listing all the sections in the libarithmatic.o file. (This is the output from my parser, you can use hexdumps or any other parser of your choice…)\n[ 00 ] Section Name: Type: 0x0 Flags: 0x0 Addr: 0x0 Offset: 0x0 Size: 0 Link: 0 Info: 0x0 Addralign: 0x0 Entsize: 0 [ 01 ] Section Name: .text Type: 0x1 Flags: 0x6 Addr: 0x0 Offset: 0x40 Size: 130 Link: 0 Info: 0x0 Addralign: 0x1 Entsize: 0 [ 02 ] Section Name: .data Type: 0x1 Flags: 0x3 Addr: 0x0 Offset: 0xc2 Size: 0 Link: 0 Info: 0x0 Addralign: 0x1 Entsize: 0 [ 03 ] Section Name: .bss Type: 0x8 Flags: 0x3 Addr: 0x0 Offset: 0xc2 Size: 0 Link: 0 Info: 0x0 Addralign: 0x1 Entsize: 0 [ 04 ] Section Name: .comment Type: 0x1 Flags: 0x30 Addr: 0x0 Offset: 0xc2 Size: 28 Link: 0 Info: 0x0 Addralign: 0x1 Entsize: 1 [ 05 ] Section Name: .note.GNU-stack Type: 0x1 Flags: 0x0 Addr: 0x0 Offset: 0xde Size: 0 Link: 0 Info: 0x0 Addralign: 0x1 Entsize: 0 [ 06 ] Section Name: .note.gnu.property Type: 0x7 Flags: 0x2 Addr: 0x0 Offset: 0xe0 Size: 48 Link: 0 Info: 0x0 Addralign: 0x8 Entsize: 0 [ 07 ] Section Name: .eh_frame Type: 0x1 Flags: 0x2 Addr: 0x0 Offset: 0x110 Size: 152 Link: 0 Info: 0x0 Addralign: 0x8 Entsize: 0 [ 08 ] Section Name: .rela.eh_frame Type: 0x4 Flags: 0x40 Addr: 0x0 Offset: 0x288 Size: 96 Link: 9 Info: 0x7 Addralign: 0x8 Entsize: 24 [ 09 ] Section Name: .symtab Type: 0x2 Flags: 0x0 Addr: 0x0 Offset: 0x1a8 Size: 168 Link: 10 Info: 0x3 Addralign: 0x8 Entsize: 24 [ 10 ] Section Name: .strtab Type: 0x3 Flags: 0x0 Addr: 0x0 Offset: 0x250 Size: 49 Link: 0 Info: 0x0 Addralign: 0x1 Entsize: 0 [ 11 ] Section Name: .shstrtab Type: 0x3 Flags: 0x0 Addr: 0x0 Offset: 0x2e8 Size: 103 Link: 0 Info: 0x0 Addralign: 0x1 Entsize: 0 Now we can easily filter out the symbol table from this (Type: 0x2)\n[ 09 ] Section Name: .symtab Type: 0x2 Flags: 0x0 Addr: 0x0 Offset: 0x1a8 Size: 168 Link: 10 Info: 0x3 Addralign: 0x8 Entsize: 24 If you go back and revisit the article about section headers and check the explaination about members, you’ll be able to conclude this – .symtab section is linked to .strtab section. So the offset values from st_name of symbol table can be resolved to proper strings using this string table.\n┌─────────────────────────────────┐ │ │ │ [ 09 ] Section Name: .symtab │ │ Type: 0x2 │ │ Flags: 0x0 │ │ Addr: 0x0 │ │ Offset: 0x1a8 │ │ Size: 168 │ ┌────┼────────── Link: 10 │ │ │ Info: 0x3 │ │ │ Addralign: 0x8 │ │ │ Entsize: 24 │ │ │ │ │ │ │ │ └─────────────────────────────────┘ │ │ │ │ │ ┌─────────────────────────────────┐ │ │ │ └────┤► [ 10 ] Section Name: .strtab │ │ Type: 0x3 │ │ Flags: 0x0 │ │ Addr: 0x0 │ │ Offset: 0x250 │ │ Size: 49 │ │ Link: 0 │ │ Info: 0x0 │ │ Addralign: 0x1 │ │ Entsize: 0 │ │ │ │ │ └─────────────────────────────────┘ Now we can begin with the interesting stuff and the first step will be to pull out the .symtab section and parse it.\n############ Explaination ################# # # xxd # -s 0x1a8 # start point (Offset: 0x1a8) # -l 168 # total length (Size: 168) # -c 24 # bytes per line (Entsize: 24) - I wanted to get each entry in a single line for uniformity # libarithmatic.o # filename # | nl -v0 # line numbers starting from 0 # ############################################# ❯ xxd -s 0x1a8 -l 168 -c 24 libarithmatic.o | nl -v0 0 000001a8: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ........................ 1 000001c0: 0100 0000 0400 f1ff 0000 0000 0000 0000 0000 0000 0000 0000 ........................ 2 000001d8: 0000 0000 0300 0100 0000 0000 0000 0000 0000 0000 0000 0000 ........................ 3 000001f0: 1100 0000 1200 0100 0000 0000 0000 0000 1a00 0000 0000 0000 ........................ 4 00000208: 1900 0000 1200 0100 1a00 0000 0000 0000 1a00 0000 0000 0000 ........................ 5 00000220: 2100 0000 1200 0100 3400 0000 0000 0000 1a00 0000 0000 0000 !.......4............... 6 00000238: 2900 0000 1200 0100 4e00 0000 0000 0000 3400 0000 0000 0000 ).......N.......4....... If we parse this data using the struct Elf64_Sym, we’ll get something like this\ntypedef struct { +------------------------------Elf64_Word st_name; | | +---------------------unsigned char st_info; | | | | +---------------unsigned char st_other; | | | | | | +----------Elf64_Section st_shndx; | | | | | | | | Elf64_Addr st_value;----+ | | | | | | | | | Elf64_Xword st_size;-----+-----------------+ | | | | | | | | | | } Elf64_Sym; | | | | | | | | | | | | | | | | | +-------------------+ | | | | | | | | | | +------------------+ | | | | | | | | | | +-------------------+ | | | | | | | | | | +-------------------+ | | | | | | | | | | | v v v v v v Index | Offset | 0 | 000001a8:| 0000 0000 | 00 | 00 | 0000 | 0000 0000 0000 0000 | 0000 0000 0000 0000 | 1 | 000001c0:| 0100 0000 | 04 | 00 | f1ff | 0000 0000 0000 0000 | 0000 0000 0000 0000 | 2 | 000001d8:| 0000 0000 | 03 | 00 | 0100 | 0000 0000 0000 0000 | 0000 0000 0000 0000 | 3 | 000001f0:| 1100 0000 | 12 | 00 | 0100 | 0000 0000 0000 0000 | 1a00 0000 0000 0000 | 4 | 00000208:| 1900 0000 | 12 | 00 | 0100 | 1a00 0000 0000 0000 | 1a00 0000 0000 0000 | 5 | 00000220:| 2100 0000 | 12 | 00 | 0100 | 3400 0000 0000 0000 | 1a00 0000 0000 0000 | 6 | 00000238:| 2900 0000 | 12 | 00 | 0100 | 4e00 0000 0000 0000 | 3400 0000 0000 0000 | From my parser, I got this result\n[ 0 ] Name: Info: 0x00 (Bind: 0x0 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 1 ] Name: libarithmatic.c Info: 0x04 (Bind: 0x0 | Type: 0x4) Other: 0x0 Shndx: 0xfff1 Value: 0x000000000000 Size: 0x0 [ 2 ] Name: Info: 0x03 (Bind: 0x0 | Type: 0x3) Other: 0x0 Shndx: 0x1 Value: 0x000000000000 Size: 0x0 [ 3 ] Name: addFunc Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0x1 Value: 0x000000000000 Size: 0x1a [ 4 ] Name: subFunc Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0x1 Value: 0x00000000001a Size: 0x1a [ 5 ] Name: mulFunc Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0x1 Value: 0x000000000034 Size: 0x1a [ 6 ] Name: divFunc Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0x1 Value: 0x00000000004e Size: 0x34 For the sake of simplicity and the scope of this article, I’ll focus on discussing the four functions in this table and leave the rest for you to explore and learn.\nWe can observe that the st_info value for all of these symbols is the same, which implies that their “bind” and “type” values are identical (duhh). According to the information we’ve gathered, these symbols are GLOBAL (bind=0x1) and of FUNC (type=0x2) type. This indicates that these symbols are basically global functions and can be called from other files as well.\nIt’s worth noting that there’s a very cool tool called \"ftrace\" by elfmaster, which utilizes this information to trace function calls, specifically focusing on function calls and not other symbols.\nFurthermore, the st_other field is empty for these members, indicating default symbol visibility. There’s nothing noteworthy to discuss here.\nSo we move on to the sh_shndx (section index) member. This member tells us that all of these symbols are associated with section 0x1 (which is .text, and that does make sense – Code of these functions should be in .text section only).\nThe st_value field indicates the offset within the .text section at which these functions begin. So, if you start executing instructions from offset 0x34 in the .text section, you’ll be running the mulFunc function. Makes sense??\nThe linker will perform relocation on the object files and generate a final executable binary that will have all the values in correct places. At that point we won’t need the mulFunc string in our ELF file.\nLast but not least, the st_size field provides the size of the function. This helps the magical entity reading the code determine when to stop and understand the boundaries of the function.\n2. main.o Performing the same initial process for the main.o file, you will be able yield its symbol table, as shown below.\n[ 11 ] Section Name: .symtab Type: 0x2 Flags: 0x0 Addr: 0x0 Offset: 0x248 Size: 312 Link: 12 Info: 0x4 Addralign: 0x8 Entsize: 24 [ 0 ] Name: Info: 0x00 (Bind: 0x0 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 1 ] Name: main.c Info: 0x04 (Bind: 0x0 | Type: 0x4) Other: 0x0 Shndx: 0xfff1 Value: 0x000000000000 Size: 0x0 [ 2 ] Name: Info: 0x03 (Bind: 0x0 | Type: 0x3) Other: 0x0 Shndx: 0x1 Value: 0x000000000000 Size: 0x0 [ 3 ] Name: Info: 0x03 (Bind: 0x0 | Type: 0x3) Other: 0x0 Shndx: 0x5 Value: 0x000000000000 Size: 0x0 [ 4 ] Name: main Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0x1 Value: 0x000000000000 Size: 0x143 [ 5 ] Name: printf Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 6 ] Name: __isoc99_scanf Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 7 ] Name: addFunc Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 8 ] Name: subFunc Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 9 ] Name: mulFunc Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 10 ] Name: divFunc Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 11 ] Name: puts Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 12 ] Name: __stack_chk_fail Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 In this case, things get a bit more interesting. Let’s begin with the same set of symbols: addFunc, subFunc, mulFunc, and divFunc.\nYou’ll notice that these symbols are global, but they don’t have any associated types. This is expected since the symbols are not defined in this file; they are just being called. At this stage, we’re not certain if there’s anything like these symbols elsewhere, which is why all the other members are zeroed out (undefined). This essentially instructs the magical linker to locate the values of these symbols (linkers are pretty good at this; they will give errors if the symbols aren’t found).\nNow, you’ll also notice the presence of printf and puts symbols. This may raise a question: “I didn’t use puts in my code, so why is it there?”\nAnswer: It’s compiler magic! The compiler observed that the line printf(\"Enter equation (9 * 6): \"); could be expressed as puts(\"Enter equation (9 * 6): \");, so it made this conversion during compilation. To confirm this, you can generate the compiled code using gcc -S and check the call to puts function.\nNow, let’s examine our mighty main symbol. The st_info indicates that it’s a GLOBAL function (with bind=0x1 and type=0x2). This function is located in the 1st section (sh_shndx: 0x1) of main.o, which in our case is the .text section. The function begins at offset 0x0, and its size is 0x143. Pretty simple, right?\n(Note: I’m leaving __isoc99_scanf and __stack_chk_fail for you. Google them!)\n3. calc This represents the ultimate outcome of the entire compilation, assembly, and linking process – the final ELF executable binary. However, the process to obtain its symbol table remains same.\nHere is the symtab for this ELF binary\n[ 27 ] Section Name: .symtab Type: 0x2 Flags: 0x0 Addr: 0x0 Offset: 0x3050 Size: 768 Link: 28 Info: 0x7 Addralign: 0x8 Entsize: 24 [ 0 ] Name: Info: 0x00 (Bind: 0x0 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 1 ] Name: main.c Info: 0x04 (Bind: 0x0 | Type: 0x4) Other: 0x0 Shndx: 0xfff1 Value: 0x000000000000 Size: 0x0 [ 2 ] Name: libarithmatic.c Info: 0x04 (Bind: 0x0 | Type: 0x4) Other: 0x0 Shndx: 0xfff1 Value: 0x000000000000 Size: 0x0 [ 3 ] Name: Info: 0x04 (Bind: 0x0 | Type: 0x4) Other: 0x0 Shndx: 0xfff1 Value: 0x000000000000 Size: 0x0 [ 4 ] Name: _DYNAMIC Info: 0x01 (Bind: 0x0 | Type: 0x1) Other: 0x0 Shndx: 0x15 Value: 0x000000003de0 Size: 0x0 [ 5 ] Name: __GNU_EH_FRAME_HDR Info: 0x00 (Bind: 0x0 | Type: 0x0) Other: 0x0 Shndx: 0x11 Value: 0x000000002048 Size: 0x0 [ 6 ] Name: _GLOBAL_OFFSET_TABLE_ Info: 0x01 (Bind: 0x0 | Type: 0x1) Other: 0x0 Shndx: 0x17 Value: 0x000000003fe8 Size: 0x0 [ 7 ] Name: __libc_start_main@GLIBC_2.34 Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 8 ] Name: _ITM_deregisterTMCloneTable Info: 0x32 (Bind: 0x2 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 9 ] Name: data_start Info: 0x32 (Bind: 0x2 | Type: 0x0) Other: 0x0 Shndx: 0x18 Value: 0x000000004020 Size: 0x0 [ 10 ] Name: subFunc Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0xe Value: 0x0000000012c6 Size: 0x1a [ 11 ] Name: puts@GLIBC_2.2.5 Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 12 ] Name: _edata Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x18 Value: 0x000000004030 Size: 0x0 [ 13 ] Name: _fini Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x2 Shndx: 0xf Value: 0x000000001330 Size: 0x0 [ 14 ] Name: __stack_chk_fail@GLIBC_2.4 Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 15 ] Name: printf@GLIBC_2.2.5 Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 16 ] Name: addFunc Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0xe Value: 0x0000000012ac Size: 0x1a [ 17 ] Name: __data_start Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x18 Value: 0x000000004020 Size: 0x0 [ 18 ] Name: __gmon_start__ Info: 0x32 (Bind: 0x2 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 19 ] Name: __dso_handle Info: 0x17 (Bind: 0x1 | Type: 0x1) Other: 0x2 Shndx: 0x18 Value: 0x000000004028 Size: 0x0 [ 20 ] Name: _IO_stdin_used Info: 0x17 (Bind: 0x1 | Type: 0x1) Other: 0x0 Shndx: 0x10 Value: 0x000000002000 Size: 0x4 [ 21 ] Name: divFunc Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0xe Value: 0x0000000012fa Size: 0x34 [ 22 ] Name: _end Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x19 Value: 0x000000004038 Size: 0x0 [ 23 ] Name: _start Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0xe Value: 0x000000001070 Size: 0x26 [ 24 ] Name: __bss_start Info: 0x16 (Bind: 0x1 | Type: 0x0) Other: 0x0 Shndx: 0x19 Value: 0x000000004030 Size: 0x0 [ 25 ] Name: mulFunc Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0xe Value: 0x0000000012e0 Size: 0x1a [ 26 ] Name: main Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0xe Value: 0x000000001169 Size: 0x143 [ 27 ] Name: __isoc99_scanf@GLIBC_2.7 Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 28 ] Name: __TMC_END__ Info: 0x17 (Bind: 0x1 | Type: 0x1) Other: 0x2 Shndx: 0x18 Value: 0x000000004030 Size: 0x0 [ 29 ] Name: _ITM_registerTMCloneTable Info: 0x32 (Bind: 0x2 | Type: 0x0) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 30 ] Name: __cxa_finalize@GLIBC_2.2.5 Info: 0x34 (Bind: 0x2 | Type: 0x2) Other: 0x0 Shndx: 0x0 Value: 0x000000000000 Size: 0x0 [ 31 ] Name: _init Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x2 Shndx: 0xc Value: 0x000000001000 Size: 0x0 The linking process did introduce numerous symbols that exceed the combined count of symbols in both individual object files. To keep things simple (* once again *), we won’t dive into the specifics of what these additional symbols do, and we can think of them as a result of linker magic.\nOur primary focus for now remains on the symbols and their properties, even if we don’t have detailed knowledge of their functions.\nThese are the symbols we defined ourselves…\n[ 10 ] Name: subFunc Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0xe Value: 0x0000000012c6 Size: 0x1a [ 16 ] Name: addFunc Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0xe Value: 0x0000000012ac Size: 0x1a [ 21 ] Name: divFunc Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0xe Value: 0x0000000012fa Size: 0x34 [ 25 ] Name: mulFunc Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0xe Value: 0x0000000012e0 Size: 0x1a [ 26 ] Name: main Info: 0x18 (Bind: 0x1 | Type: 0x2) Other: 0x0 Shndx: 0xe Value: 0x000000001169 Size: 0x143 We can observe the similarities in various members between libarithmatic.o and main.o. The notable difference I can identify is the sh_shndx value, which has changed but still points to the .text section of calc file. The important point is that it should reference the .text section, regardless of the section index value.\nAnother difference is in the st_value. With the addition of numerous new symbols in this file, the positions of these symbols have shifted. Initially, we had the main function in main.o and addFunc in libarithmatic.o, both at offset 0x0. However, when combining them into a single file, one of them had to adjust its offset to make room for the other. This is precisely what occurred here, and there are also other symbols (of function type) that occupied the initial offsets, causing our defined functions to compromise on their offsets.\nOne more intriguing detail is the _start symbol, which has an offset of 0x000000001070. This offset serves as the entry point of our ELF executable binary. You can verify this using readelf or any method you prefer. If you happen to overwrite the entrypoint value in ELF file headers, you’ll be calling some other function instead of _start function of glibc. Since _start function performs some startup actions for C runtime environment, so the modified binary may or may not work as intended.\nI’m sure that’s enough for today, ta-ta!\nhttps://developer.ibm.com/articles/au-aix-symbol-visibility/ ↩︎\nhttps://unix.stackexchange.com/questions/472660/what-are-difference-between-the-elf-symbol-visibility-levels ↩︎\n","wordCount":"5129","inLanguage":"en","datePublished":"2023-10-29T22:15:08+05:30","dateModified":"2024-04-05T21:58:47+05:30","author":[{"@type":"Person","name":"ayedaemon"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://ayedaemon.github.io/post/2023/10/elf-chronicles-symbol-tables/"},"publisher":{"@type":"Organization","name":"Connected","logo":{"@type":"ImageObject","url":"https://ayedaemon.github.io/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://ayedaemon.github.io/ accesskey=h title="Connected (Alt + H)">Connected</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://ayedaemon.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://ayedaemon.github.io/series/ title=Series><span>Series</span></a></li><li><a href=https://ayedaemon.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ayedaemon.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Elf Chronicles: Symbol Tables (5/?)</h1><div class=post-description>Exploring ELF symbol tables</div><div class=post-meta><span title='2023-10-29 22:15:08 +0530 +0530'>October 29, 2023</span>&nbsp;·&nbsp;25 min&nbsp;·&nbsp;5129 words&nbsp;·&nbsp;ayedaemon&nbsp;|&nbsp;<a href=https://github.com/ayedaemon/ayedaemon.github.io/tree/main/content/post/2023/10/elf-chronicles-symbol-tables.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#-prologue aria-label="&mldr; prologue">&mldr; prologue</a></li><li><a href=#symbols-and-symbol-tables aria-label="Symbols and symbol tables">Symbols and symbol tables</a><ul><li><a href=#st_name aria-label=st_name>st_name</a></li><li><a href=#st_info aria-label=st_info>st_info</a><ul><li><a href=#1-bind aria-label="1. Bind">1. Bind</a></li><li><a href=#2-type aria-label="2. Type">2. Type</a></li></ul></li><li><a href=#st_other aria-label=st_other>st_other</a></li><li><a href=#st_shndx aria-label=st_shndx>st_shndx</a></li><li><a href=#st_value aria-label=st_value>st_value</a></li><li><a href=#st_size aria-label=st_size>st_size</a></li></ul></li><li><a href=#analysis aria-label=Analysis>Analysis</a><ul><li><a href=#1-libarithmatico aria-label="1. libarithmatic.o">1. libarithmatic.o</a></li><li><a href=#2-maino aria-label="2. main.o">2. main.o</a></li><li><a href=#3-calc aria-label="3. calc">3. calc</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=-prologue>&mldr; prologue<a hidden class=anchor aria-hidden=true href=#-prologue>#</a></h2><p>At this point I hope you have a general idea of how a C program goes through multiple stages/passes and finally an ELF file is generated. Below is a diagram to jog your memory on this</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  ┌──────────────────┐
</span></span><span class=line><span class=cl>  │                  │
</span></span><span class=line><span class=cl>  │    hello.c       │  // C source
</span></span><span class=line><span class=cl>  │                  │
</span></span><span class=line><span class=cl>  └────────┬─────────┘
</span></span><span class=line><span class=cl>           │
</span></span><span class=line><span class=cl>           │
</span></span><span class=line><span class=cl>           │ /* Compile */
</span></span><span class=line><span class=cl>           │
</span></span><span class=line><span class=cl>           │
</span></span><span class=line><span class=cl>           │
</span></span><span class=line><span class=cl>           ▼
</span></span><span class=line><span class=cl>  ┌──────────────────┐
</span></span><span class=line><span class=cl>  │                  │
</span></span><span class=line><span class=cl>  │    hello.s       │  // assembler source
</span></span><span class=line><span class=cl>  │                  │
</span></span><span class=line><span class=cl>  └────────┬─────────┘
</span></span><span class=line><span class=cl>           │
</span></span><span class=line><span class=cl>           │
</span></span><span class=line><span class=cl>           │ /* assemble */
</span></span><span class=line><span class=cl>           │
</span></span><span class=line><span class=cl>           │
</span></span><span class=line><span class=cl>           ▼
</span></span><span class=line><span class=cl>  ┌──────────────────┐
</span></span><span class=line><span class=cl>  │                  │
</span></span><span class=line><span class=cl>  │     hello.o      │  // Assembled program (ELF - relocatable)
</span></span><span class=line><span class=cl>  │                  │
</span></span><span class=line><span class=cl>  └────────┬─────────┘
</span></span><span class=line><span class=cl>           │
</span></span><span class=line><span class=cl>           │
</span></span><span class=line><span class=cl>           │ /* link */
</span></span><span class=line><span class=cl>           │
</span></span><span class=line><span class=cl>           │
</span></span><span class=line><span class=cl>           ▼
</span></span><span class=line><span class=cl>  ┌──────────────────┐
</span></span><span class=line><span class=cl>  │                  │
</span></span><span class=line><span class=cl>  │      hello       │  // Executable binary (ELF - executable)
</span></span><span class=line><span class=cl>  │                  │
</span></span><span class=line><span class=cl>  └──────────────────┘
</span></span></code></pre></div><p>Creating a simple <em>hello</em> program is very straight-forward, let me show you how this flow works when we are building something that has more than 1 source file. This is generally what most of the &ldquo;real-world&rdquo; projects do, they create multiple files with different functionalities and then merge them together to complete the program with the desired features only.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     ┌────────────────────┐                        ┌─────────────────┐         ┌─────────────────┐
</span></span><span class=line><span class=cl>     │                    │                        │                 │         │                 │
</span></span><span class=line><span class=cl>     │   libarithmatic.c  │                        │ libarithmatic.h ├───────► │     main.c      │
</span></span><span class=line><span class=cl>     │                    │                        │                 │         │                 │
</span></span><span class=line><span class=cl>     └─────────┬──────────┘                        └─────────────────┘         └────────┬────────┘
</span></span><span class=line><span class=cl>               │                                                                        │
</span></span><span class=line><span class=cl>               │                                                                        │
</span></span><span class=line><span class=cl>               │ /* Compile + assemble */                                               │ /* Compile + assemble */
</span></span><span class=line><span class=cl>               │                                                                        │
</span></span><span class=line><span class=cl>               │                                                                        │
</span></span><span class=line><span class=cl>               ▼                                                                        ▼
</span></span><span class=line><span class=cl>    ┌─────────────────────┐                                                   ┌────────────────────┐
</span></span><span class=line><span class=cl>    │                     │                                                   │                    │
</span></span><span class=line><span class=cl>    │   libarithmatic.o   │                                                   │       main.o       │
</span></span><span class=line><span class=cl>    │                     │                                                   │                    │
</span></span><span class=line><span class=cl>    └─────────┬───────────┘                                                   └──────────┬─────────┘
</span></span><span class=line><span class=cl>              │                                                                          │
</span></span><span class=line><span class=cl>              │                                                                          │
</span></span><span class=line><span class=cl>              │                                                                          │
</span></span><span class=line><span class=cl>              │                                                                          │
</span></span><span class=line><span class=cl>              │                          /* Linking Magic */                             │
</span></span><span class=line><span class=cl>              └───────────────────────────────────┬──────────────────────────────────────┘
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  ▼
</span></span><span class=line><span class=cl>                                           ┌────────────────┐
</span></span><span class=line><span class=cl>                                           │                │
</span></span><span class=line><span class=cl>                                           │     calc       │
</span></span><span class=line><span class=cl>                                           │                │
</span></span><span class=line><span class=cl>                                           └────────────────┘
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>File: libarithmatic.c
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=nf>addFunc</span> <span class=p>(</span><span class=kt>float</span> <span class=n>a</span><span class=p>,</span> <span class=kt>float</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=nf>subFunc</span> <span class=p>(</span><span class=kt>float</span> <span class=n>a</span><span class=p>,</span> <span class=kt>float</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>-</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=nf>mulFunc</span> <span class=p>(</span><span class=kt>float</span> <span class=n>a</span><span class=p>,</span> <span class=kt>float</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>*</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=nf>divFunc</span> <span class=p>(</span><span class=kt>float</span> <span class=n>a</span><span class=p>,</span> <span class=kt>float</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>b</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>/</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>File: libarithmatic.h
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifndef ARITHMATIC_H
</span></span></span><span class=line><span class=cl><span class=cp>#define ARITHMATIC_H
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=nf>addFunc</span> <span class=p>(</span><span class=kt>float</span><span class=p>,</span> <span class=kt>float</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=nf>subFunc</span> <span class=p>(</span><span class=kt>float</span><span class=p>,</span> <span class=kt>float</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=nf>mulFunc</span> <span class=p>(</span><span class=kt>float</span><span class=p>,</span> <span class=kt>float</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=nf>divFunc</span> <span class=p>(</span><span class=kt>float</span><span class=p>,</span> <span class=kt>float</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=nf>magicFunc</span> <span class=p>(</span><span class=kt>float</span> <span class=n>a</span><span class=p>,</span> <span class=kt>float</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>File: main.c
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;libarithmatic.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>num1</span><span class=p>,</span> <span class=n>num2</span><span class=p>,</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>operator</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Enter equation (9 * 6): &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%f %c %f&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>num1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>operator</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>num2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>operator</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=sc>&#39;+&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span> <span class=o>=</span> <span class=nf>addFunc</span><span class=p>(</span><span class=n>num1</span><span class=p>,</span> <span class=n>num2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=sc>&#39;-&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span> <span class=o>=</span> <span class=nf>subFunc</span><span class=p>(</span><span class=n>num1</span><span class=p>,</span> <span class=n>num2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=sc>&#39;*&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span> <span class=o>=</span> <span class=nf>mulFunc</span><span class=p>(</span><span class=n>num1</span><span class=p>,</span> <span class=n>num2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=sc>&#39;/&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span> <span class=o>=</span> <span class=nf>divFunc</span><span class=p>(</span><span class=n>num1</span><span class=p>,</span> <span class=n>num2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Invalid operator</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Result: %.2f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Luckily gcc provides some features, that helps us to make this process easier.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>❯ gcc --help
</span></span><span class=line><span class=cl>Usage: gcc [options] file...
</span></span><span class=line><span class=cl>Options:
</span></span><span class=line><span class=cl>&lt;... OMITTED ...&gt;
</span></span><span class=line><span class=cl>  -E                       Preprocess only; do not compile, assemble or link.
</span></span><span class=line><span class=cl>  -S                       Compile only; do not assemble or link.
</span></span><span class=line><span class=cl>  -c                       Compile and assemble, but do not link.
</span></span></code></pre></div><p>So if you follow these commands, you’ll be fine</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># Compile + assemble -&gt; generates main.o
</span></span><span class=line><span class=cl>gcc -c main.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># Compile + assemble -&gt; generates libarithmatic.o
</span></span><span class=line><span class=cl>gcc -c libarithmatic.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># Linking -&gt; generates calc
</span></span><span class=line><span class=cl>gcc main.o libarithmatic.o -o calc
</span></span></code></pre></div><p><img loading=lazy src=https://media.giphy.com/media/9wG8hpQRkHMoDbCqzu/giphy.gif#center alt></p><p>This is our first time so far writing multiple files for a program. So let&rsquo;s take a moment to understand how this works.</p><p>First, we create a <code>libarithmatic.c</code> file with all of the required arithmatic functions - <code>addFunc</code>, <code>subFunc</code>, <code>mulFunc</code>, and <code>divFunc</code>. Since this file contains these functions (function definitions), the intermediate object file for this file will have related information as well.</p><p>Then comes the <code>main.c</code> file, where we have declared the <code>main</code> function. Inside the main function, we have used arithmatic functions which are not defined in this file. This will give an error at compilation time when those functions will not be found, so as a promise we give a declaration that these functions are present somewhere and they will be found in later steps by linker. Here those definitions are present in <code>libarithmatic.h</code> file &ndash; header file for <code>libarithmatic.c</code>.</p><p>So when we are compiling <code>libarithmatic.c</code>, it&rsquo;ll create a <code>libarithmatic.o</code> file which will have 4 arithmatic functions as defined. On the other hand, <code>main.c</code> will generate a <code>main.o</code> file that will have a <code>main</code> function which will be trying to call the arithmatic functions - <code>addFunc</code>, <code>subFunc</code>, <code>mulFunc</code>, and <code>divFunc</code>.</p><p><strong>Question</strong> - How did <code>main.o</code> call these functions when the address of these functions is not known to the compiler??</p><p><strong>Answer</strong> - Compiler takes <code>main.c</code> and <code>libarithmatic.h</code> (a promise that these will be present when linking), and then generates the <code>main.o</code> with all of the <code>call</code> instructions&mldr; but because of the fact that it does not know the address of the functions to be called these addresses are left blank. These blanks will be filled by linker during <code>relocation</code> process.</p><p>Here is a proof that all of them are empty before linking and have all of the addresses fixed up after linking</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>## Before linking - main.o
</span></span><span class=line><span class=cl>❯ objdump -M intel -D -j .text main.o | grep call
</span></span><span class=line><span class=cl> 26:        e8 00 00 00 00          call   2b &lt;main+0x2b&gt;
</span></span><span class=line><span class=cl> 49:        e8 00 00 00 00          call   4e &lt;main+0x4e&gt;
</span></span><span class=line><span class=cl> 86:        e8 00 00 00 00          call   8b &lt;main+0x8b&gt;
</span></span><span class=line><span class=cl> a3:        e8 00 00 00 00          call   a8 &lt;main+0xa8&gt;
</span></span><span class=line><span class=cl> c0:        e8 00 00 00 00          call   c5 &lt;main+0xc5&gt;
</span></span><span class=line><span class=cl> dd:        e8 00 00 00 00          call   e2 &lt;main+0xe2&gt;
</span></span><span class=line><span class=cl> f5:        e8 00 00 00 00          call   fa &lt;main+0xfa&gt;
</span></span><span class=line><span class=cl>123:        e8 00 00 00 00          call   128 &lt;main+0x128&gt;
</span></span><span class=line><span class=cl>13c:        e8 00 00 00 00          call   141 &lt;main+0x141&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>## After linking - calc
</span></span><span class=line><span class=cl>❯ objdump -M intel -D -j .text calc | grep call
</span></span><span class=line><span class=cl>1138:       e8 63 ff ff ff          call   10a0 &lt;_start+0x30&gt;
</span></span><span class=line><span class=cl>118f:       e8 bc fe ff ff          call   1050 &lt;printf@plt&gt;
</span></span><span class=line><span class=cl>11b2:       e8 a9 fe ff ff          call   1060 &lt;__isoc99_scanf@plt&gt;
</span></span><span class=line><span class=cl>11ef:       e8 b8 00 00 00          call   12ac &lt;addFunc&gt;
</span></span><span class=line><span class=cl>120c:       e8 b5 00 00 00          call   12c6 &lt;subFunc&gt;
</span></span><span class=line><span class=cl>1229:       e8 b2 00 00 00          call   12e0 &lt;mulFunc&gt;
</span></span><span class=line><span class=cl>1246:       e8 af 00 00 00          call   12fa &lt;divFunc&gt;
</span></span><span class=line><span class=cl>125e:       e8 cd fd ff ff          call   1030 &lt;puts@plt&gt;
</span></span><span class=line><span class=cl>128c:       e8 bf fd ff ff          call   1050 &lt;printf@plt&gt;
</span></span><span class=line><span class=cl>12a5:       e8 96 fd ff ff          call   1040 &lt;__stack_chk_fail@plt&gt;
</span></span></code></pre></div><h2 id=symbols-and-symbol-tables>Symbols and symbol tables<a hidden class=anchor aria-hidden=true href=#symbols-and-symbol-tables>#</a></h2><p><strong>Now the question is that how does linker know which blanks to fill and how to fill them??</strong> &mldr;here comes the role of <em>symbols</em> and <em>symbol tables</em>.</p><p>When writing a program, we often use &ldquo;names&rdquo; to reference &ldquo;objects&rdquo; in our code, like function &ldquo;names&rdquo; and variable &ldquo;names&rdquo;. These &ldquo;names&rdquo; are commonly referred to as <code>symbols</code>. (<em>yeah, deal with it now!</em>)</p><p>Keep in mind that not all &ldquo;names&rdquo; are symbols. For example, a local variables to a function won&rsquo;t be treated as symbols. If you think it through, you don&rsquo;t need linker to handle that data so what&rsquo;s the point of adding that info as a symbol, right?</p><p>Another worth noting thing is that unlike string tables, symbol tables have a well-defined structure, and both Glibc and the Linux kernel define a struct for this (<code>Elf64_Sym</code> for 64-bit files).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>Glibc
</span></span></span><span class=line><span class=cl><span class=cm>https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/elf.h;hb=2bd00179885928fd95fcabfafc50e7b5c6e660d2#l530
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span>    <span class=n>st_name</span><span class=p>;</span>                <span class=cm>/* Symbol name (string tbl index) */</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>st_info</span><span class=p>;</span>                <span class=cm>/* Symbol type and binding */</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>st_other</span><span class=p>;</span>               <span class=cm>/* Symbol visibility */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Section</span> <span class=n>st_shndx</span><span class=p>;</span>               <span class=cm>/* Section index */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Addr</span>    <span class=n>st_value</span><span class=p>;</span>               <span class=cm>/* Symbol value */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span>   <span class=n>st_size</span><span class=p>;</span>                <span class=cm>/* Symbol size */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf64_Sym</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>Linux kernel v6.5.8
</span></span></span><span class=line><span class=cl><span class=cm>https://elixir.bootlin.com/linux/v6.5.8/source/include/uapi/linux/elf.h#L197
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>elf64_sym</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Word</span>    <span class=n>st_name</span><span class=p>;</span>		<span class=cm>/* Symbol name, index in string tbl */</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>char</span>	<span class=n>st_info</span><span class=p>;</span>	    <span class=cm>/* Type and binding attributes */</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>char</span>	<span class=n>st_other</span><span class=p>;</span>	    <span class=cm>/* No defined meaning, 0 */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Half</span>    <span class=n>st_shndx</span><span class=p>;</span>		<span class=cm>/* Associated section index */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Addr</span>    <span class=n>st_value</span><span class=p>;</span>		<span class=cm>/* Value of the symbol */</span>
</span></span><span class=line><span class=cl>  <span class=n>Elf64_Xword</span>   <span class=n>st_size</span><span class=p>;</span>		<span class=cm>/* Associated symbol size */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Elf64_Sym</span><span class=p>;</span>
</span></span></code></pre></div><p>Let&rsquo;s see what each member of this struct resembles</p><h3 id=st_name>st_name<a hidden class=anchor aria-hidden=true href=#st_name>#</a></h3><p>Similar to other name fields in the ELF specification, this member stores the <strong>index</strong> or <strong>offset</strong> in the associated string table.</p><h3 id=st_info>st_info<a hidden class=anchor aria-hidden=true href=#st_info>#</a></h3><p>This member represents a combined value derived from two different but related attributes: <code>bind</code> and <code>type</code>.</p><p>Both, <a href=https://elixir.bootlin.com/linux/v6.5.8/source/include/uapi/linux/elf.h#L136>Linux Kernel</a> and <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/elf.h;hb=2bd00179885928fd95fcabfafc50e7b5c6e660d2#l572">glibc</a> provide definitions and macros to work with this member.</p><h4 id=1-bind>1. Bind<a hidden class=anchor aria-hidden=true href=#1-bind>#</a></h4><p>The &ldquo;bind&rdquo; bits provide information about where this symbol can be seen and used&mldr; There are 3 kinds of binding defined by linux kernel</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>https://elixir.bootlin.com/linux/v6.5.8/source/include/uapi/linux/elf.h#L123
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=cp>#define STB_LOCAL  0    </span><span class=cm>/* not visible outside the object file */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STB_GLOBAL 1    </span><span class=cm>/* visible to all object files */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STB_WEAK   2    </span><span class=cm>/* like globals, but with lower precedence */</span><span class=cp>
</span></span></span></code></pre></div><p>But glibc adds few more to this list</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/elf.h;hb=2bd00179885928fd95fcabfafc50e7b5c6e660d2#l582
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=cp>#define STB_LOCAL       0               </span><span class=cm>/* Local symbol */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STB_GLOBAL      1               </span><span class=cm>/* Global symbol */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STB_WEAK        2               </span><span class=cm>/* Weak symbol */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STB_NUM         3               </span><span class=cm>/* Number of defined types.  */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STB_LOOS        10              </span><span class=cm>/* Start of OS-specific */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STB_GNU_UNIQUE  10              </span><span class=cm>/* Unique symbol.  */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STB_HIOS        12              </span><span class=cm>/* End of OS-specific */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STB_LOPROC      13              </span><span class=cm>/* Start of processor-specific */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STB_HIPROC      15              </span><span class=cm>/* End of processor-specific */</span><span class=cp>
</span></span></span></code></pre></div><p>Kernel and glibc both provide a macro to extract the <code>bind</code> value from the provided <code>st_info</code> member - <code>#define ELF_ST_BIND(x) ((x) >> 4)</code></p><h4 id=2-type>2. Type<a hidden class=anchor aria-hidden=true href=#2-type>#</a></h4><p><code>type</code> bits tells about the type of symbol - function, file, variable, etc. One could say &ndash; A general classification for the symbol.</p><p>Linux kernel defines total 7 types</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>https://elixir.bootlin.com/linux/v6.5.8/source/include/uapi/linux/elf.h#L128
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define STT_NOTYPE  0   </span><span class=cm>/* Unspecified */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_OBJECT  1   </span><span class=cm>/* data objects like variables, arrays, etc*/</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_FUNC    2   </span><span class=cm>/* functions or other executable codes*/</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_SECTION 3   </span><span class=cm>/* associated with a section;
</span></span></span><span class=line><span class=cl><span class=cm>                           mainly used for relocations
</span></span></span><span class=line><span class=cl><span class=cm>                           (we&#39;ll see relocations in later articles)*/</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_FILE    4   </span><span class=cm>/* name of the source file*/</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_COMMON  5   </span><span class=cm>/* just like STT_OBJECT, but for tentative values */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_TLS     6   </span><span class=cm>/* stores thread local data which is unique to each thread */</span><span class=cp>
</span></span></span></code></pre></div><p>And again our beloved glibc expanded these definitions</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/elf.h;hb=2bd00179885928fd95fcabfafc50e7b5c6e660d2#l595
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=cp>#define STT_NOTYPE      0               </span><span class=cm>/* Symbol type is unspecified */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_OBJECT      1               </span><span class=cm>/* Symbol is a data object */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_FUNC        2               </span><span class=cm>/* Symbol is a code object */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_SECTION     3               </span><span class=cm>/* Symbol associated with a section */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_FILE        4               </span><span class=cm>/* Symbol&#39;s name is file name */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_COMMON      5               </span><span class=cm>/* Symbol is a common data object */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_TLS         6               </span><span class=cm>/* Symbol is thread-local data object*/</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_NUM         7               </span><span class=cm>/* Number of defined types.  */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_LOOS        10              </span><span class=cm>/* Start of OS-specific */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_GNU_IFUNC   10              </span><span class=cm>/* Symbol is indirect code object */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_HIOS        12              </span><span class=cm>/* End of OS-specific */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_LOPROC      13              </span><span class=cm>/* Start of processor-specific */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define STT_HIPROC      15              </span><span class=cm>/* End of processor-specific */</span><span class=cp>
</span></span></span></code></pre></div><p>Kernel and glibc both provide a macro to extract the <code>type</code> value from the provided <code>st_info</code> member - <code>#define ELF_ST_TYPE(x) ((x) & 0xf)</code></p><h3 id=st_other>st_other<a hidden class=anchor aria-hidden=true href=#st_other>#</a></h3><p>If you examine the <code>Elf64_Sym</code> struct in both the kernel and Glibc <em>source code</em>, you&rsquo;ll notice that the kernel doesn&rsquo;t currently have any use case for this field and marks it as such. However, Glibc uses this field to track the visibility of the symbol.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=o>/*</span>
</span></span><span class=line><span class=cl><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>sourceware</span><span class=o>.</span><span class=n>org</span><span class=o>/</span><span class=n>git</span><span class=o>/</span><span class=err>?</span><span class=n>p</span><span class=o>=</span><span class=n>glibc</span><span class=o>.</span><span class=n>git</span><span class=p>;</span><span class=n>a</span><span class=o>=</span><span class=n>blob</span><span class=p>;</span><span class=n>f</span><span class=o>=</span><span class=n>elf</span><span class=o>/</span><span class=n>elf</span><span class=o>.</span><span class=n>h</span><span class=p>;</span><span class=n>hb</span><span class=o>=</span><span class=mi>2</span><span class=n>bd00179885928fd95fcabfafc50e7b5c6e660d2</span><span class=c1>#l626</span>
</span></span><span class=line><span class=cl><span class=o>*/</span>
</span></span><span class=line><span class=cl><span class=c1>#define STV_DEFAULT     0               /* Default symbol visibility rules - as specified by symbol binding*/</span>
</span></span><span class=line><span class=cl><span class=c1>#define STV_INTERNAL    1               /* Processor specific hidden class */</span>
</span></span><span class=line><span class=cl><span class=c1>#define STV_HIDDEN      2               /* Sym unavailable in other modules */</span>
</span></span><span class=line><span class=cl><span class=c1>#define STV_PROTECTED   3               /* Not preemptible, not exported */</span>
</span></span></code></pre></div><p>From what I understand, <strong>symbol visibility</strong> (<em>yup, this is what glibc calls <code>st_other</code></em>) extends the concept of <strong>symbol binding</strong> and provides more control over symbol access.</p><p>You can read more about this member from <a href=https://developer.ibm.com/articles/au-aix-symbol-visibility/>here</a> <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> and <a href=https://unix.stackexchange.com/questions/472660/what-are-difference-between-the-elf-symbol-visibility-levels>here</a> <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><h3 id=st_shndx>st_shndx<a hidden class=anchor aria-hidden=true href=#st_shndx>#</a></h3><p>This attribute indicates the section associated with this symbol. It holds the section index corresponding to the sections in the section header.</p><h3 id=st_value>st_value<a hidden class=anchor aria-hidden=true href=#st_value>#</a></h3><p>Indeed, each symbol should have both a name and an associated value. This member holds the value associated with the respective symbol.</p><h3 id=st_size>st_size<a hidden class=anchor aria-hidden=true href=#st_size>#</a></h3><p>Many symbols come with associated sizes, for function type symbols this will be the size of that function. If a symbol doesn&rsquo;t have a size or its size is unknown, this member holds a value of zero.</p><h2 id=analysis>Analysis<a hidden class=anchor aria-hidden=true href=#analysis>#</a></h2><p>Now that we have a foundational understanding, we can apply this knowledge to analyze our previous files.</p><h3 id=1-libarithmatico>1. <code>libarithmatic.o</code><a hidden class=anchor aria-hidden=true href=#1-libarithmatico>#</a></h3><p>To keep things straightforward, I&rsquo;ll begin by listing all the sections in the <code>libarithmatic.o</code> file. (<em>This is the output from my parser, you can use hexdumps or any other parser of your choice&mldr;</em>)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[ 00 ] Section Name:                            Type: 0x0       Flags: 0x0      Addr: 0x0       Offset: 0x0             Size: 0         Link: 0         Info: 0x0       Addralign: 0x0          Entsize: 0
</span></span><span class=line><span class=cl>[ 01 ] Section Name: .text                      Type: 0x1       Flags: 0x6      Addr: 0x0       Offset: 0x40            Size: 130       Link: 0         Info: 0x0       Addralign: 0x1          Entsize: 0
</span></span><span class=line><span class=cl>[ 02 ] Section Name: .data                      Type: 0x1       Flags: 0x3      Addr: 0x0       Offset: 0xc2            Size: 0         Link: 0         Info: 0x0       Addralign: 0x1          Entsize: 0
</span></span><span class=line><span class=cl>[ 03 ] Section Name: .bss                       Type: 0x8       Flags: 0x3      Addr: 0x0       Offset: 0xc2            Size: 0         Link: 0         Info: 0x0       Addralign: 0x1          Entsize: 0
</span></span><span class=line><span class=cl>[ 04 ] Section Name: .comment                   Type: 0x1       Flags: 0x30     Addr: 0x0       Offset: 0xc2            Size: 28        Link: 0         Info: 0x0       Addralign: 0x1          Entsize: 1
</span></span><span class=line><span class=cl>[ 05 ] Section Name: .note.GNU-stack            Type: 0x1       Flags: 0x0      Addr: 0x0       Offset: 0xde            Size: 0         Link: 0         Info: 0x0       Addralign: 0x1          Entsize: 0
</span></span><span class=line><span class=cl>[ 06 ] Section Name: .note.gnu.property         Type: 0x7       Flags: 0x2      Addr: 0x0       Offset: 0xe0            Size: 48        Link: 0         Info: 0x0       Addralign: 0x8          Entsize: 0
</span></span><span class=line><span class=cl>[ 07 ] Section Name: .eh_frame                  Type: 0x1       Flags: 0x2      Addr: 0x0       Offset: 0x110           Size: 152       Link: 0         Info: 0x0       Addralign: 0x8          Entsize: 0
</span></span><span class=line><span class=cl>[ 08 ] Section Name: .rela.eh_frame             Type: 0x4       Flags: 0x40     Addr: 0x0       Offset: 0x288           Size: 96        Link: 9         Info: 0x7       Addralign: 0x8          Entsize: 24
</span></span><span class=line><span class=cl>[ 09 ] Section Name: .symtab                    Type: 0x2       Flags: 0x0      Addr: 0x0       Offset: 0x1a8           Size: 168       Link: 10        Info: 0x3       Addralign: 0x8          Entsize: 24
</span></span><span class=line><span class=cl>[ 10 ] Section Name: .strtab                    Type: 0x3       Flags: 0x0      Addr: 0x0       Offset: 0x250           Size: 49        Link: 0         Info: 0x0       Addralign: 0x1          Entsize: 0
</span></span><span class=line><span class=cl>[ 11 ] Section Name: .shstrtab                  Type: 0x3       Flags: 0x0      Addr: 0x0       Offset: 0x2e8           Size: 103       Link: 0         Info: 0x0       Addralign: 0x1          Entsize: 0
</span></span></code></pre></div><p>Now we can easily filter out the symbol table from this (<code>Type: 0x2</code>)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[ 09 ] Section Name: .symtab     Type: 0x2       Flags: 0x0      Addr: 0x0       Offset: 0x1a8           Size: 168       Link: 10        Info: 0x3       Addralign: 0x8          Entsize: 24
</span></span></code></pre></div><p>If you go back and revisit the article about section headers and check the explaination about members, you&rsquo;ll be able to conclude this &ndash; <code>.symtab</code> section is linked to <code>.strtab</code> section. So the offset values from <code>st_name</code> of symbol table can be resolved to proper strings using this string table.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>           ┌─────────────────────────────────┐
</span></span><span class=line><span class=cl>           │                                 │
</span></span><span class=line><span class=cl>           │ [ 09 ] Section Name: .symtab    │
</span></span><span class=line><span class=cl>           │           Type: 0x2             │
</span></span><span class=line><span class=cl>           │           Flags: 0x0            │
</span></span><span class=line><span class=cl>           │           Addr: 0x0             │
</span></span><span class=line><span class=cl>           │           Offset: 0x1a8         │
</span></span><span class=line><span class=cl>           │           Size: 168             │
</span></span><span class=line><span class=cl>      ┌────┼────────── Link: 10              │
</span></span><span class=line><span class=cl>      │    │           Info: 0x3             │
</span></span><span class=line><span class=cl>      │    │           Addralign: 0x8        │
</span></span><span class=line><span class=cl>      │    │           Entsize: 24           │
</span></span><span class=line><span class=cl>      │    │                                 │
</span></span><span class=line><span class=cl>      │    │                                 │
</span></span><span class=line><span class=cl>      │    └─────────────────────────────────┘
</span></span><span class=line><span class=cl>      │
</span></span><span class=line><span class=cl>      │
</span></span><span class=line><span class=cl>      │
</span></span><span class=line><span class=cl>      │
</span></span><span class=line><span class=cl>      │    ┌─────────────────────────────────┐
</span></span><span class=line><span class=cl>      │    │                                 │
</span></span><span class=line><span class=cl>      └────┤► [ 10 ] Section Name: .strtab   │
</span></span><span class=line><span class=cl>           │            Type: 0x3            │
</span></span><span class=line><span class=cl>           │            Flags: 0x0           │
</span></span><span class=line><span class=cl>           │            Addr: 0x0            │
</span></span><span class=line><span class=cl>           │            Offset: 0x250        │
</span></span><span class=line><span class=cl>           │            Size: 49             │
</span></span><span class=line><span class=cl>           │            Link: 0              │
</span></span><span class=line><span class=cl>           │            Info: 0x0            │
</span></span><span class=line><span class=cl>           │            Addralign: 0x1       │
</span></span><span class=line><span class=cl>           │            Entsize: 0           │
</span></span><span class=line><span class=cl>           │                                 │
</span></span><span class=line><span class=cl>           │                                 │
</span></span><span class=line><span class=cl>           └─────────────────────────────────┘
</span></span></code></pre></div><p>Now we can begin with the interesting stuff and the first step will be to pull out the <code>.symtab</code> section and parse it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>############ Explaination #################
</span></span><span class=line><span class=cl>#
</span></span><span class=line><span class=cl># xxd
</span></span><span class=line><span class=cl>#   -s 0x1a8            # start point (Offset: 0x1a8)
</span></span><span class=line><span class=cl>#   -l 168              # total length (Size: 168)
</span></span><span class=line><span class=cl>#   -c 24               # bytes per line (Entsize: 24) - I wanted to get each entry in a single line for uniformity
</span></span><span class=line><span class=cl>#   libarithmatic.o     # filename
</span></span><span class=line><span class=cl>#   | nl -v0            # line numbers starting from 0
</span></span><span class=line><span class=cl>#
</span></span><span class=line><span class=cl>#############################################
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>❯ xxd -s 0x1a8 -l 168 -c 24 libarithmatic.o | nl -v0
</span></span><span class=line><span class=cl>    0  000001a8: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000  ........................
</span></span><span class=line><span class=cl>    1  000001c0: 0100 0000 0400 f1ff 0000 0000 0000 0000 0000 0000 0000 0000  ........................
</span></span><span class=line><span class=cl>    2  000001d8: 0000 0000 0300 0100 0000 0000 0000 0000 0000 0000 0000 0000  ........................
</span></span><span class=line><span class=cl>    3  000001f0: 1100 0000 1200 0100 0000 0000 0000 0000 1a00 0000 0000 0000  ........................
</span></span><span class=line><span class=cl>    4  00000208: 1900 0000 1200 0100 1a00 0000 0000 0000 1a00 0000 0000 0000  ........................
</span></span><span class=line><span class=cl>    5  00000220: 2100 0000 1200 0100 3400 0000 0000 0000 1a00 0000 0000 0000  !.......4...............
</span></span><span class=line><span class=cl>    6  00000238: 2900 0000 1200 0100 4e00 0000 0000 0000 3400 0000 0000 0000  ).......N.......4.......
</span></span></code></pre></div><p>If we parse this data using the struct <code>Elf64_Sym</code>, we&rsquo;ll get something like this</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                             typedef struct {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  +------------------------------Elf64_Word    st_name;
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  |        +---------------------unsigned char st_info;
</span></span><span class=line><span class=cl>  |        |
</span></span><span class=line><span class=cl>  |        |     +---------------unsigned char st_other;
</span></span><span class=line><span class=cl>  |        |     |
</span></span><span class=line><span class=cl>  |        |     |    +----------Elf64_Section st_shndx;
</span></span><span class=line><span class=cl>  |        |     |    |
</span></span><span class=line><span class=cl>  |        |     |    |          Elf64_Addr    st_value;----+
</span></span><span class=line><span class=cl>  |        |     |    |                                     |
</span></span><span class=line><span class=cl>  |        |     |    |          Elf64_Xword   st_size;-----+-----------------+
</span></span><span class=line><span class=cl>  |        |     |    |                                     |                 |
</span></span><span class=line><span class=cl>  |        |     |    |      } Elf64_Sym;                   |                 |
</span></span><span class=line><span class=cl>  |        |     |    |                                     |                 |
</span></span><span class=line><span class=cl>  |        |     |    |                                     |                 |
</span></span><span class=line><span class=cl>  |        |     |    +-------------------+                 |                 |
</span></span><span class=line><span class=cl>  |        |     |                        |                 |                 |
</span></span><span class=line><span class=cl>  |        |     +------------------+     |                 |                 |
</span></span><span class=line><span class=cl>  |        |                        |     |                 |                 |
</span></span><span class=line><span class=cl>  |        +-------------------+    |     |                 |                 |
</span></span><span class=line><span class=cl>  |                            |    |     |                 |                 |
</span></span><span class=line><span class=cl>  +-------------------+        |    |     |                 |                 |
</span></span><span class=line><span class=cl>                      |        |    |     |                 |                 |
</span></span><span class=line><span class=cl>                      v        v    v     v                 v                 v
</span></span><span class=line><span class=cl>Index |  Offset  |
</span></span><span class=line><span class=cl>    0 | 000001a8:| 0000 0000 | 00 | 00 | 0000 | 0000 0000 0000 0000 | 0000 0000 0000 0000 |
</span></span><span class=line><span class=cl>    1 | 000001c0:| 0100 0000 | 04 | 00 | f1ff | 0000 0000 0000 0000 | 0000 0000 0000 0000 |
</span></span><span class=line><span class=cl>    2 | 000001d8:| 0000 0000 | 03 | 00 | 0100 | 0000 0000 0000 0000 | 0000 0000 0000 0000 |
</span></span><span class=line><span class=cl>    3 | 000001f0:| 1100 0000 | 12 | 00 | 0100 | 0000 0000 0000 0000 | 1a00 0000 0000 0000 |
</span></span><span class=line><span class=cl>    4 | 00000208:| 1900 0000 | 12 | 00 | 0100 | 1a00 0000 0000 0000 | 1a00 0000 0000 0000 |
</span></span><span class=line><span class=cl>    5 | 00000220:| 2100 0000 | 12 | 00 | 0100 | 3400 0000 0000 0000 | 1a00 0000 0000 0000 |
</span></span><span class=line><span class=cl>    6 | 00000238:| 2900 0000 | 12 | 00 | 0100 | 4e00 0000 0000 0000 | 3400 0000 0000 0000 |
</span></span></code></pre></div><p>From my parser, I got this result</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[  0 ] Name:                   Info: 0x00 (Bind: 0x0 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>[  1 ] Name: libarithmatic.c   Info: 0x04 (Bind: 0x0 | Type: 0x4)      Other: 0x0      Shndx: 0xfff1   Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>[  2 ] Name:                   Info: 0x03 (Bind: 0x0 | Type: 0x3)      Other: 0x0      Shndx: 0x1      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>[  3 ] Name: addFunc           Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0x1      Value: 0x000000000000   Size: 0x1a
</span></span><span class=line><span class=cl>[  4 ] Name: subFunc           Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0x1      Value: 0x00000000001a   Size: 0x1a
</span></span><span class=line><span class=cl>[  5 ] Name: mulFunc           Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0x1      Value: 0x000000000034   Size: 0x1a
</span></span><span class=line><span class=cl>[  6 ] Name: divFunc           Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0x1      Value: 0x00000000004e   Size: 0x34
</span></span></code></pre></div><p><img loading=lazy src=https://media.giphy.com/media/S5tVD09nBR2nJWJMen/giphy.gif#center alt></p><p>For the sake of simplicity and the scope of this article, I&rsquo;ll focus on discussing the four functions in this table and leave the rest for you to explore and learn.</p><p>We can observe that the <code>st_info</code> value for all of these symbols is the same, which implies that their &ldquo;<strong>bind</strong>&rdquo; and &ldquo;<strong>type</strong>&rdquo; values are identical (<em>duhh</em>). According to the information we&rsquo;ve gathered, these symbols are <code>GLOBAL</code> (bind=0x1) and of <code>FUNC</code> (type=0x2) type. This indicates that these symbols are basically global functions and can be called from other files as well.</p><p>It&rsquo;s worth noting that there&rsquo;s a very cool tool called <a href=https://github.com/elfmaster/ftrace/>"<strong>ftrace</strong>" by elfmaster</a>, which utilizes <a href=https://github.com/elfmaster/ftrace/blob/master/ftrace.c#L441>this information</a> to trace function calls, specifically focusing on function calls and not other symbols.</p><p>Furthermore, the <code>st_other</code> field is empty for these members, indicating <code>default</code> symbol visibility. There&rsquo;s nothing noteworthy to discuss here.</p><p>So we move on to the <code>sh_shndx</code> (section index) member. This member tells us that all of these symbols are associated with section <code>0x1</code> (which is <code>.text</code>, and that does make sense &ndash; Code of these functions should be in <code>.text</code> section only).</p><p>The <code>st_value</code> field indicates the offset within the <code>.text</code> section at which these functions begin. So, if you start executing instructions from offset <code>0x34</code> in the <code>.text</code> section, you&rsquo;ll be running the <code>mulFunc</code> function. <em>Makes sense??</em></p><p>The linker will perform <code>relocation</code> on the object files and generate a final executable binary that will have all the values in correct places. At that point we won&rsquo;t need the <code>mulFunc</code> string in our ELF file.</p><p>Last but not least, the <code>st_size</code> field provides the size of the function. This helps the magical entity reading the code determine when to stop and understand the boundaries of the function.</p><h3 id=2-maino>2. <code>main.o</code><a hidden class=anchor aria-hidden=true href=#2-maino>#</a></h3><p>Performing the same initial process for the <code>main.o</code> file, you will be able yield its symbol table, as shown below.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> [ 11 ] Section Name: .symtab       Type: 0x2       Flags: 0x0      Addr: 0x0       Offset: 0x248           Size: 312       Link: 12        Info: 0x4       Addralign: 0x8          Entsize: 24
</span></span><span class=line><span class=cl>     [  0 ] Name:                    Info: 0x00 (Bind: 0x0 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [  1 ] Name: main.c             Info: 0x04 (Bind: 0x0 | Type: 0x4)      Other: 0x0      Shndx: 0xfff1   Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [  2 ] Name:                    Info: 0x03 (Bind: 0x0 | Type: 0x3)      Other: 0x0      Shndx: 0x1      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [  3 ] Name:                    Info: 0x03 (Bind: 0x0 | Type: 0x3)      Other: 0x0      Shndx: 0x5      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [  4 ] Name: main               Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0x1      Value: 0x000000000000   Size: 0x143
</span></span><span class=line><span class=cl>     [  5 ] Name: printf             Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [  6 ] Name: __isoc99_scanf     Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [  7 ] Name: addFunc            Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [  8 ] Name: subFunc            Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [  9 ] Name: mulFunc            Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [ 10 ] Name: divFunc            Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [ 11 ] Name: puts               Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [ 12 ] Name: __stack_chk_fail   Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span></code></pre></div><p>In this case, things get a bit more interesting. Let&rsquo;s begin with the same set of symbols: <code>addFunc</code>, <code>subFunc</code>, <code>mulFunc</code>, and <code>divFunc</code>.</p><p>You&rsquo;ll notice that these symbols are global, but they don&rsquo;t have any associated types. This is expected since the symbols are not defined in this file; they are just being called. At this stage, we&rsquo;re not certain if there&rsquo;s anything like these symbols elsewhere, which is why all the other members are zeroed out (undefined). This essentially instructs the <em>magical</em> linker to locate the values of these symbols (linkers are pretty good at this; they will give errors if the symbols aren&rsquo;t found).</p><p>Now, you&rsquo;ll also notice the presence of <code>printf</code> and <code>puts</code> symbols. This may raise a question: &ldquo;<strong>I didn&rsquo;t use puts in my code, so why is it there?</strong>&rdquo;</p><p>Answer: It&rsquo;s compiler magic! The compiler observed that the line <code>printf("Enter equation (9 * 6): ");</code> could be expressed as <code>puts("Enter equation (9 * 6): ");</code>, so it made this conversion during compilation. To confirm this, you can generate the compiled code using <code>gcc -S</code> and check the <code>call</code> to <code>puts</code> function.</p><p>Now, let&rsquo;s examine our mighty <code>main</code> symbol. The <code>st_info</code> indicates that it&rsquo;s a <code>GLOBAL</code> <code>function</code> (with <code>bind=0x1</code> and <code>type=0x2</code>). This function is located in the 1st section (<code>sh_shndx: 0x1</code>) of <code>main.o</code>, which in our case is the <code>.text</code> section. The function begins at offset <code>0x0</code>, and its size is <code>0x143</code>. <em>Pretty simple, right?</em></p><p>(Note: I&rsquo;m leaving <code>__isoc99_scanf</code> and <code>__stack_chk_fail</code> for you. Google them!)</p><h3 id=3-calc>3. <code>calc</code><a hidden class=anchor aria-hidden=true href=#3-calc>#</a></h3><p>This represents the ultimate outcome of the entire compilation, assembly, and linking process &ndash; the final ELF executable binary. However, the process to obtain its <strong>symbol table</strong> remains same.</p><p>Here is the <code>symtab</code> for this ELF binary</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[ 27 ] Section Name: .symtab       Type: 0x2       Flags: 0x0      Addr: 0x0       Offset: 0x3050          Size: 768       Link: 28        Info: 0x7       Addralign: 0x8          Entsize: 24
</span></span><span class=line><span class=cl>     [  0 ] Name:                                 Info: 0x00 (Bind: 0x0 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [  1 ] Name: main.c                          Info: 0x04 (Bind: 0x0 | Type: 0x4)      Other: 0x0      Shndx: 0xfff1   Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [  2 ] Name: libarithmatic.c                 Info: 0x04 (Bind: 0x0 | Type: 0x4)      Other: 0x0      Shndx: 0xfff1   Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [  3 ] Name:                                 Info: 0x04 (Bind: 0x0 | Type: 0x4)      Other: 0x0      Shndx: 0xfff1   Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [  4 ] Name: _DYNAMIC                        Info: 0x01 (Bind: 0x0 | Type: 0x1)      Other: 0x0      Shndx: 0x15     Value: 0x000000003de0   Size: 0x0
</span></span><span class=line><span class=cl>     [  5 ] Name: __GNU_EH_FRAME_HDR              Info: 0x00 (Bind: 0x0 | Type: 0x0)      Other: 0x0      Shndx: 0x11     Value: 0x000000002048   Size: 0x0
</span></span><span class=line><span class=cl>     [  6 ] Name: _GLOBAL_OFFSET_TABLE_           Info: 0x01 (Bind: 0x0 | Type: 0x1)      Other: 0x0      Shndx: 0x17     Value: 0x000000003fe8   Size: 0x0
</span></span><span class=line><span class=cl>     [  7 ] Name: __libc_start_main@GLIBC_2.34    Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [  8 ] Name: _ITM_deregisterTMCloneTable     Info: 0x32 (Bind: 0x2 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [  9 ] Name: data_start                      Info: 0x32 (Bind: 0x2 | Type: 0x0)      Other: 0x0      Shndx: 0x18     Value: 0x000000004020   Size: 0x0
</span></span><span class=line><span class=cl>     [ 10 ] Name: subFunc                         Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0xe      Value: 0x0000000012c6   Size: 0x1a
</span></span><span class=line><span class=cl>     [ 11 ] Name: puts@GLIBC_2.2.5                Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [ 12 ] Name: _edata                          Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x18     Value: 0x000000004030   Size: 0x0
</span></span><span class=line><span class=cl>     [ 13 ] Name: _fini                           Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x2      Shndx: 0xf      Value: 0x000000001330   Size: 0x0
</span></span><span class=line><span class=cl>     [ 14 ] Name: __stack_chk_fail@GLIBC_2.4      Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [ 15 ] Name: printf@GLIBC_2.2.5              Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [ 16 ] Name: addFunc                         Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0xe      Value: 0x0000000012ac   Size: 0x1a
</span></span><span class=line><span class=cl>     [ 17 ] Name: __data_start                    Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x18     Value: 0x000000004020   Size: 0x0
</span></span><span class=line><span class=cl>     [ 18 ] Name: __gmon_start__                  Info: 0x32 (Bind: 0x2 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [ 19 ] Name: __dso_handle                    Info: 0x17 (Bind: 0x1 | Type: 0x1)      Other: 0x2      Shndx: 0x18     Value: 0x000000004028   Size: 0x0
</span></span><span class=line><span class=cl>     [ 20 ] Name: _IO_stdin_used                  Info: 0x17 (Bind: 0x1 | Type: 0x1)      Other: 0x0      Shndx: 0x10     Value: 0x000000002000   Size: 0x4
</span></span><span class=line><span class=cl>     [ 21 ] Name: divFunc                         Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0xe      Value: 0x0000000012fa   Size: 0x34
</span></span><span class=line><span class=cl>     [ 22 ] Name: _end                            Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x19     Value: 0x000000004038   Size: 0x0
</span></span><span class=line><span class=cl>     [ 23 ] Name: _start                          Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0xe      Value: 0x000000001070   Size: 0x26
</span></span><span class=line><span class=cl>     [ 24 ] Name: __bss_start                     Info: 0x16 (Bind: 0x1 | Type: 0x0)      Other: 0x0      Shndx: 0x19     Value: 0x000000004030   Size: 0x0
</span></span><span class=line><span class=cl>     [ 25 ] Name: mulFunc                         Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0xe      Value: 0x0000000012e0   Size: 0x1a
</span></span><span class=line><span class=cl>     [ 26 ] Name: main                            Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0xe      Value: 0x000000001169   Size: 0x143
</span></span><span class=line><span class=cl>     [ 27 ] Name: __isoc99_scanf@GLIBC_2.7        Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [ 28 ] Name: __TMC_END__                     Info: 0x17 (Bind: 0x1 | Type: 0x1)      Other: 0x2      Shndx: 0x18     Value: 0x000000004030   Size: 0x0
</span></span><span class=line><span class=cl>     [ 29 ] Name: _ITM_registerTMCloneTable       Info: 0x32 (Bind: 0x2 | Type: 0x0)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [ 30 ] Name: __cxa_finalize@GLIBC_2.2.5      Info: 0x34 (Bind: 0x2 | Type: 0x2)      Other: 0x0      Shndx: 0x0      Value: 0x000000000000   Size: 0x0
</span></span><span class=line><span class=cl>     [ 31 ] Name: _init                           Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x2      Shndx: 0xc      Value: 0x000000001000   Size: 0x0
</span></span></code></pre></div><p>The linking process did introduce numerous symbols that exceed the combined count of symbols in both individual object files. To keep things simple (* <em>once again</em> *), we won&rsquo;t dive into the specifics of what these additional symbols do, and we can think of them as a result of linker magic.</p><p>Our primary focus for now remains on the symbols and their properties, even if we don&rsquo;t have detailed knowledge of their functions.</p><p><img loading=lazy src=https://media.giphy.com/media/94OJTU1036zxU3OBhD/giphy.gif#center alt></p><p>These are the symbols we defined ourselves&mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[ 10 ] Name: subFunc                         Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0xe      Value: 0x0000000012c6   Size: 0x1a
</span></span><span class=line><span class=cl>[ 16 ] Name: addFunc                         Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0xe      Value: 0x0000000012ac   Size: 0x1a
</span></span><span class=line><span class=cl>[ 21 ] Name: divFunc                         Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0xe      Value: 0x0000000012fa   Size: 0x34
</span></span><span class=line><span class=cl>[ 25 ] Name: mulFunc                         Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0xe      Value: 0x0000000012e0   Size: 0x1a
</span></span><span class=line><span class=cl>[ 26 ] Name: main                            Info: 0x18 (Bind: 0x1 | Type: 0x2)      Other: 0x0      Shndx: 0xe      Value: 0x000000001169   Size: 0x143
</span></span></code></pre></div><p>We can observe the similarities in various members between <code>libarithmatic.o</code> and <code>main.o</code>. The notable difference I can identify is the <code>sh_shndx</code> value, which has changed but still points to the <code>.text</code> section of <code>calc</code> file. The important point is that it should reference the <code>.text</code> section, regardless of the section index value.</p><p>Another difference is in the <code>st_value</code>. With the addition of numerous new symbols in this file, the positions of these symbols have shifted. Initially, we had the <code>main</code> function in <code>main.o</code> and <code>addFunc</code> in <code>libarithmatic.o</code>, both at offset <code>0x0</code>. However, when combining them into a single file, one of them had to adjust its offset to make room for the other. This is precisely what occurred here, and there are also other symbols (of function type) that occupied the initial offsets, causing our defined functions to compromise on their offsets.</p><p>One more intriguing detail is the <code>_start</code> symbol, which has an offset of <code>0x000000001070</code>. This offset serves as the <strong>entry point</strong> of our ELF executable binary. You can verify this using <code>readelf</code> or any method you prefer. If you happen to overwrite the <code>entrypoint</code> value in <code>ELF file headers</code>, you&rsquo;ll be calling some other function instead of <code>_start</code> function of <code>glibc</code>. Since <code>_start</code> function performs some startup actions for C runtime environment, so the modified binary may or may not work as intended.</p><p>I&rsquo;m sure that&rsquo;s enough for today, ta-ta!</p><p><img loading=lazy src=https://media.giphy.com/media/mP8GermRyOFWV8PQeq/giphy.gif#center alt></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://developer.ibm.com/articles/au-aix-symbol-visibility/>https://developer.ibm.com/articles/au-aix-symbol-visibility/</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://unix.stackexchange.com/questions/472660/what-are-difference-between-the-elf-symbol-visibility-levels>https://unix.stackexchange.com/questions/472660/what-are-difference-between-the-elf-symbol-visibility-levels</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ayedaemon.github.io/tags/c/>C</a></li><li><a href=https://ayedaemon.github.io/tags/elf/>ELF</a></li><li><a href=https://ayedaemon.github.io/tags/re/>RE</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ayedaemon.github.io/>Connected</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>