<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Elf Chronicles: PLT/GOT (7/?) | Connected</title>
<meta name=keywords content="C,ELF,RE"><meta name=description content="Exploring general concepts of dynamic linking with PLT and GOT tables"><meta name=author content="ayedaemon"><link rel=canonical href=https://ayedaemon.github.io/post/2024/04/elf-chronicles-plt-got/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://ayedaemon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ayedaemon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ayedaemon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ayedaemon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ayedaemon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Elf Chronicles: PLT/GOT (7/?)"><meta property="og:description" content="Exploring general concepts of dynamic linking with PLT and GOT tables"><meta property="og:type" content="article"><meta property="og:url" content="https://ayedaemon.github.io/post/2024/04/elf-chronicles-plt-got/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-04-03T20:17:56+05:30"><meta property="article:modified_time" content="2024-04-05T21:58:47+05:30"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/12/elf-chronicles-relocations/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/10/elf-chronicles-symbol-tables/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/10/elf-chronicles-string-tables/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/10/elf-chronicles-program-headers/"><meta property="og:see_also" content="https://ayedaemon.github.io/post/2023/10/elf-chronicles-section-headers/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Elf Chronicles: PLT/GOT (7/?)"><meta name=twitter:description content="Exploring general concepts of dynamic linking with PLT and GOT tables"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ayedaemon.github.io/post/"},{"@type":"ListItem","position":2,"name":"Elf Chronicles: PLT/GOT (7/?)","item":"https://ayedaemon.github.io/post/2024/04/elf-chronicles-plt-got/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Elf Chronicles: PLT/GOT (7/?)","name":"Elf Chronicles: PLT\/GOT (7\/?)","description":"Exploring general concepts of dynamic linking with PLT and GOT tables","keywords":["C","ELF","RE"],"articleBody":"Intro In earlier articles, we talked about various parts of an ELF file and the many steps needed to create an executable ELF file that can run on your computer.\n(Note: The steps are shown visually below; For the source code, check out the symbol table article in this series.)\n┌────────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ │ │ │ │ libarithmatic.c │ │ libarithmatic.h ├───────► │ main.c │ │ │ │ │ │ │ └─────────┬──────────┘ └─────────────────┘ └────────┬────────┘ │ │ │ │ │ /* Compile + assemble */ │ /* Compile + assemble */ │ │ │ │ ▼ ▼ ┌─────────────────────┐ ┌────────────────────┐ │ │ │ │ │ libarithmatic.o │ │ main.o │ │ │ │ │ └─────────┬───────────┘ └──────────┬─────────┘ │ │ │ │ │ │ │ │ │ /* Linking Magic */ │ └───────────────────────────────────┬──────────────────────────────────────┘ │ │ │ │ │ │ ▼ ┌────────────────┐ │ │ │ calc │ │ │ └────────────────┘ After completing this process, we have an ELF executable called calc. However, we didn’t directly include any library that contains definitions for functions like printf or scanf, which we used in our main.c file to input and output data. So, how does that work?\nAnswer: Dynamic linking (which is a complex topic, so for this article, we’ll just cover the basics).\nIf you use the file command on the calc executable, it will display interesting information such as dynamically linked and interpreter /lib64/ld-linux-x86-64.so.2.\n\u003e file calc calc: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=65b929ceea26ea5e9fb8df1b15f2ab24b5c43ff6, for GNU/Linux 4.4.0, not stripped Before we move forward, let’s discuss some basics about libraries and how Linux manages them. Linux supports two types of libraries: static and shared.\nStatic libraries are connected to a program directly during the compile time (linking phase), while dynamic libraries (also known as shared libraries) are loaded when the application is launched, and all symbol resolutions and bindings are done at runtime.\nDynamic or shared libraries can be handled in two ways: Either you link your program with the shared library and let Linux load the library when the program runs (dynamic linking) 1, or you can design your application so that it loads the library from a specified path and then calls a particular function within that library (dynamic loading). 2\nNow, looking at our calc binary, it’s evident that we’re using dynamic linking to handle functions like printf and scanf (Since we are not loading any other library in out code). If you have any background in C programming, you’ve likely heard of the standard C library (libc) at least once. libc contains definitions for many standard functions used by many C programs, including printf and scanf, which we need in our calc executable.\nSo, when we run the calc executable, Linux will figure out which libraries it needs to run and load them into the process memory space. Once that’s done, it’ll load the calc executable and resolve all the dynamic symbols it contains.\nIn newer systems, this loading and resolving process is done lazily. This means that libraries will only load and resolve when there’s demand for a specific symbol. This approach is called lazy binding, and it helps speed up the loading of calc itself.\nSince symbol resolution happens at runtime, the address of the resolved symbol needs to be stored somewhere so that we don’t have to resolve it every time it’s needed.\nGOT (GLobal Offset Table) and PLT (Procedure Linkage Table) Let’s visualize our situation: We need the address of the printf function to make a call, but we don’t know where in the process memory space the libc library will load, so we can’t determine the exact address for printf.\nHow can we call printf then?\nOne naive method would be to load libc into the process memory space, find the exact address for printf using libc’s base address, and then modify the .text section of calc to update the placeholder address of printf with the exact address. This seems straightforward and will work. However, with this approach, we’ll have to load the library separately for each instance of calc or any other program that relies on libc. This isn’t efficient because it would mean having many copies of the same library in memory, unless the library is completely read-only and never modified.\nAnother approach is to add a level of redirection to the this method. In this newer approach, we patch the .got and/or .got.plt section (which contains the Global Offset Table) of calc. The idea is that when the library is loaded, the dynamic linker examines the relocation, finds the exact address of printf, and patches the .got and/or .got.plt entry as required. Then, the calc binary refers to these tables to point to the right place. This way, everything works seamlessly!\nWhat does PLT do here ??\nThe PLT (Procedure Linkage Table) adds another level of redirection that utilizes the .got.plt section to keep track of function jumps. Essentially, the Global Offset Table (GOT) is a list of addresses from the libc, while the PLT is another list of addresses used as placeholders in the .text section of the calc binary.\nBy utilizing this combination of the PLT and the .got.plt section, there’s no need to directly patch the .text section of the calc binary. This approach offers security benefits as it avoids modifying the executable code, which could potentially introduce vulnerabilities or trigger security mechanisms designed to detect such modifications.\nSecurity benifits ++\nAnalysis It will become clearer when we examine the disassembly (which is my favorite part).\nAs usual, we’ll disassemble main function first. We don’t have to check everything here, just focus on printf and scanf call instructions.\n0x000055555555518f \u003c+38\u003e: call 0x555555555050 0x00005555555551b2 \u003c+73\u003e: call 0x555555555060 \u003c__isoc99_scanf@plt\u003e Interesting thing to note here is that they point to addresses which are just 0x555555555060 - 0x555555555050 = 16 bytes away from each other. I’m sure none of these functions can be defined in just 16 bytes.\nThis is the PLT stub, the area which is referred by .text section for all kinds of dynamic linked library calls.\n(gdb) x/3i 0x555555555050 0x555555555050 : jmp QWORD PTR [rip+0x2fba] # 0x555555558010 0x555555555056 : push 0x2 0x55555555505b : jmp 0x555555555020 (gdb) x/3i 0x555555555060 0x555555555060 \u003c__isoc99_scanf@plt\u003e: jmp QWORD PTR [rip+0x2fb2] # 0x555555558018 \u003c__isoc99_scanf@got.plt\u003e 0x555555555066 \u003c__isoc99_scanf@plt+6\u003e: push 0x3 0x55555555506b \u003c__isoc99_scanf@plt+11\u003e: jmp 0x555555555020 If you examine the first instructions in both, you’ll notice they both point to memory locations 0x555555558010 and 0x555555558018, which are the Global Offset Table (GOT) entries. These entries hold addresses of actual functions from the dynamic libraries. You can inspect these locations to find where the first instruction in the PLT stub is directing the jump to.\n(gdb) x/1x 0x555555558010 0x555555558010 : 0x55555056 (gdb) x/1x 0x555555558018 0x555555558018 \u003c__isoc99_scanf@got.plt\u003e: 0x55555066 Alright, since we’re using these functions for the first time, the steps of finding the function’s address and storing it in the Global Offset Table haven’t been completed yet (which is part of the lazy binding logic). So, the program jumps to the next step instead (0x55555056 and 0x55555066 respectively).\nIn next instruction from PLT stub, a certain number onto the stack… and then both of the PLT stubs jump to same address – 0x555555555020. This is the address which should trigger the dynamic symbol resolution process.\n(gdb) x/3i 0x555555555020 =\u003e 0x555555555020: push QWORD PTR [rip+0x2fca] # 0x555555557ff0 0x555555555026: jmp QWORD PTR [rip+0x2fcc] # 0x555555557ff8 0x55555555502c: nop DWORD PTR [rax+0x0] It pushes something (0x555555557ff0) to stack and then jumps to 0x555555557ff8 address which is actually _dl_runtime_resolve_xsavec function in our dynamic linker (/lib64/ld-linux-x86-64.so.2). This function will resolve the address for printf and scanf and then patch the GOT table for it.\nOnce that is done, you can check the patched entries in the GOT tables\n(gdb) x/1x 0x555555558010 0x555555558010 : 0xf7e16730 (gdb) x/1x 0x555555558018 0x555555558018 \u003c__isoc99_scanf@got.plt\u003e: 0xf7e16430 Now, these are the real addresses for the printf and scanf functions within the calc program’s memory space. With this completed, whenever calc needs to use printf or scanf, their addresses will already be stored in the GOT table, which can be accessed by the corresponding PLT stubs.\nConclusion In conclusion, dynamic linking plays a crucial role in how programs interact with shared libraries in Linux systems. By utilizing mechanisms like the Procedure Linkage Table (PLT) and the Global Offset Table (GOT), programs can efficiently access functions from shared libraries at runtime. This process involves lazy binding, where function addresses are resolved and stored in the GOT only when they are first called, optimizing performance and memory usage. Through this approach, programs like calc can seamlessly utilize functions like printf and scanf without the need for manual intervention or redundant loading of shared libraries. Overall, dynamic linking provides a flexible and efficient way for programs to access external functionality, enhancing the functionality and usability of software on Linux platforms.\nResources https://developer.ibm.com/tutorials/l-dynamic-libraries/ https://opensource.com/article/22/5/dynamic-linking-modular-libraries-linux https://www.baeldung.com/cs/dynamic-linking-vs-dynamic-loading#2-dynamic-linking ↩︎\nhttps://www.baeldung.com/cs/dynamic-linking-vs-dynamic-loading#loading ↩︎\n","wordCount":"1475","inLanguage":"en","datePublished":"2024-04-03T20:17:56+05:30","dateModified":"2024-04-05T21:58:47+05:30","author":[{"@type":"Person","name":"ayedaemon"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://ayedaemon.github.io/post/2024/04/elf-chronicles-plt-got/"},"publisher":{"@type":"Organization","name":"Connected","logo":{"@type":"ImageObject","url":"https://ayedaemon.github.io/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://ayedaemon.github.io/ accesskey=h title="Connected (Alt + H)">Connected</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://ayedaemon.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://ayedaemon.github.io/series/ title=Series><span>Series</span></a></li><li><a href=https://ayedaemon.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ayedaemon.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Elf Chronicles: PLT/GOT (7/?)</h1><div class=post-description>Exploring general concepts of dynamic linking with PLT and GOT tables</div><div class=post-meta><span title='2024-04-03 20:17:56 +0530 +0530'>April 3, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1475 words&nbsp;·&nbsp;ayedaemon&nbsp;|&nbsp;<a href=https://github.com/ayedaemon/ayedaemon.github.io/tree/main/content/post/2024/04/elf-chronicles-plt-got.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#intro aria-label=Intro>Intro</a></li><li><a href=#got-global-offset-table-and-plt-procedure-linkage-table aria-label="GOT (GLobal Offset Table) and PLT (Procedure Linkage Table)">GOT (GLobal Offset Table) and PLT (Procedure Linkage Table)</a></li><li><a href=#analysis aria-label=Analysis>Analysis</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#resources aria-label=Resources>Resources</a></li></ul></div></details></div><div class=post-content><h3 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h3><p>In earlier articles, we talked about various parts of an ELF file and the many steps needed to create an executable ELF file that can run on your computer.</p><p>(Note: The steps are shown visually below; For the source code, check out the symbol table article in this series.)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     ┌────────────────────┐                        ┌─────────────────┐         ┌─────────────────┐
</span></span><span class=line><span class=cl>     │                    │                        │                 │         │                 │
</span></span><span class=line><span class=cl>     │   libarithmatic.c  │                        │ libarithmatic.h ├───────► │     main.c      │
</span></span><span class=line><span class=cl>     │                    │                        │                 │         │                 │
</span></span><span class=line><span class=cl>     └─────────┬──────────┘                        └─────────────────┘         └────────┬────────┘
</span></span><span class=line><span class=cl>               │                                                                        │
</span></span><span class=line><span class=cl>               │                                                                        │
</span></span><span class=line><span class=cl>               │ /* Compile + assemble */                                               │ /* Compile + assemble */
</span></span><span class=line><span class=cl>               │                                                                        │
</span></span><span class=line><span class=cl>               │                                                                        │
</span></span><span class=line><span class=cl>               ▼                                                                        ▼
</span></span><span class=line><span class=cl>    ┌─────────────────────┐                                                   ┌────────────────────┐
</span></span><span class=line><span class=cl>    │                     │                                                   │                    │
</span></span><span class=line><span class=cl>    │   libarithmatic.o   │                                                   │       main.o       │
</span></span><span class=line><span class=cl>    │                     │                                                   │                    │
</span></span><span class=line><span class=cl>    └─────────┬───────────┘                                                   └──────────┬─────────┘
</span></span><span class=line><span class=cl>              │                                                                          │
</span></span><span class=line><span class=cl>              │                                                                          │
</span></span><span class=line><span class=cl>              │                                                                          │
</span></span><span class=line><span class=cl>              │                                                                          │
</span></span><span class=line><span class=cl>              │                          /* Linking Magic */                             │
</span></span><span class=line><span class=cl>              └───────────────────────────────────┬──────────────────────────────────────┘
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  │
</span></span><span class=line><span class=cl>                                                  ▼
</span></span><span class=line><span class=cl>                                           ┌────────────────┐
</span></span><span class=line><span class=cl>                                           │                │
</span></span><span class=line><span class=cl>                                           │     calc       │
</span></span><span class=line><span class=cl>                                           │                │
</span></span><span class=line><span class=cl>                                           └────────────────┘
</span></span></code></pre></div><p>After completing this process, we have an ELF executable called <code>calc</code>. However, we didn&rsquo;t directly include any library that contains definitions for functions like <code>printf</code> or <code>scanf</code>, which we used in our <code>main.c</code> file to input and output data. So, how does that work?</p><p>Answer: <strong>Dynamic linking</strong> (which is a complex topic, so for this article, we&rsquo;ll just cover the basics).</p><p>If you use the <code>file</code> command on the <code>calc</code> executable, it will display interesting information such as <code>dynamically linked</code> and <code>interpreter /lib64/ld-linux-x86-64.so.2</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; file calc
</span></span><span class=line><span class=cl>calc: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=65b929ceea26ea5e9fb8df1b15f2ab24b5c43ff6, for GNU/Linux 4.4.0, not stripped
</span></span></code></pre></div><p>Before we move forward, let&rsquo;s discuss some basics about libraries and how Linux manages them. Linux supports two types of libraries: <em>static</em> and <em>shared</em>.</p><p><em>Static</em> libraries are connected to a program directly during the compile time (linking phase), while dynamic libraries (also known as shared libraries) are loaded when the application is launched, and all symbol resolutions and bindings are done at runtime.</p><p><em>Dynamic</em> or <em>shared</em> libraries can be handled in two ways: Either you link your program with the shared library and let Linux load the library when the program runs (dynamic linking) <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, or you can design your application so that it loads the library from a specified path and then calls a particular function within that library (dynamic loading). <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><p>Now, looking at our <code>calc</code> binary, it&rsquo;s evident that we&rsquo;re using <strong>dynamic linking</strong> to handle functions like <code>printf</code> and <code>scanf</code> (Since we are not loading any other library in out code). If you have any background in C programming, you&rsquo;ve likely heard of the standard C library (<code>libc</code>) at least once. <code>libc</code> contains definitions for many standard functions used by many C programs, including <code>printf</code> and <code>scanf</code>, which we need in our <code>calc</code> executable.</p><p>So, when we run the <code>calc</code> executable, Linux will figure out which libraries it needs to run and load them into the process memory space. Once that&rsquo;s done, it&rsquo;ll load the <code>calc</code> executable and resolve all the dynamic symbols it contains.</p><p>In newer systems, this loading and resolving process is done lazily. This means that libraries will only load and resolve when there&rsquo;s demand for a specific symbol. This approach is called lazy binding, and it helps speed up the loading of <code>calc</code> itself.</p><p>Since symbol resolution happens at runtime, the address of the resolved symbol needs to be stored somewhere so that we don&rsquo;t have to resolve it every time it&rsquo;s needed.</p><h3 id=got-global-offset-table-and-plt-procedure-linkage-table>GOT (GLobal Offset Table) and PLT (Procedure Linkage Table)<a hidden class=anchor aria-hidden=true href=#got-global-offset-table-and-plt-procedure-linkage-table>#</a></h3><p>Let&rsquo;s visualize our situation: We need the address of the <code>printf</code> function to make a call, but we don&rsquo;t know where in the process memory space the <code>libc</code> library will load, so we can&rsquo;t determine the exact address for <code>printf</code>.</p><p>How can we call <code>printf</code> then?</p><p>One naive method would be to load <code>libc</code> into the process memory space, find the exact address for <code>printf</code> using <code>libc</code>&rsquo;s base address, and then modify the <code>.text</code> section of <code>calc</code> to update the placeholder address of <code>printf</code> with the exact address. This seems straightforward and will work. However, with this approach, we&rsquo;ll have to load the library separately for each instance of <code>calc</code> or any other program that relies on <code>libc</code>. This isn&rsquo;t efficient because it would mean having many copies of the same library in memory, unless the library is completely read-only and never modified.</p><p>Another approach is to add a level of redirection to the this method. In this newer approach, we patch the <code>.got</code> and/or <code>.got.plt</code> section (which contains the Global Offset Table) of <code>calc</code>. The idea is that when the library is loaded, the dynamic linker examines the relocation, finds the exact address of <code>printf</code>, and patches the <code>.got</code> and/or <code>.got.plt</code> entry as required. Then, the <code>calc</code> binary refers to these tables to point to the right place. This way, everything works seamlessly!</p><p><strong>What does PLT do here ??</strong></p><p>The PLT (Procedure Linkage Table) adds another level of redirection that utilizes the <code>.got.plt</code> section to keep track of function jumps. Essentially, the Global Offset Table (GOT) is a list of addresses from the <code>libc</code>, while the PLT is another list of addresses used as placeholders in the <code>.text</code> section of the <code>calc</code> binary.</p><p>By utilizing this combination of the PLT and the <code>.got.plt</code> section, there&rsquo;s no need to directly patch the <code>.text</code> section of the <code>calc</code> binary. This approach offers security benefits as it avoids modifying the executable code, which could potentially introduce vulnerabilities or trigger security mechanisms designed to detect such modifications.</p><p><em>Security benifits ++</em></p><h3 id=analysis>Analysis<a hidden class=anchor aria-hidden=true href=#analysis>#</a></h3><p>It will become clearer when we examine the disassembly (which is my favorite part).</p><p>As usual, we&rsquo;ll <strong>disas</strong>semble <strong>main</strong> function first. We don&rsquo;t have to check everything here, just focus on <code>printf</code> and <code>scanf</code> call instructions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0x000055555555518f &lt;+38&gt;:    call   0x555555555050 &lt;printf@plt&gt;
</span></span><span class=line><span class=cl>0x00005555555551b2 &lt;+73&gt;:    call   0x555555555060 &lt;__isoc99_scanf@plt&gt;
</span></span></code></pre></div><p>Interesting thing to note here is that they point to addresses which are just <em>0x555555555060 - 0x555555555050 = <code>16</code></em> bytes away from each other. I&rsquo;m sure none of these functions can be defined in just 16 bytes.</p><p>This is the PLT stub, the area which is referred by <code>.text</code> section for all kinds of dynamic linked library calls.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(gdb) x/3i 0x555555555050
</span></span><span class=line><span class=cl>   0x555555555050 &lt;printf@plt&gt;:         jmp    QWORD PTR [rip+0x2fba]        # 0x555555558010 &lt;printf@got.plt&gt;
</span></span><span class=line><span class=cl>   0x555555555056 &lt;printf@plt+6&gt;:       push   0x2
</span></span><span class=line><span class=cl>   0x55555555505b &lt;printf@plt+11&gt;:      jmp    0x555555555020
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(gdb) x/3i 0x555555555060
</span></span><span class=line><span class=cl>   0x555555555060 &lt;__isoc99_scanf@plt&gt;:         jmp    QWORD PTR [rip+0x2fb2]        # 0x555555558018 &lt;__isoc99_scanf@got.plt&gt;
</span></span><span class=line><span class=cl>   0x555555555066 &lt;__isoc99_scanf@plt+6&gt;:       push   0x3
</span></span><span class=line><span class=cl>   0x55555555506b &lt;__isoc99_scanf@plt+11&gt;:      jmp    0x555555555020
</span></span></code></pre></div><p>If you examine the first instructions in both, you&rsquo;ll notice they both point to memory locations <code>0x555555558010</code> and <code>0x555555558018</code>, which are the Global Offset Table (GOT) entries. These entries hold addresses of actual functions from the dynamic libraries. You can inspect these locations to find where the first instruction in the PLT stub is directing the jump to.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(gdb) x/1x 0x555555558010
</span></span><span class=line><span class=cl>0x555555558010 &lt;printf@got.plt&gt;:        0x55555056
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(gdb) x/1x 0x555555558018
</span></span><span class=line><span class=cl>0x555555558018 &lt;__isoc99_scanf@got.plt&gt;:        0x55555066
</span></span></code></pre></div><p>Alright, since we&rsquo;re using these functions for the first time, the steps of finding the function&rsquo;s address and storing it in the Global Offset Table haven&rsquo;t been completed yet (which is part of the lazy binding logic). So, the program jumps to the next step instead (<code>0x55555056</code> and <code>0x55555066</code> respectively).</p><p>In next instruction from PLT stub, a certain number onto the stack&mldr; and then both of the PLT stubs jump to same address &ndash; <code>0x555555555020</code>. This is the address which should trigger the dynamic symbol resolution process.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(gdb) x/3i 0x555555555020
</span></span><span class=line><span class=cl>=&gt; 0x555555555020:      push   QWORD PTR [rip+0x2fca]        # 0x555555557ff0
</span></span><span class=line><span class=cl>   0x555555555026:      jmp    QWORD PTR [rip+0x2fcc]        # 0x555555557ff8
</span></span><span class=line><span class=cl>   0x55555555502c:      nop    DWORD PTR [rax+0x0]
</span></span></code></pre></div><p>It pushes something (<code>0x555555557ff0</code>) to stack and then jumps to <code>0x555555557ff8</code> address which is actually <code>_dl_runtime_resolve_xsavec</code> function in our dynamic linker (<code>/lib64/ld-linux-x86-64.so.2</code>). This function will resolve the address for <code>printf</code> and <code>scanf</code> and then patch the GOT table for it.</p><p>Once that is done, you can check the patched entries in the GOT tables</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(gdb) x/1x 0x555555558010
</span></span><span class=line><span class=cl>0x555555558010 &lt;printf@got.plt&gt;:        0xf7e16730
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(gdb) x/1x 0x555555558018
</span></span><span class=line><span class=cl>0x555555558018 &lt;__isoc99_scanf@got.plt&gt;:        0xf7e16430
</span></span></code></pre></div><p>Now, these are the real addresses for the <code>printf</code> and <code>scanf</code> functions within the <code>calc</code> program&rsquo;s memory space. With this completed, whenever <code>calc</code> needs to use <code>printf</code> or <code>scanf</code>, their addresses will already be stored in the GOT table, which can be accessed by the corresponding PLT stubs.</p><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>In conclusion, dynamic linking plays a crucial role in how programs interact with shared libraries in Linux systems. By utilizing mechanisms like the Procedure Linkage Table (PLT) and the Global Offset Table (GOT), programs can efficiently access functions from shared libraries at runtime. This process involves lazy binding, where function addresses are resolved and stored in the GOT only when they are first called, optimizing performance and memory usage. Through this approach, programs like <code>calc</code> can seamlessly utilize functions like <code>printf</code> and <code>scanf</code> without the need for manual intervention or redundant loading of shared libraries. Overall, dynamic linking provides a flexible and efficient way for programs to access external functionality, enhancing the functionality and usability of software on Linux platforms.</p><hr><h3 id=resources>Resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h3><ul><li><a href=https://developer.ibm.com/tutorials/l-dynamic-libraries/>https://developer.ibm.com/tutorials/l-dynamic-libraries/</a></li><li><a href=https://opensource.com/article/22/5/dynamic-linking-modular-libraries-linux>https://opensource.com/article/22/5/dynamic-linking-modular-libraries-linux</a></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://www.baeldung.com/cs/dynamic-linking-vs-dynamic-loading#2-dynamic-linking>https://www.baeldung.com/cs/dynamic-linking-vs-dynamic-loading#2-dynamic-linking</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://www.baeldung.com/cs/dynamic-linking-vs-dynamic-loading#loading>https://www.baeldung.com/cs/dynamic-linking-vs-dynamic-loading#loading</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ayedaemon.github.io/tags/c/>C</a></li><li><a href=https://ayedaemon.github.io/tags/elf/>ELF</a></li><li><a href=https://ayedaemon.github.io/tags/re/>RE</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ayedaemon.github.io/>Connected</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>